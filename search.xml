<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构-排序（八）归并排序</title>
    <url>/2022/03/27/Sort8/</url>
    <content><![CDATA[<h1 id="数据结构-排序（八）归并排序"><a href="#数据结构-排序（八）归并排序" class="headerlink" title="数据结构-排序（八）归并排序"></a>数据结构-排序（八）归并排序</h1><p><img src="/2022/03/27/Sort8/1.png" alt></p>
<h2 id="一、算法思想"><a href="#一、算法思想" class="headerlink" title="一、算法思想"></a>一、算法思想</h2><blockquote>
<p><strong>归并：</strong> 将两个或两个以上的有序表组合成一个新有序表</p>
<p>2路归并排序：</p>
<p><strong>排序过程</strong></p>
<ol>
<li>初始序列看成n个有序子序列，每个子序列长度为1</li>
<li>两两合并，得到 ⌊ n / 2 ⌋ 个长度为2或1的有序子序列</li>
<li>再两两合并，重复直至得到一个长度为n的有序序列为止</li>
</ol>
<p><img src="/2022/03/27/Sort8/2.gif" alt></p>
<p>以上gif动图制作，图像来自网站：<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">VisuAlgo</a></p>
</blockquote>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> *b; <span class="comment">//辅助数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并操作</span></span><br><span class="line"><span class="comment"> * @param arr </span></span><br><span class="line"><span class="comment"> * @param low </span></span><br><span class="line"><span class="comment"> * @param mid </span></span><br><span class="line"><span class="comment"> * @param high </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123; <span class="comment">//讲arr数组复制到b数组</span></span><br><span class="line">        b[k] = arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &lt;= b[j]) &#123; <span class="comment">//将较小值赋值到A中</span></span><br><span class="line">            arr[k] = b[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        arr[k++] = b[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        arr[k++] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * @param arr </span></span><br><span class="line"><span class="comment"> * @param low </span></span><br><span class="line"><span class="comment"> * @param high </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>; <span class="comment">//中间划分</span></span><br><span class="line">            MergeSort(arr, low, mid);           <span class="comment">//左半部分归并排序</span></span><br><span class="line">            MergeSort(arr, mid + <span class="number">1</span>, high); <span class="comment">//右半部分归并排序</span></span><br><span class="line">            Merge(arr, low, mid, high); <span class="comment">//归并</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//辅助数组</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr堆排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    MergeSort(arr,<span class="number">0</span>, n - <span class="number">1</span> );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、算法效率分析"><a href="#三、算法效率分析" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h2><blockquote>
<p>⼆叉树的第h层最多有 <strong>$2^{h-1}$</strong>个结点；若树高为h，则应满足 <strong>$n\le2^{h-1}$</strong> 即 <strong>$h - 1 =  ⌈ log_2n ⌉$</strong></p>
<p><strong>结论：</strong> n个元素进⾏2路归并排序，<strong>归并趟数为$⌈ log_2n ⌉$</strong></p>
<p><strong>1、每趟归并时间复杂度为 O(n)</strong>，则<strong>算法时间复杂度为$O(nlong_2n)$</strong></p>
<p><strong>2、空间复杂度为O(n)</strong>，来⾃于辅助数组B</p>
<p><strong>3、稳定性：稳定</strong></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（七）堆排序</title>
    <url>/2022/03/22/Sort7/</url>
    <content><![CDATA[<h1 id="数据结构-排序（七）堆排序"><a href="#数据结构-排序（七）堆排序" class="headerlink" title="数据结构-排序（七）堆排序"></a>数据结构-排序（七）堆排序</h1><blockquote>
<p><strong>若n个关键字序列L[1…n] 满⾜下面某⼀条性质，则称为堆（Heap）</strong> ：<br><strong>①</strong> 若满足：L(i) ≥ L(2i)且L(i) ≥ L(2i+1) （1 ≤ i ≤n/2 ） —— 大根堆（大顶堆）</p>
<p><img src="/2022/03/22/Sort7/1.jpg" alt></p>
<p><strong>②</strong> 若满足：L(i) ≤ L(2i)且L(i) ≤ L(2i+1) （1 ≤ i ≤n/2 ） —— 小根堆（小顶堆）  </p>
<p><img src="/2022/03/22/Sort7/2.jpg" alt></p>
</blockquote>
<h2 id="1、建立大根堆"><a href="#1、建立大根堆" class="headerlink" title="1、建立大根堆"></a>1、建立大根堆</h2><blockquote>
<p>大根堆： 根 ≥ 左、右  </p>
<p><strong>思路：</strong>把所有非终端结点都检查⼀遍，是否满足大根堆的要求，如果不满足，则进行调整。检查当前结点是否满足<strong>根≥左、右。</strong>若不满足，将当前<strong>结点与更大的⼀个孩子互换。</strong>若元素互换破坏了下⼀级的堆，则采用相同的方法继续往下调整（小元素不断“下坠”）  </p>
<p>在顺序存储的完全⼆叉树中， <strong>非终端结点编号 i ≤ ⌊ n / 2 ⌋</strong>  </p>
</blockquote>
<h2 id="2、基于大根堆排序"><a href="#2、基于大根堆排序" class="headerlink" title="2、基于大根堆排序"></a>2、基于大根堆排序</h2><blockquote>
<p>堆排序：每⼀趟将堆顶元素加入有序子序列（与待排序序列中的最后⼀个元素交换）</p>
<p>选择排序：每⼀趟在待排序元素中选取关键字最大的元素加入有序子序列并将待排序元素序列再次调整为大根堆（小元素不断“下坠”）  </p>
<p><strong>图解示例请看6。</strong></p>
</blockquote>
<h2 id="3、堆的插入和删除"><a href="#3、堆的插入和删除" class="headerlink" title="3、堆的插入和删除"></a>3、堆的插入和删除</h2><blockquote>
<p><strong>1、插入</strong></p>
<p>对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将⼆者互换。新元素就这样⼀路“上升”，直到无法继续上升为止。</p>
<p><strong>每次“上升”调整需要对比一次关键字</strong></p>
<p><strong>2、删除</strong></p>
<p>被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止。</p>
<p><strong>每次“下坠”调整可能需要对比一次关键字，也可能需要对比两次关键字</strong></p>
</blockquote>
<h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以 k 为为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param k</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = arr[k]; <span class="comment">//暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123; <span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++; <span class="comment">//取key较大的子节点的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt;= arr[i]) <span class="comment">//筛选结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = arr[i]; <span class="comment">//修改arr[i]调整到双亲结点</span></span><br><span class="line">            k = i; <span class="comment">//修改k值，继续向下筛选</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    arr[k] = arr[<span class="number">0</span>]; <span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立大根堆</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大根堆排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(arr, len); <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(arr[i], arr[<span class="number">1</span>]);</span><br><span class="line">        HeadAdjust(arr, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr堆排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    HeadSort(arr, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、算法效率分析"><a href="#5、算法效率分析" class="headerlink" title="5、算法效率分析"></a>5、算法效率分析</h2><blockquote>
<p><strong>1、建堆过程时间复杂度</strong></p>
<p>结论：⼀个结点，每“下坠”⼀层，最多只需对比关键字2次<br>若树高为h，某结点在第 i 层，则将这个结点向下调整最多只需要“下坠” h-i 层，<strong>关键字对比次数不超过 2(h - i)</strong><br><strong>n个结点的完全二叉树树高 $h=⌊ log_2n ⌋ + 1$</strong>  </p>
<p>第 i 层最多有 $2^{i-1}$ 个结点，而只有第 1 ~ (h-1) 层的结点才有可能需要“下坠”调整。</p>
<p>将整颗树调整为大根堆，关键字对比次数不超过4n</p>
<p><strong>$\sum_{i=h-1}^{1}2^{i-1}*2(h-i)$</strong></p>
<p><strong>$=\sum_{i=h-1}^{1}2^i(h-i)$</strong></p>
<p><strong>$= \sum_{j=1}^{h-1}2^{h-j}*j $</strong></p>
<p><strong>$\le 2n\sum_{j=1}^{h-1}\frac{j}{2^j}$</strong></p>
<p><strong>$\le 4n$</strong></p>
<p><strong>建堆的过程</strong>，关键字对比次数不超过4n，<strong>建堆时间复杂度=O(n)</strong>  </p>
<p><strong>2、排序过程时间复杂度</strong></p>
<p>根节点最多“下坠” h-1 层，每下坠⼀层，而每“下坠”⼀层，最多只需对比关键字2次，</p>
<p>因此每⼀趟排序复杂度不超过 $O(h) = O(log_2n)$。<strong>共n-1 趟</strong>，<strong>总的时间复杂度 =$O(nlog_2n)$</strong></p>
<p><strong>3、堆排序</strong></p>
<p><strong>堆排序的空间复杂度：</strong>O(1) </p>
<p><strong>堆排序的时间复杂度：</strong>$O(n) + O(nlog_2n) = O(nlog_2n)$</p>
<p><strong>4、稳定性 ：</strong> <strong>不稳定</strong></p>
</blockquote>
<h2 id="6、示例"><a href="#6、示例" class="headerlink" title="6、示例"></a>6、示例</h2><blockquote>
<p><strong>示例：将数组a[8] = [1，4，7，2，5，8，3，6]建成大根堆。画出建堆过程。并画出堆排序过程</strong></p>
<p><strong>数组插入建堆过程图如下：</strong></p>
<p><img src="/2022/03/22/Sort7/3.png" alt></p>
</blockquote>
<blockquote>
<p><strong>堆排序示例图如下：</strong></p>
<p><img src="/2022/03/22/Sort7/5.jpg" alt></p>
</blockquote>
<blockquote>
<p><strong>删除示例图如下：</strong><br><img src="/2022/03/22/Sort7/4.png" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（六）简单选择排序</title>
    <url>/2022/03/20/Sort6/</url>
    <content><![CDATA[<h1 id="数据结构-排序（六）简单选择排序"><a href="#数据结构-排序（六）简单选择排序" class="headerlink" title="数据结构-排序（六）简单选择排序"></a>数据结构-排序（六）简单选择排序</h1><h2 id="一、算法思想"><a href="#一、算法思想" class="headerlink" title="一、算法思想"></a>一、算法思想</h2><blockquote>
<p><strong>选择排序算法思想：</strong> 每⼀趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。n个元素的简单选择排序需要 <strong>n-1 趟处理</strong></p>
<p><img src="/2022/03/20/Sort6/SelectSort.gif" alt="QuickSort"><br>以上gif动图制作，图像来自网站：<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">VisuAlgo</a></p>
</blockquote>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单选择排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">//n - 1趟</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i; <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">//再arr[i...n-1]中选择最小元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123; <span class="comment">//更新最小位置</span></span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> != i) &#123; <span class="comment">//交换最小值</span></span><br><span class="line">            swap(arr[i], arr[<span class="built_in">min</span>]); <span class="comment">//交换顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr简单选择排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    SelectSort(arr, n);c</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、算法效率分析"><a href="#三、算法效率分析" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h2><blockquote>
<p><strong>1、空间复杂度：</strong> <strong>O(1)</strong>  </p>
<p><strong>2、时间复杂度</strong></p>
<p>⽆论有序、逆序、还是乱序，⼀定需要 n-1 趟处理  </p>
<p><strong>比较次数 = (n - 1) + (n - 2 )+…+ 1 = $\frac{n(n-1)}{2}$ ；交换次数 &lt; n - 1；</strong></p>
<p><strong>时间复杂度：$O(n^2)$</strong>  </p>
<p><strong>3、稳定性：</strong> <strong>不稳定</strong>  </p>
<p><strong>4、适⽤性：</strong> <strong>既可以用于顺序表，也可用于链表</strong>  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SpringBoot和React的在线考试平台</title>
    <url>/2022/03/16/ExamOnline/</url>
    <content><![CDATA[<h1 id="1-系统背景和意义"><a href="#1-系统背景和意义" class="headerlink" title="1  系统背景和意义"></a>1  系统背景和意义</h1><h2 id="1-1-系统背景"><a href="#1-1-系统背景" class="headerlink" title="1.1  系统背景"></a>1.1  系统背景</h2><p>近年来随着计算机技术的飞跃发展，教学方式、考核方式也逐渐多样化，我们不再局限于传统的纸质考试。在线考试给人们带来了更大的便捷和更高效率。在新冠肺炎疫情影响下，学校和企业都受到一些影响，学生无法在教室进行试卷考试，线上教学迅速普及。目前，我国教育领域的人数巨大，且越来越多的学生面临着极大的考试压力和竞争压力，传统教学的模式已经无法满足学生日益增长的学习需求。因此，我们考虑开发在线考试系统。</p>
<h2 id="1-2-系统意义"><a href="#1-2-系统意义" class="headerlink" title="1.2  系统意义"></a>1.2  系统意义</h2><p>随着国家和社会水平的发展和提高，教育的重要性深入人心，教育的发展不仅可以改变个人的生活，还可以促进国家和社会的发展进步，逐步缩小教育资源差距，让教育资源匮乏的地区可以通过线上的方式享受到教育资源。传统的教学模式以老师为核心、以课堂教学为主要形式开展教学活动。老师传授知识并布置作业，学生接受知识并完成作业，在这样的教学模式中,老师与学生之间信息反馈的速度较慢，老师无法快速的了解每个学生的学习情况而对症下药。互联网与教育模式的结合，则大大了弥补了传统的教学流程和学习方式上的缺陷，使学习不再局限于课堂和书本，降低了每个人的学习成本，同时也减少了学生、老师之间信息反馈的时间成本。在线考试展现出了极大的优越性，随时随地，不使用纸张，不需人工整理，极大的方便了教师和考生。本产品的面向的对象为学校和企业，是一个高效、便捷、简单的在线考试平台，适用于各种考试、练习、培训、竞赛、笔试及作业，实现了考试考核，考试培训，人员管理，企业笔试等功能，对提高学习效率、促进公司发展、促进教育现代化具有重要的意义。</p>
<h1 id="2-系统分析"><a href="#2-系统分析" class="headerlink" title="2  系统分析"></a>2  系统分析</h1><p>对于任何一个系统，最终都是要由用户来使用的，因此从用户的角度出发，能够获得对系统最直接的认识，在最大程度上满足用户的需求，用户对系统也可能有额外的约束和限定。本章对该在线学习平台进行需求分析、性能分析和可行性分析。在需求分析中，将需求分为功能性需求、非功能性需求和系统交互设计需求。通过需求分析，满足用户使用平台进行学习的目标。</p>
<h2 id="2-1-功能性需求"><a href="#2-1-功能性需求" class="headerlink" title="2.1  功能性需求"></a>2.1  功能性需求</h2><p>功能性需求是指系统为满足用户的某种需要预期提供的功能和服务。本文通过用例，分角色对系统的功能性需求进行有效的分析汇总，从而获取最准确的用户功能性需求，用来指导后续的设计及开发。</p>
<h3 id="2-1-1-教师功能"><a href="#2-1-1-教师功能" class="headerlink" title="2.1.1  教师功能"></a>2.1.1  教师功能</h3><p><strong>教师功能为出卷人，有五大基本功能</strong>，用例图如图2.1。</p>
<p><img src="/2022/03/16/ExamOnline/1.png" alt></p>
<blockquote>
<p><strong>图2-1 教师用例图</strong></p>
</blockquote>
<p><strong>（1）    考试管理：</strong>教师端的试卷管理，教师端可以查看考试和发布考试。<br><strong>（2）    题库管理：</strong>试题的管理。<br><strong>（3）    试卷管理：</strong>试卷的管理。<br><strong>（4）    成绩管理：</strong>成绩的查看。<br><strong>（5）    群组管理：</strong>教师端可以对考生和群组进行管理。</p>
<h3 id="2-1-2-监考人员功能"><a href="#2-1-2-监考人员功能" class="headerlink" title="2.1.2  监考人员功能"></a>2.1.2  监考人员功能</h3><p>监考人可以在线监督考试<strong>（未实现）</strong>。用例图如图2-2所示。</p>
<p><img src="/2022/03/16/ExamOnline/2.png" alt></p>
<blockquote>
<p><strong>图2-2 监考人员用例图</strong></p>
</blockquote>
<p><strong>（1）    监考管理：</strong>监考人可以在线监督考试，可以查看学生答题情况和强制交卷。</p>
<h3 id="2-1-3-考生功能"><a href="#2-1-3-考生功能" class="headerlink" title="2.1.3  考生功能"></a>2.1.3  考生功能</h3><p><strong>考生有四大功能模块</strong>，用例图如图2-3所示。<br><img src="/2022/03/16/ExamOnline/3.png" alt></p>
<blockquote>
<p><strong>图2-3 考生用例图</strong></p>
</blockquote>
<p><strong>（1）    我的考试：</strong>考生端的考试管理。<br><strong>（2）    我的成绩：</strong>考生可以查看考试。<br><strong>（3）    我的群组：</strong>考生可以申请群组。<br><strong>（4）    登录注册：</strong>考生可以查看教师端发布的通知。</p>
<h3 id="2-1-4-管理员功能"><a href="#2-1-4-管理员功能" class="headerlink" title="2.1.4  管理员功能"></a>2.1.4  管理员功能</h3><p>管理员功能<strong>（未实现）</strong>如图2-4所示。</p>
<p><img src="/2022/03/16/ExamOnline/4.png" alt></p>
<blockquote>
<p><strong>图2-4 管理员用例图</strong></p>
</blockquote>
<p><strong>（1）审核试题：</strong>管理员审核试题。<br><strong>（2）审核试卷：</strong>管理员审核试卷。<br><strong>（3）管理考生：</strong>管理员对考生进行管理。<br><strong>（4）管理出卷人：</strong>管理员对出卷人进行管理。</p>
<h2 id="2-2-非功能性需求"><a href="#2-2-非功能性需求" class="headerlink" title="2.2  非功能性需求"></a>2.2  非功能性需求</h2><p>系统的非功能性需求是指软件产品为满足用户业务需求而必须具有的除功能性需求外的特性，通常包括对系统性能、可靠性、安全性、可维护性、可扩展性等方面的需求。<br>（1）保证用户数据和试题的安全，对重要的数据进行加密。<br>（2）系统具备健壮性、稳定性和好的移植性。<br>（3）可维护性的好坏直接影响到系统上线后的管理与维护。线上考试平台作为一个功能复杂的系统，涉及的模块较多，同时各模块之间的交互较多，因此在系统开发过程中应尽量实现高内聚、低耦合，以便系统上线后的管理与维护。<br>（4）实用性是用户最看重的特性之一。在线考试系统应最大程度满足用户的需求，对于考试所需的各项功能提供完善的实现与支持。</p>
<h2 id="2-3-系统交互式需求"><a href="#2-3-系统交互式需求" class="headerlink" title="2.3  系统交互式需求"></a>2.3  系统交互式需求</h2><p>系统的交互式需求是非常重要的，设计小组必须通过丰富的细节来确定和记录现有的工作流程，然后将信息整合组织起来以方便将其文档化。不同类型的产品往往在需求方面也存在较大差异，我们需要都需求提出特殊的要求。每个产品使用的用户是不同，每个用户有不同的能力和弱点，有着不同背景和文化，也需要讨论用户特性对产品设计中的一些特殊需求。<br>（1）系统要提供友好的用户界面。<br>（2）界面要为用户提供方便的导航。<br>（3）系统对于用户的误操作给出相应的提示。<br>（4）系统必须具备一定的防作弊能力，以防止部分考生在考试中通过非法操作，获取试题及答案。<br>（5）对考生考试时发生的故障进行处理。考生在考试过程中如果发生机器断电、意外退出、系统无响应等情况，需要对考生的考试现场进行保存，以便考试恢复后，能够恢复到故障前的界面情景，节省考生的考试时间。</p>
<h2 id="2-4-性能分析"><a href="#2-4-性能分析" class="headerlink" title="2.4  性能分析"></a>2.4  性能分析</h2><p>（1）时间特性：普通操作在3秒内得到响应，计算量最大的任务在1分钟内完成。<br>（2）易用性：系统用MS Internet Explorer实现用户界面，大量的图形元素直观的反映了系统功能，便于记忆。<br>（3）稳定：系统的稳定性非常重要，它将直接影响到各类用户的使用质量，所以系统必须保证的稳定运行。<br>（4）数据精确度：所有有关金额的数据域要求精确到小数点后2位。<br>（5）数据库容量要求：数据库容量要求能支持多企业、多用户访问。</p>
<h2 id="2-5-可行性分析"><a href="#2-5-可行性分析" class="headerlink" title="2.5  可行性分析"></a>2.5  可行性分析</h2><h3 id="2-5-1-技术可行性"><a href="#2-5-1-技术可行性" class="headerlink" title="2.5.1  技术可行性"></a>2.5.1  技术可行性</h3><p>在当前的限制条件下，该系统的功能目标可以达到；利用现有的SpringBoot和React等技术，该系统的功能可以实现；对开发人员的数量和质量满足程序开发的需要；在规定的期限内，本系统的开发可以完成。</p>
<h3 id="2-5-2-社会可行性"><a href="#2-5-2-社会可行性" class="headerlink" title="2.5.2  社会可行性"></a>2.5.2  社会可行性</h3><p>本项目不涉及在社会上或政治上引起侵权、破坏或其他责任问题。设计本项目的一切活动都在国家法律允许范围以内。系统开发和运行与国家的政策法规不存在任何冲突和抵触之处。</p>
<h3 id="2-5-3-经济可行性"><a href="#2-5-3-经济可行性" class="headerlink" title="2.5.3  经济可行性"></a>2.5.3  经济可行性</h3><p>本项目为自主开发项目，只需相应的开发设备、开发环境和服务器域名即可，无需过多支出，所以经济方面可行。</p>
<h3 id="2-5-4-安全可行性"><a href="#2-5-4-安全可行性" class="headerlink" title="2.5.4  安全可行性"></a>2.5.4  安全可行性</h3><p>该系统使用虚拟账号进行登录，不涉及用户真实身份信息。数据方面进行加密处理，且系统设有角色权限。系统的安全无疑是确保系统正常运行的首要保障，系统的设计将从访问控制、数据安全方面进行考虑。<br>（1）权限管理：通过设置角色和用户权限可以对用户访问控制。<br>（2）运行维护管理：进行系统数据库的备份，使系统数据不会因意外事故（如突然停电）而造成破坏，从而确保数据库内容的安全可靠性；安全性方面可行。<br>（3）数据保护：前后端接口数据交互进行数据加密。<br>（4）鉴权身份认证技术：接口访问时需要提交Token进行验证，防止恶意访问。</p>
<h2 id="3-1-系统整体功能结构"><a href="#3-1-系统整体功能结构" class="headerlink" title="3.1  系统整体功能结构"></a>3.1  系统整体功能结构</h2><p>本系统的整体功能结构图如图3-1所示。用户通过登陆界面进行登陆分别进入教师端和考试端，然后在后台管理界面进行相应功能的操作。</p>
<p><img src="/2022/03/16/ExamOnline/5.png" alt></p>
<blockquote>
<p><strong>图3-1 系统整体功能结构</strong></p>
</blockquote>
<h2 id="3-2-数据库设计"><a href="#3-2-数据库设计" class="headerlink" title="3.2  数据库设计"></a>3.2  数据库设计</h2><p>本系统采用MySQL数据库，使用Navicat可视化工具进行数据编辑。根据需求，数据库一共设计了15个表。</p>
<h3 id="3-2-1-逻辑结构设计"><a href="#3-2-1-逻辑结构设计" class="headerlink" title="3.2.1  逻辑结构设计"></a>3.2.1  逻辑结构设计</h3><p><strong>（1）用户表</strong><br>属性：用户ID、用户名、昵称、密码、邮箱、盐值、注册时间、角色。<br><strong>（2）群组信息表</strong><br>属性：群组ID、组名、群组成员、成员数量、创建时间。<br><strong>（3）进入群组申请表</strong><br>属性：群组ID、用户ID、用户昵称、用户描述、申请时间、申请状态。<br><strong>（4）用户群组关联表</strong><br>属性：群组ID、用户ID。<br><strong>（5）试题信息表</strong><br>属性：题目ID、题目题型、题目标签、题目问题、题目选项集合、题目答案集合。<br><strong>（6）试题选项表</strong><br>属性：选项ID、试题ID、选项序号、选项内容。<br><strong>（7）试题答案表</strong><br>属性：试题ID、选项序号、选项内容。<br><strong>（8）试卷表</strong><br>属性：试卷ID、试卷名称、试卷出卷人ID、试卷创建日期、试卷总分、试卷类型、试卷题目集合。<br><strong>（9）试卷题目表</strong><br>属性：试卷ID、试题ID、试题分数、试卷题目ID。<br><strong>（10）考试表</strong><br>属性：考试ID、试卷ID、考试创建者ID、考试名称、考试创建日期、考试权限、进入考试口令、考试状态、考试开始时间、考试结束时间、考试时长、考试参加群组。<br><strong>（11）允许考试群组信息表</strong><br>属性：考试ID、允许考试的群组ID。<br><strong>（12）考试完成信息表</strong><br>属性：考试ID、考生ID、考试试卷ID。<br><strong>（13）考生完成考试信息表</strong><br>属性：完成考试ID、考试试卷ID、考生ID、考生备注姓名、考生分数、考试总分、考试创建时间、考试创建者ID、考生做完的日期、考试状态、考生做完题目集合。<br><strong>（14）考生完成考试题目表</strong><br>属性：完成题目ID、完成考试ID、考试试题ID、考生答案集合、答案正确性。<br><strong>（15）考生完成考试题目答案表</strong><br>属性：完成题目ID、选项序号、题目答案、答案正确性。</p>
<h3 id="3-2-2-表结构设计"><a href="#3-2-2-表结构设计" class="headerlink" title="3.2.2  表结构设计"></a>3.2.2  表结构设计</h3><p>部分表结构如下：</p>
<blockquote>
<p><strong>表3-1 用户表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段说明</th>
<th>字段类型</th>
<th>是否为空</th>
<th>字段约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>用户ID</td>
<td>bigint</td>
<td>否</td>
<td>主键</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>username</td>
<td>用户名</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>nickname</td>
<td>网名</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>邮箱</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>salt</td>
<td>盐值</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>register_time</td>
<td>注册时间</td>
<td>datatime</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>role</td>
<td>角色</td>
<td>int</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-2 群组信息表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段说明</th>
<th>字段类型</th>
<th>是否为空</th>
<th>字段约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>群组ID</td>
<td>bigint</td>
<td>否</td>
<td>主键</td>
</tr>
<tr>
<td>group_name</td>
<td>群组名称</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>group_master</td>
<td>群组成员</td>
<td>bigint</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>create_time</td>
<td>创建时间</td>
<td>data</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>number</td>
<td>群组数量</td>
<td>int</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-3 试题表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段说明</th>
<th>字段类型</th>
<th>是否为空</th>
<th>字段约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>试题ID</td>
<td>bigint</td>
<td>否</td>
<td>主键</td>
</tr>
<tr>
<td>type</td>
<td>试题类型</td>
<td>int</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>question</td>
<td>试题问题</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>tag</td>
<td>试题分类</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-4 试卷表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段说明</th>
<th>字段类型</th>
<th>是否为空</th>
<th>字段约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>试卷ID</td>
<td>bigint</td>
<td>否</td>
<td>主键</td>
</tr>
<tr>
<td>name</td>
<td>试卷名称</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>create_user_id</td>
<td>创建试卷用户ID</td>
<td>bigint</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>create_data</td>
<td>创建日期</td>
<td>date</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>total_score</td>
<td>试卷总分</td>
<td>decimal</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>sort</td>
<td>试卷分类</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-5 考试表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段说明</th>
<th>字段类型</th>
<th>是否为空</th>
<th>字段约束</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>考试ID</td>
<td>bigint</td>
<td>否</td>
<td>主键</td>
</tr>
<tr>
<td>test_paper_id</td>
<td>试卷ID</td>
<td>bigint</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>create_user_id</td>
<td>创建考试用户ID</td>
<td>bigint</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>activity_name</td>
<td>考试名称</td>
<td>varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>create_data</td>
<td>创建日期</td>
<td>data</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>start_time</td>
<td>开始时间</td>
<td>datatime</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>end_time</td>
<td>结束时间</td>
<td>datatime</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>exam_duration</td>
<td>考试时间</td>
<td>int</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>is_private</td>
<td>是否私有</td>
<td>bit</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>private_code</td>
<td>密码</td>
<td>Varchar</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>status</td>
<td>考试状态</td>
<td>tinyint</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<p>数据库EER图如图3-2所示</p>
<p><img src="/2022/03/16/ExamOnline/6.png" alt></p>
<blockquote>
<p><strong>图3-2 数据库EER图</strong></p>
</blockquote>
<h2 id="3-3-技术设计"><a href="#3-3-技术设计" class="headerlink" title="3.3  技术设计"></a>3.3  技术设计</h2><p>本项目为<strong>SpringBoot和React的分布式，前后端分离项目</strong>。SpringBoot方便对外输出各种形式的服务，有非常简洁的安全策略集成，支持关系数据库和非关系数据库，自动管理依赖。React作为如今前端框架主流技术之一，使用虚拟DOM的概念，性能好，速度快，解决了跨浏览器问题，代码组件化，模块化，重用代码更容易，可维护性高。</p>
<h3 id="3-3-1-后端技术"><a href="#3-3-1-后端技术" class="headerlink" title="3.3.1  后端技术"></a>3.3.1  后端技术</h3><p>后端采用SpringBoot、Spring MVC、mybatis、redis、MD5、身份鉴权等技术。SpringBoot是基于Spring的框架，在继承Spring优良特性的同时改善了Spring存在的弊端。<strong>SpringBoot有以下优点</strong>：<br>（1）    保留了Spring框架的核心——IOC和AOP的思想，代码便于升级维护。<br>（2）    简化了Spring的繁琐配置，便于将开发集中于业务核心，快速创建独立运行的Spring项目；内部嵌入了Servlet，不再需要单独安装容器，可直接部署运行项目<br>（3）    支持优雅搭建Restful风格的微服务架构<br>（4）    兼容性强，整合主流开发框架无需配置。</p>
<h3 id="3-3-2-前端技术"><a href="#3-3-2-前端技术" class="headerlink" title="3.3.2  前端技术"></a>3.3.2  前端技术</h3><p>前端采用React.js、React-route、axios、ES6、less、babel、webpack等技术。React.js是一个用于构建用户界面的 JavaScript 库。<strong>React有以下优点：</strong><br>（1）    提升开发效率、代码可维护性和可阅读性增强。<br>（2）    虚拟DOM，高效速度快，跨浏览器兼容–React之所以速度快，是因为其独特的特征——虚拟DOM（Document Object Model）。<br>（3）    组件是react的核心，一个完整的react应用是由若干个组件搭建起来的，每个组件有自己的数据和方法，组件具体如何划分，需要根据不同的项目来确定。组件的特征是可复用，可维护性高。<br>（4）    React只是MVC中的View层，自己无法构建大型的应用，需要与已有的框架和库来配合，如：Flux（前端架构） 、Redux（状态管理）、Axios/Fetch（异步请求）等。</p>
<h2 id="3-4-界面设计"><a href="#3-4-界面设计" class="headerlink" title="3.4  界面设计"></a>3.4  界面设计</h2><p><strong>前端采用React框架搭建界面，采用蚂蚁金服开发的一款设计体系Ant Design</strong>。让设计者和开发者有更好的体验。<br>本项目一共设有六个界面，<strong>一是产品官方首页</strong>，用户可通过首页对本产品进行一个简单了解，如图3-3所示；<strong>二是注册界面</strong>，如图3-4所示；<strong>三是登录界面</strong>，如图3-5所示；<strong>四是教师端单界面</strong>，教师端采取单页面应用程序，对用户有良好的交互体验，页面显示流畅，采用响应式布局，结构更加清晰，如图3-6所示；<strong>五是考生端单界面</strong>，如图3-7所示；<strong>六是考试界面</strong>，考试界面设计简洁大方，页面更加美观，简洁大方，如图3-8所示。</p>
<p><img src="/2022/03/16/ExamOnline/7.png" alt></p>
<blockquote>
<p><strong>图3-3 产品首页图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/8.png" alt></p>
<blockquote>
<p><strong>图3-4 注册图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/9.png" alt></p>
<blockquote>
<p><strong>图3-5 登录图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/10.png" alt></p>
<blockquote>
<p><strong>图3-6 教师端后台管理图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/11.png" alt></p>
<blockquote>
<p><strong>图3-7 考生端图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/12.png" alt></p>
<blockquote>
<p><strong>图3-8 考试页面图</strong></p>
</blockquote>
<h2 id="3-5-接口设计"><a href="#3-5-接口设计" class="headerlink" title="3.5  接口设计"></a>3.5  接口设计</h2><p>​    线上考试平台一共实现了用户、群组、试题、试卷和考试等五套的restful风格的CRUD接口供前端调用。当用户登录后将会获取到该用户的Token作为身份权限，当用户请求时，需要将Token以请求头的方式发送到服务器，防止恶意调用接口，服务器将会判断身份。部分接口文档用例如下。</p>
<blockquote>
<p><strong>表3-1 用户接口表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>URL</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>登录</td>
<td>/main/userlogin</td>
<td>POST</td>
</tr>
<tr>
<td>注册</td>
<td>/user/register</td>
<td>POST</td>
</tr>
<tr>
<td>发送验证码</td>
<td>/main/get_email_code</td>
<td>POST</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-2 群组接口表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>URL</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>创建群组</td>
<td>/group/create_group</td>
<td>POST</td>
</tr>
<tr>
<td>查询群组</td>
<td>/group/select_group</td>
<td>GET</td>
</tr>
<tr>
<td>修改群组</td>
<td>/group/update_group</td>
<td>POST</td>
</tr>
<tr>
<td>删除群组</td>
<td>/group/delete_group_by_id</td>
<td>POST</td>
</tr>
<tr>
<td>申请加群</td>
<td>/group_request/add_request</td>
<td>POST</td>
</tr>
<tr>
<td>查询加群请求</td>
<td>/group_request/select_request</td>
<td>GET</td>
</tr>
<tr>
<td>群组批量通过加群请求</td>
<td>/group_request/pass_request</td>
<td>POST</td>
</tr>
<tr>
<td>群组批量拒绝加群请求</td>
<td>/group_request/refuse_request</td>
<td>POST</td>
</tr>
<tr>
<td>获取群组内成员</td>
<td>/group/select_group_users</td>
<td>POST</td>
</tr>
<tr>
<td>群组内删除成员</td>
<td>/group/delete_user_group</td>
<td>POST</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-3 试题接口表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>URL</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>添加试题</td>
<td>/subject/add_subject</td>
<td>POST</td>
</tr>
<tr>
<td>查询试题</td>
<td>/subject/select_subject</td>
<td>GET</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表3-4 试卷接口表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>URL</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查看试卷粗略信息</td>
<td>/test_paper/select_test_paper_no_detail</td>
<td>POST</td>
</tr>
<tr>
<td>新增试卷</td>
<td>/test_paper/add_test_paper</td>
<td>POST</td>
</tr>
</tbody></table>
<blockquote>
<p>   <strong>表3-5 考试接口表</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>接口名称</th>
<th>URL</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>创建考试</td>
<td>/exam/create_exam_activity</td>
<td>POST</td>
</tr>
<tr>
<td>查询考试</td>
<td>/exam/select_exam_activity</td>
<td>POST</td>
</tr>
<tr>
<td>修改考试</td>
<td>/exam/update_exam_activity</td>
<td>POST</td>
</tr>
<tr>
<td>考生端获取参加考试</td>
<td>/select_user_participant_exam</td>
<td>POST</td>
</tr>
<tr>
<td>获取试卷</td>
<td>/exam/take_part_in_exam</td>
<td>POST</td>
</tr>
<tr>
<td>完成试卷</td>
<td>/exam/finish_exam</td>
<td>POST</td>
</tr>
</tbody></table>
<h2 id="3-6-前端路由设计"><a href="#3-6-前端路由设计" class="headerlink" title="3.6  前端路由设计"></a>3.6  前端路由设计</h2><p>前端路由设计如图3-9所示。</p>
<p><img src="/2022/03/16/ExamOnline/13.png" alt></p>
<blockquote>
<p><strong>图3-9 前端路由设计图</strong></p>
</blockquote>
<h1 id="4-系统实现"><a href="#4-系统实现" class="headerlink" title="4  系统实现"></a>4  系统实现</h1><h2 id="4-1-系统功能模块设计与实现"><a href="#4-1-系统功能模块设计与实现" class="headerlink" title="4.1  系统功能模块设计与实现"></a>4.1  系统功能模块设计与实现</h2><p>​    在线考试系统的架构图如图4-1，系统包括四个逻辑层，分别是视图层、控制层、业务逻辑层、持久层，这样分层处理便于各层职能明确化，逻辑清晰化，同时可以降低系统的业务耦合度，便于业务修改与扩展。</p>
<p><img src="/2022/03/16/ExamOnline/14.png" alt></p>
<blockquote>
<p><strong>图4-1 总体架构图</strong></p>
</blockquote>
<h2 id="4-2-登录功能"><a href="#4-2-登录功能" class="headerlink" title="4.2  登录功能"></a>4.2  登录功能</h2><p>​    本系统具有一定的保密性，所以需要登陆，进入界面。登陆界面采用div+css布局。登录模块，通过登录自己的账号，根据该账号的注册身份进入相应的页面。界面展示图如图4-2所示。</p>
<p>​    登录顺序图如图4-3所示，用户通过登录界面，提交表单，前端通过Axios发送请求，后端在控制层接收请求及参数，控制层决定该请求由哪个业务进行处理，从而调用业务层，并将参数传给业务层，业务层进行详细的业务处理，调用数据层执行数据的操作，然后生成一个唯一的Token值，供用户请求使用。<br><img src="/2022/03/16/ExamOnline/15.png" alt></p>
<blockquote>
<p><strong>图4-2 登录界面</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/16.png" alt></p>
<blockquote>
<p><strong>4-3 登录顺序图</strong></p>
</blockquote>
<h2 id="4-3-教师端"><a href="#4-3-教师端" class="headerlink" title="4.3  教师端"></a>4.3  教师端</h2><h3 id="4-3-1-教师后台管理"><a href="#4-3-1-教师后台管理" class="headerlink" title="4.3.1 教师后台管理"></a>4.3.1 教师后台管理</h3><p>​    <strong>教师端后台管理界面Ant Design中的Layout布局，采用了单页面应用程序，支持响应式布局，分为顶栏、左侧导航栏和内容区域。</strong>后台管理界面架构进行了前端路由设计，没有页面之间的切换，通过异步获取数据以及数据的操作。后台管理主界面如图4-4所示。<strong>教师端一共有六大功能模块</strong>，首页是一个快捷路径和数据统计窗口，可以快速进行操作，并且可以查看所有试题数、试卷数和考试数。六大功能模块包括群组管理、考试管理、试卷管理、题库管理、成绩管理和申请通知。</p>
<p><img src="/2022/03/16/ExamOnline/17.png" alt></p>
<blockquote>
<p><strong>图4-4 教师端管理界面图</strong></p>
</blockquote>
<h3 id="4-3-2-群组管理模块"><a href="#4-3-2-群组管理模块" class="headerlink" title="4.3.2  群组管理模块"></a>4.3.2  群组管理模块</h3><p>教师端可以实现创建群组，修改群组，删除群组，添加群组内考生，删除群组内考生和导出群组内考生等功能，方便对考生进行管理，界面图如图4-5，群组顺序图如图4-6所示。</p>
<p><img src="/2022/03/16/ExamOnline/18.png" alt></p>
<blockquote>
<p><strong>图4-5 教师端群组管理图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/19.png" alt></p>
<blockquote>
<p><strong>4-6 群组管理顺序图</strong></p>
</blockquote>
<h3 id="4-3-3-成绩管理"><a href="#4-3-3-成绩管理" class="headerlink" title="4.3.3 成绩管理"></a>4.3.3 成绩管理</h3><p>教师端可以查看每一个考试中考生的成绩和试卷答题详情，并且可进行可视化分析和手动修改考生成绩，方便教师对考试情况有更直观的了解。成绩管理顺序图如图4-7所示，部分效果图如图4-8和图4-9所示。</p>
<p><img src="/2022/03/16/ExamOnline/20.png" alt></p>
<blockquote>
<p><strong>图4-7 成绩管理顺序图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/21.png" alt></p>
<blockquote>
<p><strong>图4-8 考试成绩可视化分析图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/22.png" alt></p>
<blockquote>
<p><strong>图4-9 查看考生试卷详情效果图</strong></p>
</blockquote>
<h3 id="4-3-4-题库管理模块"><a href="#4-3-4-题库管理模块" class="headerlink" title="4.3.4  题库管理模块"></a>4.3.4  题库管理模块</h3><p>教师端可实现查看题库，添加试题等功能，试题录入查看更加方便。顺序图如图4-10、效果图如图4-11和图4-12所示。</p>
<p><img src="/2022/03/16/ExamOnline/23.png" alt></p>
<blockquote>
<p><strong>图4-10 录入试题顺序图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/24.png" alt></p>
<blockquote>
<p><strong>图4-11 添加试题效果图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/25.png" alt></p>
<blockquote>
<p><strong>图4-12 查看试题效果图</strong></p>
</blockquote>
<h3 id="4-3-5-试卷管理模块"><a href="#4-3-5-试卷管理模块" class="headerlink" title="4.3.5  试卷管理模块"></a>4.3.5  试卷管理模块</h3><p>教师端可实现查看试卷试题，添加试题并创建试卷等功能，选题更加方便，试卷可用于考试直接选用。如图4-13和图4-14所示。</p>
<p><img src="/2022/03/16/ExamOnline/26.png" alt></p>
<blockquote>
<p><strong>图4-13 查看试卷试题图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/27.png" alt></p>
<blockquote>
<p><strong>图4-14 创建试卷图</strong></p>
</blockquote>
<h3 id="4-3-6-考试管理模块"><a href="#4-3-6-考试管理模块" class="headerlink" title="4.3.6  考试管理模块"></a>4.3.6  考试管理模块</h3><p>教师端可进行查看已发布考试和创建考试，修改考试信息和查看考试试题等操作，创建考试操作简单，实现一“创”即考。效果如图4-15和图4-16所示。</p>
<p><img src="/2022/03/16/ExamOnline/28.png" alt></p>
<blockquote>
<p><strong>图4-15 教师端考试管理效果图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/29.png" alt></p>
<blockquote>
<p><strong>图4-16 教师端创建考试效果图</strong></p>
</blockquote>
<h3 id="4-3-7-通知管理模块"><a href="#4-3-7-通知管理模块" class="headerlink" title="4.3.7 通知管理模块"></a>4.3.7 通知管理模块</h3><p>教师端可以对考生申请加入群组的通知进行管理，效果图如图4-17所示。</p>
<p><img src="/2022/03/16/ExamOnline/30.png" alt></p>
<blockquote>
<p><strong>图4-17 通知管理模块效果图</strong></p>
</blockquote>
<h2 id="4-4-考生端"><a href="#4-4-考生端" class="headerlink" title="4.4  考生端"></a>4.4  考生端</h2><p><strong>考生端有五大功能模块，包括我的考生，我的成绩，我的分组，我的通知和考试。</strong></p>
<h3 id="4-4-1-我的群组"><a href="#4-4-1-我的群组" class="headerlink" title="4.4.1 我的群组"></a>4.4.1 我的群组</h3><p>学生端可以实现搜索申请群组和查看已加入的群组等功能，组别清晰明了。考生申请加入群组顺序图如图4-18，效果图如图4-19所示。</p>
<p><img src="/2022/03/16/ExamOnline/31.png" alt></p>
<blockquote>
<p><strong>图4-18 申请加入群组顺序图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/32.png" alt></p>
<blockquote>
<p><strong>图4-19 考试端查看群组图</strong></p>
</blockquote>
<h3 id="4-4-2-我的考试"><a href="#4-4-2-我的考试" class="headerlink" title="4.4.2 我的考试"></a>4.4.2 我的考试</h3><p>考生可以查看可以参加的所有考试信息并在规定时间内参加考试。参加考试顺序图如图4-20所示，考试答题界面如图4-21所示。</p>
<p><img src="/2022/03/16/ExamOnline/33.png" alt></p>
<blockquote>
<p><strong>图4-20 参加考试顺序图</strong></p>
</blockquote>
<p><img src="/2022/03/16/ExamOnline/34.png" alt></p>
<blockquote>
<p><strong>图4-20 答题界面效果图</strong></p>
</blockquote>
<h3 id="4-4-3-我的成绩"><a href="#4-4-3-我的成绩" class="headerlink" title="4.4.3 我的成绩"></a>4.4.3 我的成绩</h3><p>考生端可以查看考生参加考试的成绩。效果图如图4-20所示。</p>
<p><img src="/2022/03/16/ExamOnline/35.png" alt></p>
<blockquote>
<p><strong>图4-21 我的成绩效果图</strong></p>
</blockquote>
<h3 id="4-4-4-我的通知"><a href="#4-4-4-我的通知" class="headerlink" title="4.4.4 我的通知"></a>4.4.4 我的通知</h3><p>考生端可以在我的通知接受教师端公布的通知和通过群组的消息。效果图如图4-22所示。</p>
<p><img src="/2022/03/16/ExamOnline/36.png" alt></p>
<blockquote>
<p><strong>图4-22 我的通知效果图</strong></p>
</blockquote>
<h2 id="4-5-系统关键问题解决"><a href="#4-5-系统关键问题解决" class="headerlink" title="4.5  系统关键问题解决"></a>4.5  系统关键问题解决</h2><h3 id="4-5-1-鉴权身份认证技术"><a href="#4-5-1-鉴权身份认证技术" class="headerlink" title="4.5.1  鉴权身份认证技术"></a>4.5.1  鉴权身份认证技术</h3><p>因为本次项目采用的前后端分离开发模式，为了防止接口恶意访问，进行CSRF攻击，系统采用了鉴权身份认证技术。简单来说就是用户在浏览器中输入用户和密码，后台服务器通过加密或者其他逻辑，生成一个Token。前端获取到Token，存储到cookie或者localStorage中，在接下来的请求中，将token通过url参数或者HTTP Header头部传入到服务器。服务器获取token值，通过查找数据库判断当前token是否有效，保证用户在一次访问内，能够重复使用用户信息而不需要查询。同时Token单点登录对于服务器端来讲，压力会比较小。并且在分布式上具有较大的优势。</p>
<h3 id="4-5-2-跨域"><a href="#4-5-2-跨域" class="headerlink" title="4.5.2  跨域"></a>4.5.2  跨域</h3><p>因为本项目采用B/S架构下的前后端分离开发模式，这种模式下首先需要解决的问题就是同源策略导致的跨域问题。同源策略是浏览器的一种安全机制，它是指浏览器会阻止对非同源页面的DOM操作以及XMLHttpRequest对象向非同源服务器发起http请求。虽然这些限制是十分必要的，但有时会影响我们的正常开发需求，尤其在前后端分离开发模式下，经常需要跨域进行业务交互。</p>
<p>目前业界常用的解决跨域的方法包括Jsonp、Ngnix反向代理和CORS跨域。本项目采用的是Ngnix反向代理技术解决跨域问题。</p>
<h1 id="5-项目感想"><a href="#5-项目感想" class="headerlink" title="5  项目感想"></a>5  项目感想</h1><p>本次实践项目是在线考试平台的设计与实现，该项目主要是实现了教师端和考生端，包括了群组管理、试题管理、试卷管理、考试管理、成绩管理、通知管理和考试等基本的功能。在这一段时间里，通过实践，我学会了不少知识。</p>
<p>在本产品的开发阶段，我们两人相互协作，完成后台各种逻辑的实现和可视化页面的创作，为了让用户有更好视觉效果和体验效果，我们尽最大努力去了解用户的需求，完成我们的产品。</p>
<p>项目开发阶段，我们决定使用SpringBoot和React开发网站，采用前后端分离开发模式，我们相互交流，探讨后端和前端的交互问题，优化前端数据相应时间和页面视觉效果，努力做到让用户满意。为了用户的操作简捷，我们的每一个操作流程都进行精心设计。当用户操作时，会有系统的提示，让用户拥有很好的交互体验。</p>
<p>在项目的创作过程中，我们都学到了很多东西，从一开始的项目构建，项目的设计分析，项目的分工，项目的实现，到最后的项目部署，我们都用心去制作，采用的项目框架都是经过我们用心思考，采用React框架，为未来功能的升级演进，服务优化和移动端的转化实现第一步。从我们团队分配任务后，我们各司其职，不断的学习新的知识，遇到难题，讨论解决，看官方文档学习。我们投入时间，去进行数据的优化，页面的美化，页面的响应式布局等，目的就是方便用户。最后我们脚踏实地地完成项目。</p>
<p>总而言之，经过了这次实战，自己的综合能力有了明显的提高，实战让我不仅仅学会知识，更是让我学会实践，将自己所学的知识运用出来，这也是以后非常重要的一个环节–学以致用。</p>]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（五）快速排序</title>
    <url>/2021/12/13/Sort5/</url>
    <content><![CDATA[<h1 id="数据结构-排序（五）快速排序"><a href="#数据结构-排序（五）快速排序" class="headerlink" title="数据结构-排序（五）快速排序"></a>数据结构-排序（五）快速排序</h1><h2 id="1、算法思想"><a href="#1、算法思想" class="headerlink" title="1、算法思想"></a>1、算法思想</h2><blockquote>
<p><strong>算法思想：</strong>在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取首元素），通过⼀趟排序将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上， 这个过程称为⼀次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有⼀个元素或空为止，即所有元素放在了其最终位置上。  </p>
<p><strong>举个栗子🌰</strong> ，将 <strong>4 1 6 2 9 3</strong> 进行快速排序</p>
<p>​    首先在这个序列中随便找一个基准数（pivot）。为了方便，<strong>通常让第一个数 4 作为基准数</strong>。接下来，需要将这个序列所有<strong>比基准数大的数放在4的右边</strong>，比准数小的数放在 4 的左边，即：</p>
<p>​         3    1    2    <u><strong>4</strong></u>    9    6</p>
<p>​    在初始状态下，数字4在序列的第一位。我们需要将 4 挪到中间的一个位置，假设这个位置是k。现在需要找这个k，并且以k为分界点，左边的数都小于等于4，右边的数都是大于等于4。</p>
<p>​    分别从初始序列“4   1   6   2   9   3”<strong>两端开始勘测</strong>。定义变量pivot存储基准数4，然后<strong>先从左往右</strong>找一个小于4的数，找到后，将其与放到左边，即放到4，4放到6，<strong>再从右往左</strong>找一个大于4的数，<strong>然后将其放到上一个小于基准数4的位置，即上个6，现在4的位置。</strong>这里可以<strong>用两个变量low 和 high，分别指向序列最左边和最右边（即两个哨兵）</strong>。刚开始的时候 <strong>“哨兵low”</strong> 指向序列最左边（即i=1）,指向数字4，<strong>“哨兵high”</strong>指向序列最右边（即j=6）,指向数字3。</p>
<p>​    <strong>哨兵high开始出动</strong>。因为基准数设置为最左边的数。<strong>哨兵high</strong>一步一步<strong>向左挪动</strong>（即<strong>high–</strong>），<strong>直到找到一个小于4的数停下来</strong>，<strong>哨兵j</strong>停在了数字3上。接下来<strong>哨兵high与哨兵low交换</strong></p>
<p><img src="/2021/12/13/Sort5/1.png" alt></p>
<p>交换后序列如下</p>
<p>​          <u><strong>3</strong></u>   1   6   2   9   <u><strong>4</strong></u></p>
<p><strong>接下来哨兵low再一步一步向右挪动（即low++）</strong>，<strong>直到找到一个大于4的数停下来</strong>。<strong>哨兵low</strong>停在了数字6上。<strong>哨兵low与哨兵high交换</strong></p>
<p><img src="/2021/12/13/Sort5/2.png" alt></p>
<p>交换后序列如下</p>
<p>​          <u><strong>3</strong></u>   1   <u><strong>4</strong></u>   2   9   <u><strong>6</strong></u></p>
<p>然后<strong>哨兵high,哨兵low</strong>继续移动<strong>直到相遇</strong>。<strong>然后将pivot赋值给哨兵</strong></p>
<p><img src="/2021/12/13/Sort5/3.png" alt></p>
<p>相遇后与基准数交换后的序列为：</p>
<p>​          3   1   2    <u><strong>4</strong></u>   9   6</p>
<p>现在基准数4已经归位，此时，我们以4(基准数)为分界点<strong>拆分为两个序列</strong>，左边为“3    1    2”，右边序列为“9    6”。接下来我们按照第一轮勘测的方法继续处理。<strong>直到不可拆分出新的子序列为止</strong>。</p>
<p><img src="/2021/12/13/Sort5/4.png" alt></p>
</blockquote>
<h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param low</span></span><br><span class="line"><span class="comment"> * @param high</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low]; <span class="comment">//第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) <span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">            --high;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot)  <span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">            ++low;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[high] = pivot; <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param low</span></span><br><span class="line"><span class="comment"> * @param high</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotPos = Partition(arr, low, high);</span><br><span class="line">        QuickSort1(arr, low, pivotPos - <span class="number">1</span>); <span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort1(arr, pivotPos + <span class="number">1</span>, high); <span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr快速排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    QuickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、算法效率分析"><a href="#3、算法效率分析" class="headerlink" title="3、算法效率分析"></a>3、算法效率分析</h2><blockquote>
<p>把n个元素组织成⼆叉树，⼆叉树的层数就是递归调用的层数<br>第⼀层QuickSort处理后：n个结点的⼆叉树最小高度 = ⌊log2n⌋ + 1  ；最大高度 = n</p>
<p><strong>1、空间复杂度： O(递归层数)</strong>  </p>
<p>最好空间复杂度：$O(log_2n)$</p>
<p>最坏空间复杂度：$O(n)$  </p>
<p><strong>2、时间复杂度 O(n*递归层数)</strong>  </p>
<p>最好时间复杂度：$O(nlog_2n)$  每次选的枢轴元素都能将序列划分成均匀的两部分  </p>
<p>最坏时间复杂度：$O(n^2)$  若序列原本就有序或逆序，则时、空复杂度最⾼（可优化，尽量选择可以把数据中分的枢轴元素。）  </p>
<p><strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong>  </p>
<p><strong>3、稳定性：不稳定</strong></p>
<p><strong>4、快速排序算法优化思路：</strong>尽量选择可以把数据中分的枢轴元素。<br>eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（四）冒泡排序</title>
    <url>/2021/12/01/Sort4/</url>
    <content><![CDATA[<h1 id="数据结构-排序（四）冒泡排序"><a href="#数据结构-排序（四）冒泡排序" class="headerlink" title="数据结构-排序（四）冒泡排序"></a>数据结构-排序（四）冒泡排序</h1><p><img src="/2021/12/01/Sort4/1.png" alt></p>
<h2 id="1、算法思想"><a href="#1、算法思想" class="headerlink" title="1、算法思想"></a>1、算法思想</h2><blockquote>
<p><strong>基于“交换”的排序：</strong> 根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置  </p>
<p><strong>冒泡排序的算法思想是：</strong> 每次<strong>比较两个相邻的元素</strong>，<strong>若为逆序（即A[i-1]&gt;A[i]）顺序错误，就把他们交换过来</strong>。从第一个元素起。比较相邻的元素，如果第一个比第一个大，就交换。然后继续比较，直到最大的数到最后一个。称这样过程为“⼀趟”冒泡排序。所有元素重复以上动作。直到序列比较完。 </p>
<p><strong>举个例子</strong>，需要对数组a[5,8,3,4,2]进行从小到大排序</p>
<p>从小到大排序就需要将最大的数冒到最后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++)&#123; <span class="comment">// 5个数排序，只用进行n-1趟，即4趟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line"><span class="comment">//从第1位开始比较直到最后一个归位的数，i可以认为为已经归位了几个数字</span></span><br><span class="line"><span class="comment">//第一趟 i = 0</span></span><br><span class="line">第一次: <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>   (j = <span class="number">0</span>) <span class="comment">//5和8比较</span></span><br><span class="line">第二次: <span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span>   (j = <span class="number">1</span>) <span class="comment">//8和3比较</span></span><br><span class="line">第三次: <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span> <span class="number">2</span>   (j = <span class="number">2</span>) <span class="comment">//8和4比较</span></span><br><span class="line">第四次: <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> [<span class="number">8</span>] (j = <span class="number">3</span>) <span class="comment">//8和2比较，8归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二趟 i = 1</span></span><br><span class="line">第一次: <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> [<span class="number">8</span>] (j = <span class="number">0</span>) <span class="comment">//5和3比较</span></span><br><span class="line">第二次: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> [<span class="number">8</span>] (j = <span class="number">1</span>) <span class="comment">//5和4比较</span></span><br><span class="line">第三次: <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> [<span class="number">8</span>] (j = <span class="number">2</span>) <span class="comment">//5和2比较，5归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三趟 i = 2</span></span><br><span class="line">第一次: <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> [<span class="number">5</span> <span class="number">8</span>] (j = <span class="number">0</span>) <span class="comment">//3和4比较</span></span><br><span class="line">第二次: <span class="number">3</span> <span class="number">2</span> [<span class="number">4</span> <span class="number">5</span> <span class="number">8</span>] (j = <span class="number">1</span>) <span class="comment">//4和2比较，4归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四趟 i = 3</span></span><br><span class="line">第一次: <span class="number">2</span> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span>] (j = <span class="number">0</span>) <span class="comment">//3和2比较，2,3归位</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/01/Sort4/2.gif" alt><br>以上gif动图制作，图像来自网站：<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">VisuAlgo</a></p>
</blockquote>
<h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123; <span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">//升序排列</span></span><br><span class="line">                <span class="comment">//arr[j] &gt; arr[j + 1] 降序排列</span></span><br><span class="line">                swap(arr[j], arr[j + <span class="number">1</span>]); <span class="comment">//交换顺序数值函数</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">//本趟遍历后没有交换顺序，说明已经有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"arr冒泡排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    BubbleSort(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出arr排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出arr初始数组</span><br><span class="line"><span class="number">12</span>  <span class="number">28</span>  <span class="number">20</span>  <span class="number">50</span>  <span class="number">48</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">28</span></span><br><span class="line">arr冒泡排序</span><br><span class="line">输出arr排序后数组</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">12</span>  <span class="number">20</span>  <span class="number">28</span>  <span class="number">28</span>  <span class="number">48</span>  <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h2 id="3、算法效率分析"><a href="#3、算法效率分析" class="headerlink" title="3、算法效率分析"></a>3、算法效率分析</h2><blockquote>
<p><strong>1、空间复杂度：</strong> $O(1)$  </p>
<p><strong>2、时间复杂度</strong></p>
<p><strong>最好情况（有序）：</strong>  $比较次数 = n - 1；交换次数 = 0；最好时间复杂度 = O(n)$</p>
<p><strong>最坏情况（逆序）：</strong>  </p>
<p>$比较次数 = (n - 1) + (n - 2 )+…+ 1 = \frac{n(n-1)}{2} = 交换次数；最坏时间复杂度 = O(n^2)$</p>
<p><strong>平均时间复杂度:</strong>  $O(n^2)$ </p>
<p><strong>3、稳定性：</strong> 稳定</p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（三）希尔排序</title>
    <url>/2021/12/01/Sort3/</url>
    <content><![CDATA[<h1 id="数据结构-排序（三）希尔排序"><a href="#数据结构-排序（三）希尔排序" class="headerlink" title="数据结构-排序（三）希尔排序"></a>数据结构-排序（三）希尔排序</h1><p><img src="/2021/12/01/Sort3/1.png" alt></p>
<h2 id="1、算法思想"><a href="#1、算法思想" class="headerlink" title="1、算法思想"></a>1、算法思想</h2><blockquote>
<p><strong>算法思想：</strong> </p>
<p>先追求表中元素部分有序，再逐渐逼近全局有序，先将待排序表分割成若干形如 $L[i, i + d, i + 2d,…, i + kd]$ 的“特殊”子表，对各个子表分别进行<strong>直接插入排序，缩小增量d</strong>，重复上述过程，直到d = 1为止。  <strong>第一趟一般d = n / 2，往后 d = d / 2 。每次将增量缩小⼀半</strong> </p>
<p><strong>例子：</strong></p>
<p>对数组【12  28  20  50  48  1  5  28】进行排序</p>
<p><strong>第一趟</strong></p>
<p><img src="/2021/12/01/Sort3/2.png" alt></p>
<p><strong>第二趟</strong></p>
<p><img src="/2021/12/01/Sort3/3.png" alt></p>
<p><strong>第三趟</strong></p>
<p><img src="/2021/12/01/Sort3/4.png" alt></p>
</blockquote>
<h2 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d, j;</span><br><span class="line">    <span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt;= <span class="number">1</span>; d = d / <span class="number">2</span>) &#123; <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d + <span class="number">1</span>; i &lt;= n ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - d]) &#123; <span class="comment">//arr[i]插入有序增量表</span></span><br><span class="line">                arr[<span class="number">0</span>] = arr[i]; <span class="comment">//暂存</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - d; j &gt; <span class="number">0</span> &amp;&amp; arr[<span class="number">0</span>] &lt; arr[j] ; j -= d) &#123;</span><br><span class="line">                    arr[j + d] = arr[j]; <span class="comment">//记录后移，查找插入位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + d] = arr[<span class="number">0</span>]; <span class="comment">//插入数据</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、算法复杂度分析"><a href="#3、算法复杂度分析" class="headerlink" title="3、算法复杂度分析"></a>3、算法复杂度分析</h2><blockquote>
<p><strong>时间复杂度：</strong>和增量序列 d1, d2, d3… 的选择有关，目前无法用数学手段证明确切的时间复杂度，最坏时间复杂度为 $O(n^2)$，当n在某个范围内时，可达$O(n^{1.3})$  </p>
<p><strong>空间复杂度：</strong> $O(1)$</p>
<p><strong>稳定性：</strong>不稳定</p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（二）插入排序</title>
    <url>/2021/11/24/Sort2/</url>
    <content><![CDATA[<h1 id="数据结构-排序（二）插入排序"><a href="#数据结构-排序（二）插入排序" class="headerlink" title="数据结构-排序（二）插入排序"></a>数据结构-排序（二）插入排序</h1><p><img src="/2021/11/24/Sort2/1.png" alt></p>
<h2 id="一、-直接插入排序"><a href="#一、-直接插入排序" class="headerlink" title="一、 直接插入排序"></a>一、 直接插入排序</h2><h3 id="1、算法思想"><a href="#1、算法思想" class="headerlink" title="1、算法思想"></a>1、算法思想</h3><blockquote>
<p><strong>算法思想：</strong> 每次将⼀个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插⼊完成。 </p>
<p><strong>排序过程：</strong></p>
<ul>
<li>整个排序过程为n-1趟插入，</li>
<li>先将序列中第1个记录看成是一个有序子序列，</li>
<li>然后从第2个记录开始，逐个进行插入，直至整个序列有序。</li>
</ul>
<p><img src="/2021/11/24/Sort2/2.gif" alt></p>
<p>以上gif动图制作，图像来自网站：<a href="https://visualgo.net/zh/sorting" target="_blank" rel="noopener">VisuAlgo</a></p>
<p>链表实现请参考：<a href="https://blog.csdn.net/weixin_43533538/article/details/121450105?spm=1001.2014.3001.5501" target="_blank" rel="noopener">链表实现直接插入排序</a></p>
</blockquote>
<h3 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * @param arr  数组</span></span><br><span class="line"><span class="comment"> * @param n  数据个数</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123; <span class="comment">//若关键字小于前驱</span></span><br><span class="line">            <span class="keyword">int</span> t = arr[i]; <span class="comment">//暂存关键字</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; t ; j--) &#123; <span class="comment">//检查前面排序的元素</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//所有大于t的元素完后挪位</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = t; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出数组</span></span><br><span class="line"><span class="comment"> * @param arr </span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出初始数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"直接插入排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InsertSort(arr, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"输出排序后数组"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PrintArray(arr, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出初始数组</span><br><span class="line"><span class="number">12</span>  <span class="number">28</span>  <span class="number">20</span>  <span class="number">50</span>  <span class="number">48</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">28</span></span><br><span class="line">直接插入排序</span><br><span class="line">输出排序后数组</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">12</span>  <span class="number">20</span>  <span class="number">28</span>  <span class="number">28</span>  <span class="number">48</span>  <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="3、算法效率分析"><a href="#3、算法效率分析" class="headerlink" title="3、算法效率分析"></a>3、算法效率分析</h3><blockquote>
<p><strong>1、空间复杂度：</strong> O(1)  </p>
<p><strong>2、时间复杂度：</strong> 主要来自对比关键字、移动元素若有 n 个元素，则需要 n-1 趟处理  </p>
<p><strong>最好情况：</strong>共n-1趟处理，每⼀趟只需要对比关键字1次，不⽤移动元素 </p>
<p><strong>最好时间复杂度—— O(n)</strong></p>
<p><strong>最坏情况：</strong><br>第1趟：对比关键字2次，移动元素3次<br>第2趟：对比关键字3次，移动元素4次<br>…<br>第 i 趟：对比关键字 i+1次，移动元素 i+2 次    </p>
<p><strong>最坏时间复杂度——$O(n^2)$</strong>  </p>
<p>最好时间复杂度（全部有序）：O(n)</p>
<p>最坏时间复杂度（全部逆序）：$O(n^2)$</p>
<p><strong>平均时间复杂度：$O(n^2)$</strong></p>
<p><strong>3、算法稳定性：</strong> 稳定  </p>
</blockquote>
<h2 id="二、折半插入排序"><a href="#二、折半插入排序" class="headerlink" title="二、折半插入排序"></a>二、折半插入排序</h2><h3 id="1、算法思想-1"><a href="#1、算法思想-1" class="headerlink" title="1、算法思想"></a>1、算法思想</h3><blockquote>
<p><strong>算法思想：</strong> 先用折半查找找到应该插⼊的位置，再移动元素  </p>
<ul>
<li>当 low &gt; high 时折半查找停止，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置  </li>
<li>当 A[mid] == A[0] 时，为了保证算法的<strong>“稳定性”</strong>，应继续在 mid 所指位置右边寻找插入位置  </li>
</ul>
</blockquote>
<h3 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折半插入排序</span></span><br><span class="line"><span class="comment"> * @param arr</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SplitInsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i]; <span class="comment">//暂存关键字</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = i - <span class="number">1</span>; <span class="comment">//折半查找范围</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">//折半查找</span></span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[<span class="number">0</span>]) &#123; <span class="comment">//查找左子表</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//查找右半子表</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span> ; --j) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//统一后移操作，空出插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[high + <span class="number">1</span>] = arr[<span class="number">0</span>]; <span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、算法效率分析-1"><a href="#3、算法效率分析-1" class="headerlink" title="3、算法效率分析"></a>3、算法效率分析</h3><blockquote>
<p><strong>1、空间复杂度：</strong> O(1)  </p>
<p><strong>2、时间复杂度：</strong></p>
<p>比起“直接插⼊排序”，比较关键字的次数减少了，但是移动元素的次数没变，整体来看<strong>时间复杂度依然是$O(n^2)$</strong>  </p>
<p><strong>3、算法稳定性：</strong> 稳定  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-排序（一）绪论</title>
    <url>/2021/11/23/Sort/</url>
    <content><![CDATA[<h2 id="数据结构-排序（一）绪论"><a href="#数据结构-排序（一）绪论" class="headerlink" title="数据结构-排序（一）绪论"></a>数据结构-排序（一）绪论</h2><blockquote>
<p>排序（Sort） ，就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。</p>
<p><strong>输入：</strong> n个记录$R_1, R_2,…, R_n$，对应的关键字为$k_1, k_2,…, k_n。$</p>
<p><strong>输出：</strong>输⼊序列的⼀个重排$R_1ʹ, R_2ʹ,…, R_nʹ，$使得有$k_1ʹ≤k_2ʹ≤…≤k_nʹ$（也可递减） </p>
<p><strong>排序算法的评价指标：</strong>①时间复杂度；②空间复杂度   </p>
<p><strong>算法的稳定性：</strong> 若待排序表中有两个元素$ R_i$ 和$ R_j$，其对应的关键字相同即$key_i= key_j$，且在排序前的前⾯$ R_i$ 和$ R_j$，若使⽤某⼀排序算法排序后， $ R_i$ 仍然在 $ R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
<p><strong>分类：</strong></p>
<ul>
<li>内部排序：数据都在内存里<strong>（关注如何使算法时、空复杂度更低 ）</strong></li>
<li>外部排序：数据太多，无法全部存在内存里<strong>（还要关注如何使读/写磁盘次数更少）</strong></li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th></th>
<th></th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>最好</td>
<td>最差</td>
<td>平均</td>
<td></td>
<td></td>
</tr>
<tr>
<td>直接插入排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不确定</td>
<td>$O(n^2)$</td>
<td>$O(n^{1.25}）～O（1.6n^{1.25}）$</td>
<td>$O(1)$</td>
<td><strong>不稳定</strong></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(n^2)$</td>
<td><strong>$O(nlog_2n)$</strong></td>
<td>$O(log_2n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td><strong>不稳定</strong></td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(nlog_2n)$</td>
<td><strong>$O(nlog_2n)$</strong></td>
<td>$O(1)$</td>
<td><strong>不稳定</strong></td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlog_2n)$</td>
<td>$O(nlog_2n)$</td>
<td><strong>$O(nlog_2n)$</strong></td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(d(n+rd))$</td>
<td>$O(d(n+rd))$</td>
<td>$O(d(n+rd))$</td>
<td>$O(n+rd)$</td>
<td>稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>时间空间复杂度网站推荐：<a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener">https://www.bigocheatsheet.com/</a></p>
<p><img src="/2021/11/23/Sort/1.png" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（十一）链表直接插入排序</title>
    <url>/2021/11/21/DSP11/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（十一）链表直接插入排序"><a href="#数据结构算法每日一练（十一）链表直接插入排序" class="headerlink" title="数据结构算法每日一练（十一）链表直接插入排序"></a>数据结构算法每日一练（十一）链表直接插入排序</h1><p><strong>难度：</strong>⭐⭐⭐</p>
<blockquote>
<p><strong>题目：</strong> 在链式存储结构上设计直接插入排序算法</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>（1）算法思想：</strong> 每次将⼀个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插⼊完成。 时间复杂度$O(n^2)$</p>
<p><strong>（2）实现步骤：</strong></p>
<ul>
<li>整个排序过程为n-1趟插入，</li>
<li>先将序列中第1个记录看成是一个有序子序列，</li>
<li>然后从第2个记录开始，逐个进行插入，直至整个序列有序。</li>
</ul>
<p><strong>（3）代码实现：</strong></p>
<p>链表实现参考: <a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * @param head  链表头结点</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkedList <span class="title">InsertSort</span><span class="params">(LinkedList head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="comment">//若链表为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LNode *sorted = head-&gt;next; <span class="comment">//表示已排序链表，指向链表第一个元素</span></span><br><span class="line">    LNode *curr = sorted-&gt;next; <span class="comment">//表示待排元素</span></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (sorted-&gt;data &lt;= curr-&gt;data) &#123; <span class="comment">//若已排最后一个元素元素小于待排元素，则不需要排序</span></span><br><span class="line">                sorted = sorted-&gt;next;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             LNode *prev = head; <span class="comment">//头结点</span></span><br><span class="line">             <span class="keyword">while</span> (prev-&gt;next-&gt;data &lt;= curr-&gt;data) &#123; <span class="comment">//从头结点开始遍历，找到小于待排元素的结点</span></span><br><span class="line">                 prev = prev-&gt;next;</span><br><span class="line">             &#125; <span class="comment">//while</span></span><br><span class="line">             sorted-&gt;next = curr-&gt;next; <span class="comment">//插入待排结点</span></span><br><span class="line">             curr-&gt;next = prev-&gt;next;</span><br><span class="line">             prev-&gt;next = curr;</span><br><span class="line">         &#125; <span class="comment">//else</span></span><br><span class="line">        curr = sorted-&gt;next;</span><br><span class="line">    &#125; <span class="comment">//while</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125; <span class="comment">//void</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/21/DSP11/LInsert.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺式结构</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * @param arr  数组</span></span><br><span class="line"><span class="comment"> * @param n  数据个数</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123; <span class="comment">//若关键字小于前驱</span></span><br><span class="line">            <span class="keyword">int</span> t = arr[i]; <span class="comment">//暂存关键字</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; t ; j--) &#123; <span class="comment">//检查前面排序的元素</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//所有大于t的元素完后挪位</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = t; <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125; <span class="comment">//if</span></span><br><span class="line">    &#125; <span class="comment">//for</span></span><br><span class="line">&#125; <span class="comment">//bool</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/21/DSP11/InsertSort.gif" alt></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（七）哈夫曼树</title>
    <url>/2021/11/21/Tree7/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（七）哈夫曼树📑"><a href="#数据结构-树和二叉树（七）哈夫曼树📑" class="headerlink" title="数据结构-树和二叉树（七）哈夫曼树📑"></a>数据结构-树和二叉树（七）哈夫曼树📑</h1><p><img src="/2021/11/21/Tree7/1.png" alt></p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><blockquote>
<p><strong>结点的权：</strong>有某种现实含义的数值（如：表示结点的重要性等）<br><strong>结点的带权路径长度：</strong> 从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积<br><strong>树的带权路径长度：</strong> 树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）<br>$$<br>WPL = \sum_{i=1}^{100}w_{i}l_{i}<br>$$<br>其中，<strong>w<del>i</del></strong> 是第 i 个叶节点所带的全值，<strong>l<del>i</del></strong> 是该叶节点到根结点的路径长度。</p>
<p><img src="/2021/11/21/Tree7/2.png" alt></p>
</blockquote>
<h2 id="2、构造"><a href="#2、构造" class="headerlink" title="2、构造"></a>2、构造</h2><blockquote>
<p>给定n个权值分别为w<del>1</del>, w<del>2</del>,…, w<del>n</del>的结点，<strong>构造哈夫曼树的算法描述</strong>如下：</p>
<ol>
<li><p>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</p>
</li>
<li><p>构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，</p>
<p>并且将新结点的权值置为左、右子树上根结点的权值之和。</p>
</li>
<li><p>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。</p>
</li>
<li><p>重复步骤2）和3），直至F中只剩下一棵树为止。  </p>
</li>
</ol>
<p>==特点：==</p>
<ol>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大</li>
<li>叶节点为n，哈夫曼树的结点总数为2n - 1。</li>
<li>哈夫曼树中<strong>不存在度为1</strong>的结点。</li>
<li>哈夫曼树并不唯一，但WPL必然相同且为最优  </li>
</ol>
<p><img src="/2021/11/21/Tree7/3.png" alt></p>
</blockquote>
<h2 id="3、哈夫曼编码"><a href="#3、哈夫曼编码" class="headerlink" title="3、哈夫曼编码"></a>3、哈夫曼编码</h2><blockquote>
<p><strong>固定长度编码</strong>——每个字符用相等长度的二进制位表示  </p>
<p><strong>可变长度编码</strong>——允许对不同字符用不等长的二进制位表示  </p>
<p>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码  </p>
<p>有哈夫曼树得到哈夫曼编码——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树  </p>
<p>🌰🌱（栗子）</p>
<p>某系统在通讯时，只出现C，A，S，T，B五种字符，其出现频率依次为2，4，2，3，3，试设计Huffman编码。</p>
<p>1、首先根据字符出现频率构造最优哈夫曼树，如图；</p>
<p><img src="/2021/11/21/Tree7/4.png" alt></p>
<p>2、根据哈夫曼树，得出哈夫曼编码；</p>
<p>T　 00</p>
<p>B 　01</p>
<p>A 　10</p>
<p>C 　110</p>
<p>S　 111</p>
<p>3、计算WPL</p>
<p>WPL = 2 * (3 + 3 + 4) + 3 * (2 + 2) = 32</p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（六）二叉平衡树</title>
    <url>/2021/11/20/Tree6/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（六）二叉平衡树-⚖"><a href="#数据结构-树和二叉树（六）二叉平衡树-⚖" class="headerlink" title="数据结构-树和二叉树（六）二叉平衡树 ⚖"></a>数据结构-树和二叉树（六）二叉平衡树 ⚖</h1><p><img src="/2021/11/20/Tree6/6.png" alt></p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><blockquote>
<p><strong>平衡二叉树</strong>（Balanced Binary Tree）， 简称<strong>平衡树（AVL树）</strong> ——树上任一结点的左子树和右子树的高度之差不超过1。<br><strong>结点的平衡因子</strong> = 左子树高 - 右子树高。  </p>
</blockquote>
<h2 id="2、AVL树的插入"><a href="#2、AVL树的插入" class="headerlink" title="2、AVL树的插入"></a>2、AVL树的插入</h2><h3 id="（1）LL平衡旋转"><a href="#（1）LL平衡旋转" class="headerlink" title="（1）LL平衡旋转"></a>（1）LL平衡旋转</h3><blockquote>
<p><strong>LL平衡旋转（ 右单旋转）</strong>。由于在结点A的左孩子（ L）的左子树（ L）上插入了新结点， A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要<strong>一次向右的旋转操作</strong>。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。  </p>
<p><img src="/2021/11/20/Tree6/1.png" alt></p>
</blockquote>
<h3 id="（2）RR平衡旋转"><a href="#（2）RR平衡旋转" class="headerlink" title="（2）RR平衡旋转"></a>（2）RR平衡旋转</h3><blockquote>
<p><strong>RR平衡旋转（ 左单旋转）</strong>。由于在结点A的右孩子（ R）的右子树（ R）上插入了新结点， A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要<strong>一次向左的旋转操作</strong>。将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。</p>
<p><img src="/2021/11/20/Tree6/2.png" alt></p>
</blockquote>
<h3 id="（3）LR平衡旋转"><a href="#（3）LR平衡旋转" class="headerlink" title="（3）LR平衡旋转"></a>（3）LR平衡旋转</h3><blockquote>
<p><strong>LR平衡旋转（先左后右双旋转）</strong>。由于在A的左孩子（L）的右子树（R）上插入新结点， A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行<strong>两次旋转操作，先左旋转后右旋转</strong>。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。</p>
<p><img src="/2021/11/20/Tree6/3.png" alt></p>
</blockquote>
<h3 id="（4）RL平衡旋转"><a href="#（4）RL平衡旋转" class="headerlink" title="（4）RL平衡旋转"></a>（4）RL平衡旋转</h3><blockquote>
<p><strong>RL平衡旋转（先右后左双旋转）</strong>。由于在A的右孩子（R）的左子树（L）上插入新结点， A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行<strong>两次旋转操作，先右旋转后左旋转</strong>。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置，然后再把该C结点向左上旋转提升到A结点的位置。</p>
<p><img src="/2021/11/20/Tree6/4.png" alt></p>
</blockquote>
<h2 id="3、查找效率分析"><a href="#3、查找效率分析" class="headerlink" title="3、查找效率分析"></a>3、查找效率分析</h2><blockquote>
<p>平衡二叉树—树上任一结点的左子树和右子树的高度之差不超过1  </p>
<p>若树高为h，则<strong>最坏情况下</strong>，查找一个关键字最多需要对比 h 次，即<strong>查找操作的时间复杂度不可能超过 $O(h)$</strong>  </p>
<p>假设以 n<del>h</del> 表示<strong>深度为 h</strong> 的平衡树中含有的最少结点数。</p>
<p>则有$n_0 = 0, n_1 = 1, n_2 = 2，$ 并且有$n_h = n_{h-1} + n_{h-2} + 1  $</p>
<p>可以证明含有n个结点的平衡二叉树的<strong>最大深度为$O(log_2n)$</strong> ， 平衡二叉树的<strong>平均查找长度为$O(log_2n)$</strong>  </p>
</blockquote>
<h2 id="4、例题"><a href="#4、例题" class="headerlink" title="4、例题"></a>4、例题</h2><blockquote>
<p><strong>题目：</strong> 按顺序插入【21，30，50，26，60，66，24】构建平衡二叉树，请画出插入并调整为平衡二叉树的过程。</p>
<p><strong>过程如下：</strong></p>
<p><img src="/2021/11/20/Tree6/5.jpg" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（十）年龄排序</title>
    <url>/2021/11/10/DSP10/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（十）年龄排序"><a href="#数据结构算法每日一练（十）年龄排序" class="headerlink" title="数据结构算法每日一练（十）年龄排序"></a>数据结构算法每日一练（十）年龄排序</h1><p><strong>难度：</strong> ⭐⭐</p>
<blockquote>
<p><strong>题目：</strong>一个公司有几万名在职员工，请设计一个排序算法，对公司所有员工的年龄进行排序，要求时间效率$O(n)$。可以使用辅助内存，但使用辅助空间不得超过$O(1)$</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>（1）基本思想：</strong>在职员工的年龄必然小于100岁，可以建立长度101的哈希表，用来表示每个年龄的员工个数，利用哈希表可以完成$O(n)$时间复杂度的排序。该思想类似于桶排序。<a href="https://blog.csdn.net/weixin_43533538/article/details/104077088" target="_blank" rel="noopener">桶排序介绍</a></p>
<p><strong>（2）实现步骤：</strong></p>
<p>① 建立哈希表，遍历整个年龄数组arr，遍历一个年龄，对应哈希表的值加1，时间复杂度$O(n)$</p>
<p>② 遍历整个哈希表，重排所有元素，直到每个哈希表的值为0，时间复杂度$O(n)$</p>
<p><strong>（3）代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hashsort</span><span class="params">(<span class="keyword">int</span> &amp;arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) <span class="comment">//建立哈希表</span></span><br><span class="line">        ++result[arr[i]];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">//年龄数组arr下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123; <span class="comment">//重排</span></span><br><span class="line">        <span class="keyword">while</span>(result[i] != <span class="number">0</span>) &#123; <span class="comment">//当哈希值不为0时继续</span></span><br><span class="line">            arr[index] = i; <span class="comment">//重新给年龄数组arr从头到尾赋值</span></span><br><span class="line">            index++;</span><br><span class="line">            --result[i]; <span class="comment">//哈希值减一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（五）二叉排序树</title>
    <url>/2021/10/24/Tree5/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（五）二叉排序树"><a href="#数据结构-树和二叉树（五）二叉排序树" class="headerlink" title="数据结构-树和二叉树（五）二叉排序树"></a>数据结构-树和二叉树（五）二叉排序树</h1><p><img src="/2021/10/24/Tree5/1.png" alt></p>
<h2 id="二叉排序树🚉"><a href="#二叉排序树🚉" class="headerlink" title="二叉排序树🚉"></a>二叉排序树🚉</h2><blockquote>
<p>二叉排序树，又称二叉查找树（ BST， Binary Search Tree）<br>一棵二叉树或者是空二叉树，或者是具有如下<strong>性质的二叉树：</strong></p>
<ol>
<li><p>左子树上所有结点的关键字均小于根结点的关键字；</p>
</li>
<li><p>右子树上所有结点的关键字均大于根结点的关键字。</p>
</li>
<li><p>左子树和右子树又各是一棵二叉排序树。  </p>
</li>
<li><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值  </p>
</li>
<li><p>进行中序遍历，可以得到一个递增的有序序列  </p>
</li>
</ol>
</blockquote>
<h3 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1 代码实现"></a>1 代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Wang on 2021/8/23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lChild</span>, *<span class="title">rChild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归插入</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBST</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *newNode = (BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        newNode-&gt;value = e;</span><br><span class="line">        newNode-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">        newNode-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">        T = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTNode *p = T, *parent = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;value == e) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"值已存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;value &gt; e) &#123;</span><br><span class="line">            p = p-&gt;lChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;value = e;</span><br><span class="line">    newNode-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    newNode-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;value &gt; e) &#123;</span><br><span class="line">        parent-&gt;lChild = newNode;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent-&gt;rChild = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归插入</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionInsertBST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *newNode = (BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        newNode-&gt;value = e;</span><br><span class="line">        newNode-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">        newNode-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">        T = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;value == e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"值已存在"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; T-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">return</span> RecursionInsertBST(T-&gt;rChild, e);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RecursionInsertBST(T-&gt;lChild, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造二叉排序树</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param str</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreatBST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        InsertBST(T, str[i]);</span><br><span class="line"><span class="comment">//      RecursionInsertBST(T, str[i]);</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归查找</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">SearchBST</span><span class="params">(BSTree T, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; e != T-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; T-&gt;value) &#123;</span><br><span class="line">            T = T-&gt;lChild;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            T = T-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归查找</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">RecursionSearchBST</span><span class="params">(BSTree T, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e == T-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (e &lt; T-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">return</span> RecursionSearchBST(T-&gt;lChild, e);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RecursionSearchBST(T-&gt;rChild, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找子树最小值结点即，父节点的直接后继结点</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">SearchMin</span><span class="params">(BSTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T-&gt;lChild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        T  = T-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> * @param e</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTNode *p = T;</span><br><span class="line">    BSTNode *parent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">0</span>; <span class="comment">//左子树0，右子树1</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; e != p-&gt;value) &#123;  <span class="comment">//寻找要删除的结点</span></span><br><span class="line">        parent = p; <span class="comment">//得其父节点</span></span><br><span class="line">        <span class="keyword">if</span> (e &lt; T-&gt;value) &#123;</span><br><span class="line">            p = p-&gt;lChild;</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;rChild;</span><br><span class="line">            tag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rChild == <span class="literal">nullptr</span> &amp;&amp; p-&gt;lChild == <span class="literal">nullptr</span>) &#123; <span class="comment">//左右子树为空，</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="number">0</span>) &#123;</span><br><span class="line">            parent-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;rChild == <span class="literal">nullptr</span> &amp;&amp; p-&gt;lChild != <span class="literal">nullptr</span>) &#123; <span class="comment">//右子树为空</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="number">0</span>) &#123;</span><br><span class="line">            parent-&gt;lChild = p-&gt;lChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;rChild = p-&gt;lChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;rChild != <span class="literal">nullptr</span> &amp;&amp; p-&gt;lChild == <span class="literal">nullptr</span>) &#123; <span class="comment">//左子树为空</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="number">0</span>) &#123;</span><br><span class="line">            parent-&gt;lChild = p-&gt;rChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;rChild = p-&gt;rChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 左右子树均不为空</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="number">0</span>) &#123;</span><br><span class="line">            BSTNode *t = SearchMin(p-&gt;lChild); <span class="comment">//寻找p结点右子树的最小结点</span></span><br><span class="line">            <span class="keyword">int</span> tValue = t-&gt;value;</span><br><span class="line">            DeleteBST(T, t-&gt;value); <span class="comment">//删除最小结点</span></span><br><span class="line">            p-&gt;value = tValue; <span class="comment">//将此结点替换到删除结点</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BSTNode *t = SearchMin(p-&gt;rChild);</span><br><span class="line">            <span class="keyword">int</span> tValue = t-&gt;value;</span><br><span class="line">            DeleteBST(T, t-&gt;value); <span class="comment">//删除最小结点</span></span><br><span class="line">            p-&gt;value = tValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BSTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrderTraversal(root-&gt;lChild);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    InOrderTraversal(root-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BSTree T;</span><br><span class="line">    T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">54</span>, <span class="number">20</span>, <span class="number">66</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">58</span>, <span class="number">79</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"创建二叉排序树"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    CreatBST(T, arr, len);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraversal(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找20子树"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraversal(SearchBST(T, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除结点20"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DeleteBST(T, <span class="number">20</span>);</span><br><span class="line">    InOrderTraversal(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">创建二叉排序树</span><br><span class="line">中序遍历</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">28</span>-&gt;<span class="number">40</span>-&gt;<span class="number">54</span>-&gt;<span class="number">58</span>-&gt;<span class="number">66</span>-&gt;<span class="number">79</span>-&gt;</span><br><span class="line">查找<span class="number">20</span>子树</span><br><span class="line"><span class="number">20</span>-&gt;<span class="number">28</span>-&gt;<span class="number">40</span>-&gt;</span><br><span class="line">删除结点<span class="number">20</span></span><br><span class="line"><span class="number">28</span>-&gt;<span class="number">40</span>-&gt;<span class="number">54</span>-&gt;<span class="number">58</span>-&gt;<span class="number">66</span>-&gt;<span class="number">79</span>-&gt;</span><br></pre></td></tr></table></figure>



<h3 id="2、查找效率分析"><a href="#2、查找效率分析" class="headerlink" title="2、查找效率分析"></a>2、查找效率分析</h3><blockquote>
<p>查找长度——在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度  </p>
<p>若树高h， 找到最下层的一个结点需要对比 h 次  </p>
<p><strong>最好情况：</strong> n个结点的二叉树最小高度为[log<del>2</del>n] + 1。平均查找长度 = O(log<del>2</del>n) </p>
<p><strong>最坏情况：</strong>每个结点只有一个分支，树高 h = 结点数n。 平均查找长度 = O(n)   </p>
<p><img src="/2021/10/24/Tree5/2.png" alt></p>
<p><img src="/2021/10/24/Tree5/3.png" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（四）树和森林</title>
    <url>/2021/10/01/Tree4/</url>
    <content><![CDATA[<h1 id="1-数据结构-树和二叉树（四）树和森林"><a href="#1-数据结构-树和二叉树（四）树和森林" class="headerlink" title="1 数据结构-树和二叉树（四）树和森林"></a>1 数据结构-树和二叉树（四）树和森林</h1><p><img src="/2021/10/01/Tree4/1.png" alt></p>
<h2 id="1-1-树的逻辑结构"><a href="#1-1-树的逻辑结构" class="headerlink" title="1.1 树的逻辑结构"></a>1.1 树的逻辑结构</h2><blockquote>
<p>树是n（n≥0）个结点的有限集合， n = 0时，称为<strong>空树</strong>，这是一种特殊情况。</p>
<p>在任意一棵<strong>非空树</strong>中应满足：</p>
<p>1、有且仅有一个特定的称为根的结点。</p>
<p>2、当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。  </p>
<p>树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。</p>
<p>树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p>
<ol>
<li>🌲除了根节点外，任何一个结点都有且仅有一个前驱  </li>
<li>🌳中所有结点可以有零个或多个后继</li>
</ol>
</blockquote>
<h2 id="1-2-双亲表示法"><a href="#1-2-双亲表示法" class="headerlink" title="1.2 双亲表示法"></a>1.2 双亲表示法</h2><blockquote>
<p><img src="/2021/10/01/Tree4/2.png" alt></p>
<p><img src="/2021/10/01/Tree4/3.png" alt></p>
</blockquote>
<h2 id="1-3-孩子表示法"><a href="#1-3-孩子表示法" class="headerlink" title="1.3 孩子表示法"></a>1.3 孩子表示法</h2><blockquote>
<p><img src="/2021/10/01/Tree4/4.png" alt></p>
</blockquote>
<h2 id="1-4-孩子兄弟表示法"><a href="#1-4-孩子兄弟表示法" class="headerlink" title="1.4 孩子兄弟表示法"></a>1.4 孩子兄弟表示法</h2><blockquote>
<img src="/2021/10/01/Tree4/Users\Wang\AppData\Roaming\Typora\typora-user-images\image-20210822104916075.png" alt="image-20210822104916075" style="zoom:80%;">
</blockquote>
<h2 id="1-5-树、森林与二叉树的转换"><a href="#1-5-树、森林与二叉树的转换" class="headerlink" title="1.5 树、森林与二叉树的转换"></a>1.5 树、森林与二叉树的转换</h2><blockquote>
<p><img src="/2021/10/01/Tree4/5.png" alt></p>
</blockquote>
<blockquote>
<p><img src="/2021/10/01/Tree4/6.png" alt></p>
</blockquote>
<h2 id="1-6-树和森林的遍历"><a href="#1-6-树和森林的遍历" class="headerlink" title="1.6 树和森林的遍历"></a>1.6 树和森林的遍历</h2><h3 id="1、树的遍历"><a href="#1、树的遍历" class="headerlink" title="1、树的遍历"></a>1、树的遍历</h3><h4 id="（1）先根遍历"><a href="#（1）先根遍历" class="headerlink" title="（1）先根遍历"></a>（1）先根遍历</h4><blockquote>
<p> 先根遍历。若树非空，先访问根结点，再依次对每棵子树进行先根遍历。  深度优先遍历  </p>
<p> 树的先根遍历序列与这棵树相应二叉树的先序序列相同    </p>
</blockquote>
<h4 id="（2）后根遍历"><a href="#（2）后根遍历" class="headerlink" title="（2）后根遍历"></a>（2）后根遍历</h4><blockquote>
<p>后根遍历。若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。  深度优先遍历  </p>
<p>树的后根遍历序列与这棵树相应二叉树的中序序列相同。  </p>
</blockquote>
<h4 id="（3）层次遍历"><a href="#（3）层次遍历" class="headerlink" title="（3）层次遍历"></a>（3）层次遍历</h4><blockquote>
<p>层次遍历（用队列实现）  广度优先遍历 </p>
<p>① 若树非空， 则根节点入队</p>
<p>② 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</p>
<p>③ 重复②直到队列为空  </p>
</blockquote>
<h3 id="2、森林的遍历"><a href="#2、森林的遍历" class="headerlink" title="2、森林的遍历"></a>2、森林的遍历</h3><h4 id="（1）先序遍历"><a href="#（1）先序遍历" class="headerlink" title="（1）先序遍历"></a>（1）先序遍历</h4><blockquote>
<p>先序遍历森林。</p>
<p>若森林为非空，则按如下规则进行遍历：</p>
<ol>
<li>访问森林中第一棵树的根结点。</li>
<li>先序遍历第一棵树中根结点的子树森林。</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
<p>效果等同于依次对各个树进行先根遍历  ，等同于依次对二叉树的先序遍历  </p>
</blockquote>
<h4 id="（2）中序遍历"><a href="#（2）中序遍历" class="headerlink" title="（2）中序遍历"></a>（2）中序遍历</h4><blockquote>
<p>中序遍历森林。</p>
<p>若森林为非空，则按如下规则进行遍历：</p>
<ol>
<li>中序遍历森林中第一棵树的根结点的子树森林。</li>
<li>访问第一棵树的根结点。</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。  </li>
</ol>
<p>效果等同于依次对各个树进行后根遍历  ，等同于依次对二叉树的中序遍历  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（九）查找链表倒数元素</title>
    <url>/2021/10/01/DSP9/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（九）查找链表倒数元素"><a href="#数据结构算法每日一练（九）查找链表倒数元素" class="headerlink" title="数据结构算法每日一练（九）查找链表倒数元素"></a>数据结构算法每日一练（九）查找链表倒数元素</h1><p><strong>难度：</strong> ⭐⭐</p>
<blockquote>
<p><strong>题目：</strong> 已知一个带有表头结点的单链表，假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数</p>
<p>第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求:</p>
<p>（1）描述算法的基本设计思想。</p>
<p>（2）描述算法的详细实现步骤。</p>
<p>（3）根据设计思想和实现步骤，采用程序设计语言描述算法(使用C、C++或Java语言实现)，关键之处请给出简要注释。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>（1）基本思想：</strong> 如果设计一个尽可能高效的算法，则需要遍历一遍链表便找到链表中倒数第k个位置上的结点，可以定义两个指针变量p和q，初始时，均指向链表的第一个结点，开始遍历时，p指针先沿链表移动，当p指针移动到第k个结点时，q指针开始与p指针同步移动，当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。（<strong>如果遍历链表两遍也可以实现，但不是最优算法</strong>，即先遍历一遍得到链表结点数量n，然后再遍历n-k次即可实现）</p>
<p><strong>（2）实现步骤</strong></p>
<p>① 设置count计数，count=0，p和q指向头指针的下一个结点。</p>
<p>② 若p为空，则转⑤。</p>
<p>③ 若count = k，则 q指向下一个结点 （q=q-&gt;next）；否则，count = count+1。</p>
<p>④ p指向下一个结点（p=p-&gt;next），转②。</p>
<p>⑤ 若count = k，则查找成功，输出该结点的data域值，返回1；否则，k值超过链表长度，查找失败，返回0。</p>
<p>⑥ 算法结束。</p>
<p><strong>（3）算法实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType; <span class="comment">//链表数据的类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">//结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//结点链接指针</span></span><br><span class="line">&#125;LNode, *LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param LinkedList list 单链表头指针</span></span><br><span class="line"><span class="comment"> * @param int k 查找的位置 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(LinkedList <span class="built_in">list</span>, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LNode *p = <span class="built_in">list</span>-&gt;next, *q = <span class="built_in">list</span>-&gt;next; <span class="comment">//指针p，q指示第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//位置计数</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; k) <span class="comment">//计数，如果count&lt;k, 只移动p</span></span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q = q-&gt;next; <span class="comment">//否则，p，q同步移动</span></span><br><span class="line">    	p = p-&gt;next; <span class="comment">// p移动</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">if</span>(count &lt; k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//查找失败，返回0</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q-&gt;data &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//查找成功，输出数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（八）数组循环队列</title>
    <url>/2021/09/30/DSP8/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（八）数组循环队列"><a href="#数据结构算法每日一练（八）数组循环队列" class="headerlink" title="数据结构算法每日一练（八）数组循环队列"></a>数据结构算法每日一练（八）数组循环队列</h1><p><strong>难度：</strong> ⭐⭐</p>
<blockquote>
<p>题目：下面是给定容量为MAX的使用循环数组实现队列的代码片段，其中T是队列中元素类型。</p>
<p>static int const MAX = 256; //队列的最大容量</p>
<p>static T* data; //循环数组，队列元素存储在此</p>
<p>static 其他必要数据;</p>
<p>（1）请给出循环数组实现队列所需的其他必要数据的定义；</p>
<p>（2）请使用循环数组实现队列的下述六个功能函数，请首先用语言描述实现的方法，再给出C/C++语言的具体实现。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>​    void ini(); //初始化函数</p>
<p>​    int size(); //返回队列中元素个数</p>
<p>​    bool full(); //判满函数</p>
<p>​    bool empty(); //判空函数</p>
<p>​    T front(); //返回队头元素; T是元素类型</p>
<p>​    void push(T v); //入队</p>
<p>​    void pop(); //出队</p>
</blockquote>
<blockquote>
<p>（1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    T* data; <span class="comment">//存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front, rear; <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<ol>
<li><strong>void ini(); //初始化函数</strong></li>
</ol>
<p>首先将数组初始化，将队头指针和队尾指针设置初始值为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ini</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.data = <span class="keyword">new</span> T[MAX]; <span class="comment">//数组初始化 </span></span><br><span class="line">	Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>int size(); //返回队列中元素个数</strong></li>
</ol>
<p>队尾指针减去队头指针，然后加上MAX，然后取模MAX。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">init <span class="title">size</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAX) % MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>bool full(); //判满函数</strong></li>
</ol>
<p>当队尾指针加1取模等于队头指针时，判满。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear + <span class="number">1</span>) % MAX == Q.front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>bool empty(); //判空函数</strong></li>
</ol>
<p>当队头指针等于队尾指针时，队列为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>T front(); //返回队头元素; T是元素类型</strong></li>
</ol>
<p>先判断队列是否为空，若为空则返回-1，否则返回队头指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">front</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> Q.data[Q.front]; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>void push(T v); //入队</strong></li>
</ol>
<p>当入队时，先判断队列是否满，不满，则将数据加入队尾指针，然后队尾指针加1取模。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(SqQueue &amp;Q, T v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(full(Q))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Q.data[Q.rear] = v;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>void pop(); //出队</strong></li>
</ol>
<p>判断队列是否为空，若不为空，则先取出队头指针的数据，然后队头指针加1取模。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(SqQueue &amp;Q, T &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(empty(Q))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAX; <span class="comment">//队头指针加1取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（七）数组未出现最小正整数</title>
    <url>/2021/09/25/DSP7/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（七）数组未出现最小正整数"><a href="#数据结构算法每日一练（七）数组未出现最小正整数" class="headerlink" title="数据结构算法每日一练（七）数组未出现最小正整数"></a>数据结构算法每日一练（七）数组未出现最小正整数</h1><p><strong>难度：</strong> ⭐⭐</p>
<blockquote>
<p><strong>题目：</strong>给定一个含n（n≥1）个整数的数组A，请设计一个在时间上尽可能高效的算法。找出数组中未出现的最小正整数。例如，数组{-5，3，2，3}</p>
<p>中未出现的最小正整数是1；数组{1，2，3}中未出现的最小正整数是4。要求：</p>
<p>1）给出算法的基本设计思想。</p>
<p>2）根据设计思想，来用C或C++语言描述算法，关键之处给出注释。</p>
<p>3）说明你所设计算法的时问复杂度和空问复杂度。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>（1）<strong>基本思想：</strong> 时间上尽可能高效的算法，采用空间换时间的方式，采用桶排序算法思想。分配一个用于标记的数组 B[n]，用来记录A中是否出现了 1 ~ n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化B中全部为 0。由于A中含有n个整数，因此可能返回的值是 1 ~ n+1，当A中n个数恰好为 1 ~ n时返回 n+1。当数组A中出现了小于等于0或大于n的值时，会导致 1 ~ n中出现空余位置，返回结果必然在 1 ~ n中，因此对于A中出现了小于等于 0或大于n的值，可以不采取任何操作。</p>
<p>经过以上分析可以得出算法流程：</p>
<ol>
<li>从A[0]开始遍历A,若 0 &lt; A[i] &lt;= n,则令 B[A[i]-1]=1；否则不做操作。</li>
<li>对A遍历结束后，开始遍历数组B，若能查找到第一个满足 B[i]==0 的下标 i,返回i+1即为结果，此时说明A中未出现的最小正整数在 1~n之间。</li>
<li>若 B[i]全部不为0，返回i+1（跳出循环时 i=n， i+1 等于n+1），此时说明A中未出现的最小正整数是n+1。</li>
</ol>
<p>本题思想与上道数组主元素算法一基本思想相同</p>
<p>（2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMissMin</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *B;</span><br><span class="line">    B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); <span class="comment">//分配空间</span></span><br><span class="line">    <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); <span class="comment">//赋初值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//遍历A数组</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; <span class="number">0</span> &amp;&amp; A[i] &lt;= n) &#123; <span class="comment">//若A[i]的值介于1~n,则标记数组B</span></span><br><span class="line">            B[ A[i] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//遍历B数组，找到未出现的最小正整数</span></span><br><span class="line">        <span class="keyword">if</span> (B[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">-3</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> res = findMissMin(A, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）</p>
<p>时间复杂度为$O(n)$，空间复杂度为$O(n)$</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（三）二叉树线索化</title>
    <url>/2021/09/25/Tree3/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（三）二叉树线索化"><a href="#数据结构-树和二叉树（三）二叉树线索化" class="headerlink" title="数据结构-树和二叉树（三）二叉树线索化"></a>数据结构-树和二叉树（三）二叉树线索化</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/25/Tree3/1.png" alt></p>
<p><img src="/2021/09/25/Tree3/2.png" alt></p>
<p><img src="/2021/09/25/Tree3/3.png" alt></p>
<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><blockquote>
<p>普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得，</p>
<p>若将遍历后对应的有关前驱和后继预存起来，则从第一个结点开始就能很快“顺藤摸瓜”而遍历整个树。</p>
<p><strong>思路：</strong></p>
<p>若结点有左子树，则lchild指向其左孩子；否则，lchild指向其直接前驱(即线索)；</p>
<p>若结点有右子树，则rchild指向其右孩子；否则，rchild指向其直接后继(即线索) 。</p>
<p>LTag：  若 LTag=0, lchild域指向左孩子；</p>
<p>​           若 LTag=1, lchild域指向其前驱。</p>
<p>RTag： 若 RTag=0, rchild域指向右孩子；</p>
<p>​           若 RTag=1, rchild域指向其后继。</p>
<p><strong>线索二叉树的遍历</strong></p>
<p><img src="/2021/09/25/Tree3/7.png" alt></p>
</blockquote>
<h2 id="2、中序线索二叉树"><a href="#2、中序线索二叉树" class="headerlink" title="2、中序线索二叉树"></a>2、中序线索二叉树</h2><blockquote>
<p><img src="/2021/09/25/Tree3/4.png" alt></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lChild</span>, *<span class="title">rChild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> lTag, rTag;  <span class="comment">//左右线索标志</span></span><br><span class="line">    <span class="comment">//tag == 0 表示孩子</span></span><br><span class="line">    <span class="comment">//tag == 1 表示线索</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line">ThreadNode  *pre = <span class="literal">nullptr</span>;  <span class="comment">//全局变量pre，指当前访问结点的前驱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBinaryTree</span><span class="params">(ThreadTree &amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *node1 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="keyword">auto</span> *node2 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="keyword">auto</span> *node3 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="keyword">auto</span> *node4 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="keyword">auto</span> *node5 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="keyword">auto</span> *node6 = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    root-&gt;rTag = <span class="number">0</span>;  root-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node1-&gt;rTag = <span class="number">0</span>; node1-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node2-&gt;rTag = <span class="number">0</span>; node2-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node3-&gt;rTag = <span class="number">0</span>; node3-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node4-&gt;rTag = <span class="number">0</span>; node4-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node5-&gt;rTag = <span class="number">0</span>; node5-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    node6-&gt;rTag = <span class="number">0</span>; node6-&gt;lTag = <span class="number">0</span>;</span><br><span class="line">    root-&gt;value = <span class="number">15</span>;</span><br><span class="line">    node1-&gt;value = <span class="number">10</span>;</span><br><span class="line">    node2-&gt;value = <span class="number">23</span>;</span><br><span class="line">    node3-&gt;value = <span class="number">8</span>;</span><br><span class="line">    node4-&gt;value = <span class="number">12</span>;</span><br><span class="line">    node5-&gt;value = <span class="number">21</span>;</span><br><span class="line">    node6-&gt;value = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    root-&gt;lChild = node1;</span><br><span class="line">    root-&gt;rChild = node2;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node1-&gt;lChild = node3;</span><br><span class="line">    node1-&gt;rChild = node4;</span><br><span class="line">    node2-&gt;lChild = node5;</span><br><span class="line">    node2-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node3-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node3-&gt;rChild = node6;</span><br><span class="line">    node4-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node4-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node5-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node5-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node6-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node6-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问根结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lChild == <span class="literal">nullptr</span>) &#123;  <span class="comment">//如果左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lChild = pre; <span class="comment">//左孩子设为前驱结点</span></span><br><span class="line">        p-&gt;lTag = <span class="number">1</span>;  <span class="comment">//左标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) &#123; <span class="comment">//如果右子树为空，建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rChild = p;  <span class="comment">//前驱节点的后继线索</span></span><br><span class="line">        pre-&gt;rTag = <span class="number">1</span>; <span class="comment">//右标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p; <span class="comment">//前驱结点更换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉树，一边遍历一遍线索化； 左根右遍历</span></span><br><span class="line"><span class="comment"> * @param p 根结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123; <span class="comment">//结点为空返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InThread(p-&gt;lChild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">    visit(p); <span class="comment">//根节点线索化</span></span><br><span class="line">    InThread(p-&gt;rChild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序线索化二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreatInThread</span><span class="params">(ThreadTree &amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        InThread(root);  <span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rChild == <span class="literal">nullptr</span>)  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序获得首一个结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstInNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;lTag == <span class="number">0</span>) &#123; <span class="comment">//最左下结点</span></span><br><span class="line">        p = p-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序获得下一个一个结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextInNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rTag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FirstInNode(p-&gt;rChild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//rTag == 1,直接返回后继线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序线索二叉树的遍历</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p = FirstInNode(root); p != <span class="literal">nullptr</span> ; p = NextInNode(p)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadTree root;</span><br><span class="line">    root = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始化创建二叉树"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreateBinaryTree(root);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序遍历线索化"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreatInThread(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序线索化二叉树的中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    InOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">初始化创建二叉树</span><br><span class="line">中序遍历线索化</span><br><span class="line">中序线索化二叉树的中序遍历</span><br><span class="line"><span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">10</span>-&gt;<span class="number">12</span>-&gt;<span class="number">15</span>-&gt;<span class="number">21</span>-&gt;<span class="number">23</span>-&gt;</span><br></pre></td></tr></table></figure>



<h2 id="3、先序线索二叉树"><a href="#3、先序线索二叉树" class="headerlink" title="3、先序线索二叉树"></a>3、先序线索二叉树</h2><blockquote>
<p><strong>思路：</strong> 找后继遍历先序线索二叉树</p>
<ol>
<li><p>若p-&gt;rTag == 1，则next = p-&gt;rChild</p>
</li>
<li><p>若p-&gt;rTag == 0</p>
<p>① 若有左孩子，则先序后继为左孩子</p>
<p>② 若没有左孩子，则先序后继为右孩子</p>
</li>
</ol>
<p><img src="/2021/09/25/Tree3/5.png" alt></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据结构定义看上面中序线索二叉树代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问根结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lChild == <span class="literal">nullptr</span>) &#123;  <span class="comment">//如果左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lChild = pre; <span class="comment">//左孩子设为前驱结点</span></span><br><span class="line">        p-&gt;lTag = <span class="number">1</span>;  <span class="comment">//左标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) &#123; <span class="comment">//如果右子树为空，建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rChild = p;  <span class="comment">//前驱节点的后继线索</span></span><br><span class="line">        pre-&gt;rTag = <span class="number">1</span>; <span class="comment">//右标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p; <span class="comment">//前驱结点更换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历二叉树，一边遍历一遍线索化；根左右遍历</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123; <span class="comment">//结点非空</span></span><br><span class="line">        visit(p); <span class="comment">//根节点线索化</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lTag == <span class="number">0</span>) <span class="comment">//左子树不是前驱线索</span></span><br><span class="line">            PreThread(p-&gt;lChild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rTag == <span class="number">0</span>) <span class="comment">//右子树不是前驱线索</span></span><br><span class="line">            PreThread(p-&gt;rChild); <span class="comment">//先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序线索化二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreatPreThread</span><span class="params">(ThreadTree &amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        PreThread(root);  <span class="comment">//先序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rChild == <span class="literal">nullptr</span>)  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序获得下一个结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextPreNode</span><span class="params">(ThreadNode *p)</span> </span>&#123; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rTag == <span class="number">1</span>) &#123; <span class="comment">//如果rTag == 1,有直接后继，返回直接后继</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//没有</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lTag == <span class="number">0</span>) &#123; <span class="comment">//无左标志线索，有孩子</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;lChild; <span class="comment">//返回左孩子</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//有左标志线索</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;rChild;  <span class="comment">//返回右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序线索二叉树的遍历</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p = root; p != <span class="literal">nullptr</span>; p = NextPreNode(p)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">初始化创建二叉树</span><br><span class="line">先序遍历线索化</span><br><span class="line">先序线索化二叉树的先序遍历</span><br><span class="line"><span class="number">15</span>-&gt;<span class="number">10</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">12</span>-&gt;<span class="number">23</span>-&gt;<span class="number">21</span>-&gt;</span><br></pre></td></tr></table></figure>



<h2 id="4、后序线索二叉树"><a href="#4、后序线索二叉树" class="headerlink" title="4、后序线索二叉树"></a>4、后序线索二叉树</h2><blockquote>
<p><strong>思路：</strong> 找前驱遍历后序线索二叉树</p>
<ol>
<li><p>若p-&gt;rLag == 1，则pre = p-&gt;lChild</p>
</li>
<li><p>若p-&gt;lTag == 0</p>
<p>① 若有右孩子，则后序前驱为右孩子</p>
<p>② 若有左孩子，则后序前驱为左孩子</p>
</li>
</ol>
<p><img src="/2021/09/25/Tree3/6.png" alt></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据结构定义看上面中序线索二叉树代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问根结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lChild == <span class="literal">nullptr</span>) &#123;  <span class="comment">//如果左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lChild = pre; <span class="comment">//左孩子设为前驱结点</span></span><br><span class="line">        p-&gt;lTag = <span class="number">1</span>;  <span class="comment">//左标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rChild == <span class="literal">nullptr</span>) &#123; <span class="comment">//如果右子树为空，建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rChild = p;  <span class="comment">//前驱节点的后继线索</span></span><br><span class="line">        pre-&gt;rTag = <span class="number">1</span>; <span class="comment">//右标志设为1，代表有线索</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p; <span class="comment">//前驱结点更换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树，一边遍历一遍线索化；左右根遍历</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123; <span class="comment">//结点为空返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PostThread(p-&gt;lChild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">    PostThread(p-&gt;rChild); <span class="comment">//后序遍历右子树</span></span><br><span class="line">    visit(p); <span class="comment">//根节点线索化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序线索化二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreatPostThread</span><span class="params">(ThreadTree &amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        PostThread(root);  <span class="comment">//后序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rChild == <span class="literal">nullptr</span>)  <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序获得最后一个结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastPostNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序获得上一个一个结点</span></span><br><span class="line"><span class="comment"> * @param p</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PrePostNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;lTag == <span class="number">1</span>) &#123; <span class="comment">//有直接前驱</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//lTag == 0 无直接前驱</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rChild != <span class="literal">nullptr</span> &amp;&amp; p-&gt;rTag == <span class="number">0</span>) &#123; <span class="comment">//如果右孩子存在，且rTag==0,则右孩子为直接前驱</span></span><br><span class="line">            <span class="keyword">return</span> LastPostNode(p-&gt;rChild);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lChild != <span class="literal">nullptr</span> &amp;&amp; p-&gt;lTag == <span class="number">0</span>) &#123; <span class="comment">//如果左孩子存在，且rTag==0,则左孩子为直接前驱</span></span><br><span class="line">            <span class="keyword">return</span> LastPostNode(p-&gt;lChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序线索二叉树的遍历</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(ThreadNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p = LastPostNode(root); p != <span class="literal">nullptr</span> ; p = PrePostNode(p)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadTree root;</span><br><span class="line">    root = (ThreadNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadNode));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始化创建二叉树"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreateBinaryTree(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"后序遍历线索化"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreatPostThread(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"后序线索化二叉树的先序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    PostOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">初始化创建二叉树</span><br><span class="line">后序遍历线索化</span><br><span class="line">后序线索化二叉树的先序遍历</span><br><span class="line"><span class="number">15</span>-&gt;<span class="number">23</span>-&gt;<span class="number">21</span>-&gt;<span class="number">10</span>-&gt;<span class="number">12</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（六）数组主元素</title>
    <url>/2021/09/24/DSP6/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（六）数组主元素"><a href="#数据结构算法每日一练（六）数组主元素" class="headerlink" title="数据结构算法每日一练（六）数组主元素"></a>数据结构算法每日一练（六）数组主元素</h1><p><strong>难度：</strong> ⭐⭐⭐</p>
<blockquote>
<p><strong>题目：</strong>已知一个整数序列$A = (a_0，a_1……a_{n-1})$,其中 $0≤a_i&lt;n(0≤i&lt;n)$。</p>
<p>若存在$a_{pi}=a_{p2}= ……a_{pm}=x且m&gt;n/2 (0≤p_k&lt;n,1≤k≤m)$,则称x为A的主元素。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>例如A=(0, 5, 5, 3, 5, 7, 5, 5)，则5为主元素；又如A=(0, 5, 5, 3, 5, 1, 5, 7), 则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计</p>
<p>一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1.要求:</p>
<p>（1）给出算法的基本设计思想。</p>
<p>（2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
<p>（3）说明你所设计算法的时间复杂度和空间复杂度。</p>
</blockquote>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><blockquote>
<p>（1）<strong>算法思想：</strong>构建一个大小为n的数组，用于对每个整数的计数，遍历一遍序列然后再遍历1次这个数组找到最大值，然后判断条件是否符合主元素条件。<strong>此解法易思考。</strong></p>
<p>（2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主元素算法</span></span><br><span class="line"><span class="comment"> * @param A 判定数组</span></span><br><span class="line"><span class="comment"> * @param n 数量n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Majority</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[n];</span><br><span class="line">    <span class="keyword">int</span> i, *B;</span><br><span class="line">    B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); <span class="comment">//分配空间</span></span><br><span class="line">    <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n); <span class="comment">//赋初值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        B[ A[i] ]++; <span class="comment">//将A数组对应的值在B数组对应+1；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">//遍历完查最大数量的数值</span></span><br><span class="line">        <span class="keyword">if</span> (B[j] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> &gt; n / <span class="number">2</span>)  <span class="comment">//判断最多数量的数是否满足主元素的条件大于n/2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）时间复杂度为$O(n)$，空间复杂度为$O(n)$;</p>
</blockquote>
<h2 id="解法二（最优解法）"><a href="#解法二（最优解法）" class="headerlink" title="解法二（最优解法）"></a>解法二（最优解法）</h2><blockquote>
<p>（1）<strong>算法思想：</strong>策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确定Num是否是主元素。</p>
<p>算法可分为以下两步:</p>
<p>①选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1； 若遇到的下一个整数仍</p>
<p>等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重</p>
<p>复上述过程，直到扫描完全部数组元素。</p>
<p>②判断c中元素是否是真正的主元素。再次扫描该数组，统计C中元素出现的次数，若大于n/2,则为主元素；否则，序列中不存在主元素。</p>
<p>（2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主元素算法</span></span><br><span class="line"><span class="comment"> * @param A 判定数组</span></span><br><span class="line"><span class="comment"> * @param n 数量n</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Majority1</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , c, count = <span class="number">1</span>;</span><br><span class="line">    c = A[<span class="number">0</span>]; <span class="comment">//设置A[0]为候选主元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == c) &#123; <span class="comment">//如果是候选主元素，则计数加一</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//如果不是候选主元素，计数减一</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//计数为0，更换候选主元素</span></span><br><span class="line">                c = A[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//统计候选主元素的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == c) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; n / <span class="number">2</span>)  <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）时间复杂度为$O(n)$，空间复杂度为$O(1)$</p>
</blockquote>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><blockquote>
<p>（1）<strong>算法思想：</strong>先对整个序列进行排序，然后遍历一遍看哪个元素最多，此算法也易想，相较于上述两种算法效率稍低。</p>
<p>（2）时间复杂度</p>
<p>若使用快速排序或者归并排序时间复杂度为$O(nlog_2n)$，冒泡排序获插入排序等时间复杂度为$O(n^2)$</p>
<p>快速排序空间复杂度为$O(log_2n)$，归并排序空间复杂度为$O(n)$</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（五）顺序表合并</title>
    <url>/2021/09/23/DSP5/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（五）顺序表合并"><a href="#数据结构算法每日一练（五）顺序表合并" class="headerlink" title="数据结构算法每日一练（五）顺序表合并"></a>数据结构算法每日一练（五）顺序表合并</h1><blockquote>
<p><strong>题目：</strong>将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><strong>算法思想：</strong>按顺序不断取下两个顺序表表头的较小结点入新的顺序表，直到一个表为空，将另一个表剩下的部分加到新的顺序表后。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(SqList A, SqList B, SqList &amp;C)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (A.len + B.len &gt; C.MaxSize) &#123; <span class="comment">//若大于顺序表的最大长度，则返回false，空间不够</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">//定义变量</span></span><br><span class="line"> <span class="keyword">while</span> (i &lt; A.len &amp;&amp; j &lt; B.len) &#123; <span class="comment">//循环两个有序表，两两比较，较小的存入结果表</span></span><br><span class="line">     <span class="keyword">if</span> (A.data[i] &lt; B.data[j]) &#123;</span><br><span class="line">         C.data[k++] = A.data[i++];</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">         C.data[k++] = B.data[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; A.len) &#123; <span class="comment">//A还没比较完，将A剩下加入结果表</span></span><br><span class="line">     C.data[k++] = A.data[i++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (j &lt; B.len) &#123; <span class="comment">//B还没比较完，将B剩下加入结果表</span></span><br><span class="line">     C.data[k++] = B.data[j++];</span><br><span class="line"> &#125;</span><br><span class="line"> C.len = k; <span class="comment">//结果表的长度</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（二）二叉树的遍历</title>
    <url>/2021/09/23/Tree2/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（二）二叉树的遍历"><a href="#数据结构-树和二叉树（二）二叉树的遍历" class="headerlink" title="数据结构-树和二叉树（二）二叉树的遍历"></a>数据结构-树和二叉树（二）二叉树的遍历</h1><p><img src="/2021/09/23/Tree2/1.png" alt></p>
<h2 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1 先序遍历"></a>1 先序遍历</h2><blockquote>
<p><strong>DLR—先序遍历，即先根再左再右</strong></p>
<p><strong>先序遍历</strong>（PreOrder）的操作过程如下：</p>
<ol>
<li><p>若二叉树为空，则什么也不做；</p>
</li>
<li><p>若二叉树非空：</p>
<p>①访问根结点；</p>
<p>②先序遍历左子树；</p>
<p>③先序遍历右子树。</p>
</li>
</ol>
</blockquote>
<h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2 中序遍历"></a>2 中序遍历</h2><blockquote>
<p><strong>LDR—中序遍历，即先左再根再右</strong></p>
<p><strong>中序遍历</strong>（InOrder）的操作过程如下：</p>
<ol>
<li><p>若二叉树为空，则什么也不做；</p>
</li>
<li><p>若二叉树非空：</p>
<p>①中序遍历左子树；</p>
<p>②访问根结点；</p>
<p>③中序遍历右子树。</p>
</li>
</ol>
<p>   <img src="/2021/09/23/Tree2/InOrder.gif" alt></p>
</blockquote>
<h2 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3 后序遍历"></a>3 后序遍历</h2><blockquote>
<p><strong>LRD—后序遍历，即先左再右再根</strong></p>
<p><strong>后序遍历</strong>（PostOrder）的操作过程如下：</p>
<ol>
<li><p>若二叉树为空，则什么也不做；</p>
</li>
<li><p>若二叉树非空：</p>
<p>①后序遍历左子树；</p>
<p>②后序遍历右子树；</p>
<p>③访问根结点。  </p>
</li>
</ol>
</blockquote>
<h2 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4 层次遍历"></a>4 层次遍历</h2><blockquote>
<p><strong>算法思想：</strong></p>
<p>①初始化一个辅助队列</p>
<p>②根结点入队</p>
<p>③若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）</p>
<p>④重复③直至队列为空  </p>
</blockquote>
<h2 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5 代码实现"></a>5 代码实现</h2><blockquote>
<p>实现对如图二叉树<strong>创建</strong>和<strong>遍历</strong></p>
<p><img src="/2021/09/23/Tree2/2.png" alt></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lChild</span>, *<span class="title">rChild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateBiTNode</span><span class="params">(BiTree &amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创造新结点</span></span><br><span class="line">    <span class="keyword">auto</span> *node1 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">auto</span> *node2 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">auto</span> *node3 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">auto</span> *node4 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">auto</span> *node5 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">auto</span> *node6 = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="comment">//为结点赋值</span></span><br><span class="line">    root-&gt;value = <span class="number">15</span>;</span><br><span class="line">    node1-&gt;value = <span class="number">10</span>;</span><br><span class="line">    node2-&gt;value = <span class="number">23</span>;</span><br><span class="line">    node3-&gt;value = <span class="number">8</span>;</span><br><span class="line">    node4-&gt;value = <span class="number">12</span>;</span><br><span class="line">    node5-&gt;value = <span class="number">21</span>;</span><br><span class="line">    node6-&gt;value = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//分层赋子节点</span></span><br><span class="line">    root-&gt;lChild = node1;</span><br><span class="line">    root-&gt;rChild = node2;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node1-&gt;lChild = node3;</span><br><span class="line">    node1-&gt;rChild = node4;</span><br><span class="line">    node2-&gt;lChild = node5;</span><br><span class="line">    node2-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node3-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node3-&gt;rChild = node6;</span><br><span class="line">    node4-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node4-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node5-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node5-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    node6-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">    node6-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历--先根再左再右</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    PreOrderTraversal(root-&gt;lChild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">    PreOrderTraversal(root-&gt;rChild); <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历--先左再根再右</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrderTraversal(root-&gt;lChild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">    InOrderTraversal(root-&gt;rChild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历--先左再右再根</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PostOrderTraversal(root-&gt;lChild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">    PostOrderTraversal(root-&gt;rChild); <span class="comment">//h序遍历右子树</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; root-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BiTNode *&gt; tree; <span class="comment">//声明队列</span></span><br><span class="line">    tree.push(root); <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!tree.empty()) &#123; <span class="comment">//当队列不为空</span></span><br><span class="line">        BiTNode *p = tree.front();  <span class="comment">//队头结点出队</span></span><br><span class="line">        tree.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="string">"-&gt;"</span>;  <span class="comment">//打印队头结点数据</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lChild != <span class="literal">nullptr</span>) &#123; <span class="comment">//左子树不为空，左子树根节点入队</span></span><br><span class="line">            tree.push(p-&gt;lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rChild != <span class="literal">nullptr</span>) &#123; <span class="comment">//左子树不为空，左子树根节点入队</span></span><br><span class="line">            tree.push(p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree root;</span><br><span class="line">    root = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"初始化创建二叉树"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreateBiTNode(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序遍历二叉树--先左再根再右"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    PreOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"中序遍历二叉树--先左再根再右"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    InOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"后序遍历二叉树--先左再右再根"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    PostOrderTraversal(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"层次遍历二叉树--按层次遍历"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    LevelOrderTraversal(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">初始化创建二叉树</span><br><span class="line">先序遍历二叉树--先左再根再右</span><br><span class="line"><span class="number">15</span>-&gt;<span class="number">10</span>-&gt;<span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">12</span>-&gt;<span class="number">23</span>-&gt;<span class="number">21</span>-&gt;</span><br><span class="line">中序遍历二叉树--先左再根再右</span><br><span class="line"><span class="number">8</span>-&gt;<span class="number">9</span>-&gt;<span class="number">10</span>-&gt;<span class="number">12</span>-&gt;<span class="number">15</span>-&gt;<span class="number">21</span>-&gt;<span class="number">23</span>-&gt;</span><br><span class="line">后序遍历二叉树--先左再右再根</span><br><span class="line"><span class="number">9</span>-&gt;<span class="number">8</span>-&gt;<span class="number">12</span>-&gt;<span class="number">10</span>-&gt;<span class="number">21</span>-&gt;<span class="number">23</span>-&gt;<span class="number">15</span>-&gt;</span><br><span class="line">层次遍历二叉树--按层次遍历</span><br><span class="line"><span class="number">15</span>-&gt;<span class="number">10</span>-&gt;<span class="number">23</span>-&gt;<span class="number">8</span>-&gt;<span class="number">12</span>-&gt;<span class="number">21</span>-&gt;<span class="number">9</span>-&gt;</span><br><span class="line"><span class="built_in">Process</span> finished with <span class="built_in">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="6-由遍历序列构造二叉树"><a href="#6-由遍历序列构造二叉树" class="headerlink" title="6 由遍历序列构造二叉树"></a>6 由遍历序列构造二叉树</h2><p><img src="/2021/09/23/Tree2/3.png" alt></p>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（四）数组逆置</title>
    <url>/2021/09/22/DSP4/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（四）数组逆置"><a href="#数据结构算法每日一练（四）数组逆置" class="headerlink" title="数据结构算法每日一练（四）数组逆置"></a>数据结构算法每日一练（四）数组逆置</h1><blockquote>
<p><strong>题目1：</strong> 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>算法思想：扫描顺序表L的前半部分元素，对于元素L.data[i]  (0 ≤ i &lt; L.length / 2)，将其与下半部分的对应元素L.data[L.length - i - 1]进行交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        swap(L.data[i], L.data[L.length - i - <span class="number">1</span>]); <span class="comment">//交换数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>题目2：</strong> 已知在一维数组A[m + n]中依次存放两个线性表$(a_1, a_2, a_3,…,a_m)$和$(b_1, b_2, b_3,…,b_n)$。试编写一个函数，将数组中两个顺序表的位置互换，即将$(b_1, b_2, b_3,…,b_n)$放在$(a_1, a_2, a_3,…,a_m)$的前面。</p>
</blockquote>
<blockquote>
<p>算法思想：先总表逆置，然后再对前n个元素和后m个元素分别逆置。或者先对前n个元素和后m个元素分别逆置，再总表逆置。</p>
<p>例 [(1,2,3)(4,5,6,7)] -&gt; [(7,6,5,4)(3,2,1)] -&gt; [4,5,6,7,1,2,3]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right || right &gt;= len) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; mid; i++) &#123;</span><br><span class="line">        swap(arr[i], arr[right - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    Reverse(A, <span class="number">0</span>, m + n - <span class="number">1</span>, length);  <span class="comment">//总表逆置</span></span><br><span class="line">    Reverse(A, <span class="number">0</span>, n - <span class="number">1</span>, length);  <span class="comment">//前n个元素逆置</span></span><br><span class="line">    Reverse(A, n, m + n - <span class="number">1</span>, length);  <span class="comment">//后m个元素逆置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树和二叉树（一）基本概念</title>
    <url>/2021/09/22/Tree1/</url>
    <content><![CDATA[<h1 id="数据结构-树和二叉树（一）基本概念"><a href="#数据结构-树和二叉树（一）基本概念" class="headerlink" title="数据结构-树和二叉树（一）基本概念"></a>数据结构-树和二叉树（一）基本概念</h1><h2 id="1-树的基本概念"><a href="#1-树的基本概念" class="headerlink" title="1 树的基本概念"></a>1 树的基本概念</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h3><p><img src="/2021/09/22/Tree1/1.png" alt></p>
<p><img src="/2021/09/22/Tree1/2.png" alt></p>
<h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote>
<p>树是n（n≥0）个结点的有限集合， n = 0时，称为<strong>空树</strong>，这是一种特殊情况。</p>
<p>在任意一棵<strong>非空树</strong>中应满足：</p>
<p>1、有且仅有一个特定的称为根的结点。</p>
<p>2、当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。  </p>
<p>树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。</p>
<p>树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p>
<ol>
<li>🌲除了根节点外，任何一个结点都有且仅有一个前驱  </li>
<li>🌳中所有结点可以有零个或多个后继</li>
</ol>
<p>非空树的<strong>特性</strong>：<br>🌲有且仅有一个根节点<br>🌳没有后继的结点称为“叶子结点”（或终端结点）<br>🌴有后继的结点称为“分支结点”（或非终端结点）<br>🌱除了根节点外，任何一个结点都有且仅有一个前驱<br>🌵每个结点可以有0个或多个后继。  </p>
</blockquote>
<h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><blockquote>
<p><strong>属性</strong></p>
<ul>
<li><strong>结点的度</strong>（Degree）：结点的子树个数；</li>
<li><strong>树的度</strong>：树的所有结点中最大的度数；</li>
<li><strong>叶子结点</strong>（Leaf）：度为0的结点；也叫<strong>终端结点</strong>。</li>
<li><strong>父结点</strong>（Parent）：有子树的结点是其子树的根节点的父结点；</li>
<li><strong>子结点/孩子结点</strong>（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；</li>
<li><strong>兄弟结点</strong>（Sibling）：具有同一个父结点的各结点彼此是兄弟结点；</li>
<li><strong>路径和路径长度</strong>：从结点$n_1$到$n_k$的路径为一个结点序列$n_1，n_2，…，n_k$。$n_i$是$n_i+1$的父结点。路径所包含边的个数为路径的长度；</li>
<li><strong>祖先结点</strong>（Ancestor）：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；</li>
<li><strong>子孙结点</strong>（Descendant）：某一结点的子树中的所有结点是这个结点的子孙；</li>
<li><strong>结点的层次</strong>（Level）：规定根结点在1层，其他任一结点的层数是其父结点的层数加1；</li>
<li><strong>树的深度</strong>（Depth）：树中所有结点中的最大层次是这棵树的深度；</li>
<li><strong>有序树</strong>——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</li>
<li><strong>无序树</strong>——逻辑上看，树中结点的各子树从左至右是无次序的，可以互换  </li>
<li><strong>森林</strong>： 森林是m（m≥0）棵互不相交的树的集合  </li>
</ul>
</blockquote>
<h3 id="1-3-树的性质"><a href="#1-3-树的性质" class="headerlink" title="1.3 树的性质"></a>1.3 树的性质</h3><blockquote>
<ol>
<li>树中的<strong>结点数</strong> = <strong>总度数</strong> + <strong>1</strong>      </li>
<li>度为 m 的树第 i 层<strong>至多</strong>有$m^{i-1}$ 个结点（i ≥ 1）  </li>
<li>高度为 h 的 m 叉树<strong>至多</strong>有 <strong>$(m^{h- 1}) / (m - 1)$</strong>个结点。 </li>
<li>高度为 h 的 m 叉树<strong>至少</strong>有 <strong>h</strong> 个结点；高度为h、度为m的树<strong>至少</strong>有 <strong>h + m - 1</strong> 个结点。  </li>
<li>具有 n 个结点的 m 叉树的<strong>最小高度</strong>为 <strong>$[log_m(n (m - 1) + 1)]$</strong>    </li>
</ol>
</blockquote>
<p><strong>度为m的树、m叉树的区别</strong></p>
<blockquote>
<p><img src="/2021/09/22/Tree1/3.png" alt></p>
</blockquote>
<h2 id="2-二叉树🌱的基本概念"><a href="#2-二叉树🌱的基本概念" class="headerlink" title="2 二叉树🌱的基本概念"></a>2 二叉树🌱的基本概念</h2><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h3><p><img src="/2021/09/22/Tree1/4.png" alt></p>
<p><img src="/2021/09/22/Tree1/13.png" alt></p>
<h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><blockquote>
<p>二叉树是n（n≥0）个结点的有限集合：</p>
<p>① 或者为空二叉树，即n = 0。</p>
<p>② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</p>
<p><strong>特点：</strong></p>
<p>① 每个结点<strong>至多</strong>只有两棵子树 </p>
<p>② 左右子树不能颠倒（<strong>二叉树是有序树</strong>）  </p>
<p><strong>二叉树的五种形态</strong></p>
<p><img src="/2021/09/22/Tree1/5.png" alt></p>
<p><strong>特殊的二叉树</strong></p>
<p><strong>1、满二叉树。</strong> 一棵高度为h，且含有$2^h - 1$个结点的二叉树  </p>
<p><strong>特点：</strong><br>① 只有最后一层有叶子结点</p>
<p>② 不存在度为 1 的结点</p>
<p>③ 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i + 1；结点 i 的父节点为 i / 2 （如果有的话）</p>
<p><img src="/2021/09/22/Tree1/6.png" alt></p>
<p><strong>2、完全二叉树</strong>。 当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树。</p>
<p><strong>特点：</strong><br>① 只有最后两层可能有叶子结点</p>
<p>② 最多只有一个度为1的结点</p>
<p>③ 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i + 1；结点 i 的父节点为 i / 2 （如果有的话）</p>
<p>④  i≤ 𝑛/2 为分支结点， i&gt; 𝑛/2 为叶子结点  </p>
<p><strong>注：如果某结点只有一个孩子，那么一定是左孩子</strong>  </p>
<p><img src="/2021/09/22/Tree1/7.png" alt></p>
<p><strong>3、二叉排序树</strong>。 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p>
<p>① 左子树上所有结点的关键字均小于根结点的关键字；</p>
<p>② 右子树上所有结点的关键字均大于根结点的关键字。</p>
<p>③ 左子树和右子树又各是一棵二叉排序树。  </p>
<p><strong>二叉排序树可用于元素的排序、搜索</strong>  </p>
<p><img src="/2021/09/22/Tree1/8.png" alt></p>
<p><strong>4、平衡二叉树</strong>。 树上任一结点的左子树和右子树的深度之差不超过1。<strong>平衡二叉树能有更高的搜索效率</strong>。   </p>
<p><img src="/2021/09/22/Tree1/9.png" alt></p>
</blockquote>
<h3 id="2-2-性质"><a href="#2-2-性质" class="headerlink" title="2.2 性质"></a>2.2 性质</h3><blockquote>
<p>1、设非空二叉树中度为<code>0</code>、 <code>1</code>和<code>2</code>的结点个数分别为$n_0$、 $n_1$和 $n_2$， 则 <strong>$n_0$ = $n_2$ + 1</strong>（叶子结点比二分支结点多一个）</p>
<p>2、<strong>二叉树</strong>第 <strong>i</strong> 层至多有<strong>$2^i - 1$</strong> 个结点（i≥1）；</p>
<p>​     <strong>m叉树</strong>第 <strong>i</strong> 层至多有$m^i - 1$ 个结点（i≥1）  </p>
<p>3、高度为 h 的二叉树<strong>至多</strong>有 <strong>$2^ℎ - 1$</strong>个结点（满二叉树） ；高度为h的m叉树<strong>至多</strong>有<strong>($m^{h - 1}$) / (m - 1)</strong>个结点。 </p>
<p>4、具有 n 个（n &gt; 0）结点的<strong>完全二叉树</strong>的高度 h 为$[log_2(n + 1)]$ 或 $[log_2n]+1  $</p>
<p>高为 h - 1 的<strong>满二叉树</strong>共有 $2^ℎ - 1$个结点  </p>
<p>高为 h 的<strong>完全二叉树</strong>至少$2^{h - 1}$个结点，至多 $2^ℎ - 1$ 个结点  </p>
<p>5、对于<strong>完全二叉树</strong>，可以由的结点数 n 推出度为0、 1 和 2 的结点个数为$n_0$、 $n_1$和$n_2$</p>
<p>完全二叉树最多只有一个度为 1 的结点，即 $n_1$ = 0 或 1  </p>
<p>$n_0$ = $n_2$+ 1 —–&gt; <strong>n0 + n2 一定是奇数</strong>  </p>
<p>若完全二叉树有 <strong>2k 个（偶数）</strong>个结点，则必有 $n_1$ = 1， $n_0$ = k， $n_2$ = k - 1</p>
<p>若完全二叉树有 <strong>2k - 1 个（奇数）</strong>个结点，则必有 $n_1$=0， $n_0$ = k， $n_2$ = k - 1  </p>
</blockquote>
<h3 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h3><h4 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h4><blockquote>
<p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<p><strong>特点：</strong></p>
<p>结点间关系蕴含在其存储位置中，浪费空间，适于存<strong>满二叉树</strong>和<strong>完全二叉树</strong></p>
<p><img src="/2021/09/22/Tree1/10.png" alt></p>
<p><img src="/2021/09/22/Tree1/11.png" alt></p>
</blockquote>
<h4 id="2、链式存储结构"><a href="#2、链式存储结构" class="headerlink" title="2、链式存储结构"></a>2、链式存储结构</h4><blockquote>
<p><strong>n</strong>个结点的二叉链表共有 <strong>n+1</strong> 个空链域</p>
<p><img src="/2021/09/22/Tree1/12.png" alt></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lChild</span>, *<span class="title">rChild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建二叉树</span></span><br><span class="line"><span class="comment"> * @param root</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateBiTNode</span><span class="params">(BiTree &amp;root)</span> </span>&#123;</span><br><span class="line">    root = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">-1</span>) &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;value = e;</span><br><span class="line">        root-&gt;lChild = <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;rChild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; e &lt;&lt; <span class="string">"左结点值（-1代表无子结点）："</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">        CreateBiTNode(root-&gt;lChild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; e &lt;&lt; <span class="string">"右结点值（-1代表无子结点）："</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">        CreateBiTNode(root-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseBiTree</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T-&gt;value &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    TraverseBiTree(T-&gt;lChild);</span><br><span class="line">    TraverseBiTree(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree root;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入结点值（-1代表无子结点）："</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    CreateBiTNode(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序遍历二叉树"</span> &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    TraverseBiTree(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请输入结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">请输入<span class="number">1</span>左结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">2</span></span><br><span class="line">请输入<span class="number">2</span>左结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">请输入<span class="number">2</span>右结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">请输入<span class="number">1</span>右结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">3</span></span><br><span class="line">请输入<span class="number">3</span>左结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">请输入<span class="number">4</span>左结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">请输入<span class="number">4</span>右结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">请输入<span class="number">3</span>右结点值（<span class="number">-1</span>代表无子结点）：</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">先序遍历二叉树</span><br><span class="line"><span class="number">1</span>-&gt;</span><br><span class="line"><span class="number">2</span>-&gt;</span><br><span class="line"><span class="number">3</span>-&gt;</span><br><span class="line"><span class="number">4</span>-&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Process</span> finished with <span class="built_in">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（三）青蛙跳台阶</title>
    <url>/2021/09/21/DSP3/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（三）青蛙跳台阶"><a href="#数据结构算法每日一练（三）青蛙跳台阶" class="headerlink" title="数据结构算法每日一练（三）青蛙跳台阶"></a>数据结构算法每日一练（三）青蛙跳台阶</h1><blockquote>
<p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果)。</p>
<p>（1）请用递归的方式求 n 级的台阶总共有多少种跳法: int jumpFloor(int n);</p>
<p>（2）给出此递归函数的时间复杂度。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>解析：</p>
<p>当n = 0, jumpFloor(0) = 0;</p>
<p>当n = 1, jumpFloor(1) = 1;</p>
<p>当n = 2, jumpFloor(2) = 2;</p>
<p>当n &gt; 3, jumpFloor(n) = jumpFloor(n - 1) + jumpFloor(n - 2);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> jumpFloor(n - <span class="number">1</span>) + jumpFloor(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = jumpFloor(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>为递归调用 $O(2^n)$</p>
<p>该题为斐波那契数列，分析方法与其一致。</p>
<p>斐波那契数列递推公式 <strong>$a_n=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n]$</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-串和数组（三）KMP算法</title>
    <url>/2021/09/21/String3/</url>
    <content><![CDATA[<h1 id="数据结构-串和数组（三）KMP算法"><a href="#数据结构-串和数组（三）KMP算法" class="headerlink" title="数据结构-串和数组（三）KMP算法"></a>数据结构-串和数组（三）KMP算法</h1><h2 id="1、算法思想"><a href="#1、算法思想" class="headerlink" title="1、算法思想"></a>1、算法思想</h2><blockquote>
<p>由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法；</p>
<p>根据模式串T，求出 next 数组。利用next数组进行匹配（主串指针不回溯）next数组只和短短的模式串有关，和长长的主串无关      </p>
</blockquote>
<h2 id="2、复杂度分析"><a href="#2、复杂度分析" class="headerlink" title="2、复杂度分析"></a>2、复杂度分析</h2><blockquote>
<p><strong>时间复杂度：</strong></p>
<p>KMP算法， 最坏时间复杂度 <strong>O(m+n)</strong><br>其中，求 next 数组时间复杂度 O(m)<br>模式匹配过程最坏时间复杂度 O(n)  </p>
</blockquote>
<h2 id="3、-next数组求解"><a href="#3、-next数组求解" class="headerlink" title="3、 next数组求解"></a>3、 next数组求解</h2><blockquote>
<p><strong>next数组的作用：</strong>当模式串的第 j 个字符失配时，从模式串的第 next[j] 的继续往后匹配  </p>
</blockquote>
<h3 id="1、手动移位模拟法"><a href="#1、手动移位模拟法" class="headerlink" title="1、手动移位模拟法"></a><strong>1、手动移位模拟法</strong></h3><blockquote>
<p><strong>next[1]</strong> 都⽆脑写 0</p>
<p><strong>next[2]</strong> 都⽆脑写 1</p>
<p><strong>其他 next：</strong> 在不匹配的位置前，划⼀根美丽的分界线；模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。</p>
<p>此时 j 指向哪⼉， next数组值就是多少；  </p>
<p><img src="/2021/09/21/String3/1.png" alt></p>
<p><img src="/2021/09/21/String3/2.png" alt></p>
</blockquote>
<h3 id="2、前后缀计算法"><a href="#2、前后缀计算法" class="headerlink" title="2、前后缀计算法"></a><strong>2、前后缀计算法</strong></h3><blockquote>
<p><strong>next[j]</strong> = 字符串的前缀和后缀的<strong>最长相等前后缀长度</strong> + <strong>1</strong></p>
<p><img src="/2021/09/21/String3/3.png" alt></p>
<p><img src="/2021/09/21/String3/4.png" alt></p>
</blockquote>
<h2 id="4、-KMP算法优化"><a href="#4、-KMP算法优化" class="headerlink" title="4、 KMP算法优化"></a>4、 KMP算法优化</h2><blockquote>
<p><strong>先得出next数组，然后从头开始遍历</strong></p>
<p>1、先找对应的next[next[j]]</p>
<p>2、判断该字符是否相等</p>
<p>3、相等，则nextval[j] = next[next[j]]，即等于找到的next数组值</p>
<p>4、不相等，则nextval[j] = next[j]，即等于自身next数组值</p>
<p><img src="/2021/09/21/String3/5.png" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（二）Lagureer多项式</title>
    <url>/2021/09/20/DSP2/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（二）Lagureer多项式"><a href="#数据结构算法每日一练（二）Lagureer多项式" class="headerlink" title="数据结构算法每日一练（二）Lagureer多项式"></a>数据结构算法每日一练（二）Lagureer多项式</h1><blockquote>
<p>1、N次Laguerre多项式$P_n(x)$的递归定义是：<br>$P_0(x)=1$<br>$P_1(x)=1-x$<br>$P_n(x) = (2n-1-x) P_{n-1}(x) - (n-1)^2 P_{n-2}(x) (n&gt;1)$</p>
<p>(1)请按照上面的定义用递归的方式求n次Lagureer 多项式在x处的值: double laguerre (double x，int n);</p>
<p>(2)给出此递归函数的时间复杂度。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>（1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">laguerre</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> - x;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">2</span>*n - <span class="number">1</span> - x) * laguerre(x, n - <span class="number">1</span>) - (n - <span class="number">1</span>) * (n - <span class="number">1</span>) * laguerre(x, n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; n;</span><br><span class="line"><span class="keyword">double</span> res = laguerre(x, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）时间复杂度为递归调用$O(2^n)$</p>
<p>详细分析请参照上篇-斐波那契数列</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-串和数组（二）BF算法</title>
    <url>/2021/09/20/String2/</url>
    <content><![CDATA[<h1 id="数据结构-串和数组（二）BF算法"><a href="#数据结构-串和数组（二）BF算法" class="headerlink" title="数据结构-串和数组（二）BF算法"></a>数据结构-串和数组（二）BF算法</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/20/String2/1.png" alt></p>
<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><blockquote>
<p>主串长度为n，模式串长度为 m  </p>
<p><strong>朴素模式匹配算法：</strong>将主串中所有长度为m的子串依次与模式串对⽐，直到找到⼀个完全匹配的子串，或所有的子串都不匹配为止  （最多对比 n-m+1 个子串  ）</p>
<p>若当前子串匹配失败，则主串指针 i 指向下⼀个子串的第⼀个位置， 模式串指针 j 回到模式串的第⼀个位置  </p>
</blockquote>
<h2 id="2、复杂度分析"><a href="#2、复杂度分析" class="headerlink" title="2、复杂度分析"></a>2、复杂度分析</h2><blockquote>
<p><strong>时间复杂度：</strong></p>
<p><strong>最坏时间复杂度：</strong>  O(nm)</p>
<p><strong>最好时间复杂度：</strong>  O(n)  </p>
<p>最坏的情况，每个子串都要对比 m 个字符，共 n-m+1 个⼦串，复杂度 = O((n-m+1)m) = O(nm)</p>
<p><strong>注：</strong>很多时候，n &gt;&gt; m  </p>
</blockquote>
<h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Wang on 2021/8/16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == t.length())</span><br><span class="line">        <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Index(s, t) &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ababcabcacbab</span><br><span class="line">abc</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-串和数组（一）串基本概念</title>
    <url>/2021/09/19/String1/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="数据结构-串和数组（一）串基本概念"><a href="#数据结构-串和数组（一）串基本概念" class="headerlink" title="数据结构-串和数组（一）串基本概念"></a>数据结构-串和数组（一）串基本概念</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/19/String1/1.png" alt></p>
<p><img src="/2021/09/19/String1/2.png" alt></p>
<h2 id="1-串的定义和实现"><a href="#1-串的定义和实现" class="headerlink" title="1 串的定义和实现"></a>1 串的定义和实现</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><blockquote>
<p><strong>串</strong>，即<strong>字符串</strong>（String）是由零个或多个字符组成的有限序列。一般记为</p>
<p>$S = ‘ a_1a_2······a_n ‘ (n≥0)$</p>
<p>其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其他字符；串中字符的个数n称为串的长度。n = 0时的串称为空串（用∅表示）。</p>
<p><strong>例：</strong> </p>
<p>S=”HelloWorld!”</p>
<p>T=‘iPhone 11 Pro Max?’   </p>
<p><strong>子串：</strong>串中任意个连续的字符组成的子序列。 Eg：’iPhone’，’Pro M’ 是串T 的子串</p>
<p><strong>主串：</strong>包含子串的串。 Eg：T 是子串’iPhone’的主串</p>
<p><strong>字符在主串中的位置：</strong>字符在串中的序号。 Eg：’1’在T中的位置是8(第一次出现)</p>
<p><strong>子串在主串中的位置：</strong>子串的第一个字符在主串中的位置 。 Eg：’11 Pro’在 T 中的位置为8</p>
</blockquote>
<h3 id="1-2-存储结构"><a href="#1-2-存储结构" class="headerlink" title="1.2 存储结构"></a>1.2 存储结构</h3><blockquote>
<p>串是一种特殊的线性表，数据元素之间呈线性关系  </p>
</blockquote>
<h3 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h3><blockquote>
<p><strong>StrAssign(&amp;T,chars)：</strong>赋值操作。把串T赋值为chars。</p>
<p><strong>StrCopy(&amp;T,S)：</strong>复制操作。由串S复制得到串T。</p>
<p><strong>StrEmpty(S)：</strong>判空操作。若S为空串，则返回TRUE，否则返回FALSE。</p>
<p><strong>StrLength(S)：</strong>求串长。返回串S的元素个数。</p>
<p><strong>ClearString(&amp;S)：</strong>清空操作。将S清为空串。</p>
<p><strong>DestroyString(&amp;S)：</strong>销毁串。将串S销毁（回收存储空间）。</p>
<p><strong>Concat(&amp;T,S1,S2)：</strong>串联接。用T返回由S1和S2联接而成的新串</p>
<p><strong>SubString(&amp;Sub,S,pos,len)：</strong>求子串。用Sub返回串S的第pos个字符起长度为len的子串。</p>
<p><strong>Index(S,T)：</strong>定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0。</p>
<p><strong>StrCompare(S,T)：</strong>比较操作。若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0。  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构算法每日一练（一）斐波那契数列</title>
    <url>/2021/09/18/DSP1/</url>
    <content><![CDATA[<h1 id="数据结构算法每日一练（一）斐波那契数列"><a href="#数据结构算法每日一练（一）斐波那契数列" class="headerlink" title="数据结构算法每日一练（一）斐波那契数列"></a>数据结构算法每日一练（一）斐波那契数列</h1><blockquote>
<p>题目：写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>F(0) = 0,</p>
<p>F(1) = 1</p>
<p>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>
<p>（1）请按照上面的定义用递归的方式求第n向Fibonacci数列的值: int fibonacci(int n);</p>
<p>（2）给出此递归函数的时间复杂度。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>（1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span> <span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = fibonacci (n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）</p>
<p>递归结构图如下：</p>
<p><img src="/2021/09/18/DSP1/D:%5CBlog%5CMrWang%5Csource_posts%5CDSP1%5C%E4%B8%80.png" alt></p>
<p><strong>1、时间复杂度为(二叉树的节点个数）：</strong></p>
<p>因为递归后不属于完全二叉树，因此结点小于$(2^h)-1$，近似归为$(2^h)$</p>
<p><strong>时间复杂度近似为</strong> $(2^h)-1= O(2^n)$</p>
<p>更精确一些时间复杂度为$O(F(n))$</p>
<p>$F(n)=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n - (\frac{1-\sqrt{5}}{2})^n]$</p>
<p>$O(F(n)) = O((\frac{1+\sqrt{5}}{2})^n)$</p>
<p><strong>2、空间复杂度为(树的高度)：</strong>h = $O(n)$.</p>
<p>二叉树的高度h根据具体数据推算为 n - 1</p>
</blockquote>
<blockquote>
<p>递归算法时间复杂度过大，优化算法，采取递推算法即动态规划</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  fib[<span class="number">101</span>];			<span class="comment">//采用数组保存中间结果</span></span><br><span class="line">    fib[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = fibonacci (n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度为：</strong>$O(n)$</p>
<p><strong>空间复杂度为：</strong> $O(1)$.</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构算法每日一练</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列（三）栈和队列的应用</title>
    <url>/2021/09/18/Stack2/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="栈和队列（三）栈和队列的应用"><a href="#栈和队列（三）栈和队列的应用" class="headerlink" title="栈和队列（三）栈和队列的应用"></a>栈和队列（三）栈和队列的应用</h1><h2 id="1-栈在括号匹配应用"><a href="#1-栈在括号匹配应用" class="headerlink" title="1 栈在括号匹配应用"></a>1 栈在括号匹配应用</h2><h3 id="1-1-算法流程图"><a href="#1-1-算法流程图" class="headerlink" title="1.1 算法流程图"></a>1.1 算法流程图</h3><p><img src="/2021/09/18/Stack2/1.png" alt></p>
<h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><blockquote>
<p>（1）判断括号是否匹配</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span> || str[i] == <span class="string">'['</span> || str[i] == <span class="string">'&#123;'</span>)&#123;  <span class="comment">//左括号入栈</span></span><br><span class="line">            s.push(str[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.empty()) &#123; <span class="comment">//栈空失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> t;</span><br><span class="line">            t = s.top(); <span class="comment">//匹配右括号</span></span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">')'</span> &amp;&amp; t == <span class="string">'('</span>) &#123;</span><br><span class="line">                s.pop();    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">']'</span> &amp;&amp; t == <span class="string">'['</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'&#125;'</span> &amp;&amp; t == <span class="string">'&#123;'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.empty(); <span class="comment">//匹配结束，栈空匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bracketCheck(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">([]&#123;&#125;(()))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>（2）n对括号可以有多少种匹配排列方式</p>
<p>算法链接 <a href="https://blog.csdn.net/u014529413/article/details/39119273" target="_blank" rel="noopener">https://blog.csdn.net/u014529413/article/details/39119273</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> n, <span class="built_in">string</span> s, <span class="keyword">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == l)</span><br><span class="line">    &#123;</span><br><span class="line">        s.append(<span class="string">"("</span>);</span><br><span class="line">        l++;</span><br><span class="line">        dfs(l, r, n, s, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//r&lt;l</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == n)</span><br><span class="line">        &#123;</span><br><span class="line">            s.append(<span class="string">")"</span>);</span><br><span class="line">            r++;</span><br><span class="line">            dfs(l, r, n, s, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.append(<span class="string">"("</span>);</span><br><span class="line">            l++;</span><br><span class="line">            dfs(l, r, n, s, num);</span><br><span class="line">            s = s.substr(<span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            l--;</span><br><span class="line">            s.append(<span class="string">")"</span>);</span><br><span class="line">            r++;</span><br><span class="line">            dfs(l, r, n, s, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, n, s, num);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">((()))</span><br><span class="line">(()())</span><br><span class="line">(())()</span><br><span class="line">()(())</span><br><span class="line">()()()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-栈在表达式求值应用"><a href="#2-栈在表达式求值应用" class="headerlink" title="2 栈在表达式求值应用"></a>2 栈在表达式求值应用</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h3><p><img src="/2021/09/18/Stack2/2.png" alt></p>
<h3 id="2-1-中缀表达式"><a href="#2-1-中缀表达式" class="headerlink" title="2.1 中缀表达式"></a>2.1 中缀表达式</h3><blockquote>
<p><strong>中缀表达式</strong>是一个通用的算术或逻辑公式表示方法， <strong>操作符是以中缀形式处于操作数的中间</strong>，中缀表达式是人们常用的算术表示方法，</p>
<p>比如（499 + 1）* 2 + 314</p>
</blockquote>
<h3 id="2-2-前缀表达式"><a href="#2-2-前缀表达式" class="headerlink" title="2.2 前缀表达式"></a>2.2 前缀表达式</h3><blockquote>
<p><strong>前缀表达式</strong>是一种没有括号的算术表达式，与中缀表达式不同的是，<strong>其将运算符写在前面，操作数写在后面</strong>。也被叫做<strong>波兰表达式</strong>,</p>
<p>比如<strong>（499 + 1）* 2 + 314</strong> 的前缀表达式为 <strong>+ * + 499 1 2 314</strong></p>
</blockquote>
<p><strong>求值方法：</strong></p>
<blockquote>
<p>（1）从右至左扫描表达式，遇到数字时，将数字压入栈；</p>
<p>（2）遇到运算符时，弹出栈顶的两个数；</p>
<p>（3）用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；</p>
<p>（4）重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果；</p>
</blockquote>
<blockquote>
<p>举栗子🌰🌰（499 + 1）* 2 + 314 对应的前缀表达式就是 + * + 499 1 2 314, 针对前缀表达式求值步骤如下:</p>
<ol>
<li>从右至左扫描，将314、2、1、499压入堆栈</li>
<li>遇到+运算符，因此弹出499和1（499为栈顶元素，1为次顶元素），计算499 + 1的值，得500，再将500入栈</li>
<li>接下来是 * 运算符，因此弹出500和2（500为栈顶元素，2为次顶元素），计算500 * 2的值，得1000，再将1000入栈</li>
<li>最后是+运算符，计算出1000 + 314的值，即1314💝💝，由此得出最终结果</li>
</ol>
</blockquote>
<h3 id="2-3-后缀表达式"><a href="#2-3-后缀表达式" class="headerlink" title="2.3 后缀表达式"></a>2.3 后缀表达式</h3><blockquote>
<p><strong>逆波兰式</strong>（或逆波兰记法），也叫<strong>后缀表达式</strong>，<strong>其将运算符写在操作数之后</strong>，后缀表达式源自于前缀表达式，为了区分前缀和后缀表示，通常将后缀表示称为逆波兰表示。</p>
<p>比如：（499 + 1）x 2 + 314 的后缀表达试为 499 1 + 2 x 314 +</p>
</blockquote>
<p><strong>求值方法：</strong></p>
<blockquote>
<p>（1）从左至右扫描表达式，遇到数字时，将数字压入堆栈；</p>
<p>（2）遇到运算符时，弹出栈顶的两个数；</p>
<p>（3）用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；</p>
<p>（4）重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。</p>
</blockquote>
<blockquote>
<p>举栗子🌰🌰（499 + 1）* 2 + 314 对应的后缀表达式就是 499 1 + 2 * 314 +, 针对前缀表达式求值步骤如下:</p>
<ol>
<li>从左至右扫描，将499和1压入堆栈；</li>
<li>遇到+运算符，因此弹出499和1（1为栈顶元素，499为次顶元素），计算出499+1的值，得500，再将500入栈；</li>
<li>将2入栈；</li>
<li>接下来是 * 运算符，因此弹出500和2，计算出500 * 2，得1000，再将1000入栈；</li>
<li>将314入栈；</li>
<li>最后是+运算符，计算出1000+314的值，即1314💗💗，由此得出最终结果</li>
</ol>
</blockquote>
<h3 id="2-4-中缀转后缀表达式"><a href="#2-4-中缀转后缀表达式" class="headerlink" title="2.4 中缀转后缀表达式"></a>2.4 中缀转后缀表达式</h3><blockquote>
<p><strong>转换算法步骤</strong>📋👇</p>
<ol>
<li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2栈；</p>
</li>
<li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<p>4.1.如果s1为空，或栈顶运算符为左括号“ ( ”，则直接将此运算符入栈；</p>
<p>4.2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p>
<p>4.3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</p>
</li>
<li><p>遇到括号时：<br>(1) 如果是左括号“ ( ”，则直接压入s1<br>(2) 如果是右括号“ ) ”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</p>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></p>
</li>
</ol>
<p><strong>注：中缀表达式转为前缀表达式是从又往左扫描中缀表达式，核心算法思想相同</strong>😄😄</p>
</blockquote>
<p><strong>实例分析</strong></p>
<p>将中缀表达式1+((2+3)*4)-5转换为后缀表达式。</p>
<p><img src="/2021/09/18/Stack2/3.png" alt></p>
<p>按照步骤最终结果为：1 2 3 + 4 * + 5 -</p>
<h3 id="2-5-中缀转前缀表达式"><a href="#2-5-中缀转前缀表达式" class="headerlink" title="2.5 中缀转前缀表达式"></a>2.5 中缀转前缀表达式</h3><blockquote>
<p>中缀表达式转为前缀表达式是从又往左扫描中缀表达式，核心算法思想与中缀转后缀表达式相同</p>
</blockquote>
<h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><blockquote>
<p><strong>用栈实现中缀表达式转后缀表达式：</strong> </p>
<p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<p><code>①</code> 遇到操作数。直接加入后缀表达式。 </p>
<p><code>②</code> 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹 出“(”为止。注意：“(”不加入后缀表达式。</p>
<p><code>③</code> 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。 按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p><strong>用栈实现后缀表达式的计算：</strong></p>
<p><code>①</code>从左往右扫描下一个元素，直到处理完所有元素</p>
<p><code>②</code>若扫描到操作数则压入栈，并回到①；否则执行③ </p>
<p><code>③</code>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</p>
<p><strong>用栈实现中缀表达式的计算：</strong> </p>
<p><code>①</code>初始化两个栈，操作数栈和运算符栈 </p>
<p><code>②</code>若扫描到操作数，压入操作数栈</p>
<p><code>③</code>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符， 每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p>
</blockquote>
<h2 id="3-栈在递归中的应用"><a href="#3-栈在递归中的应用" class="headerlink" title="3 栈在递归中的应用"></a>3 栈在递归中的应用</h2><blockquote>
<p><strong>函数调用的特点</strong>：最后被调用的函数最先执行结束<strong>（LIFO）</strong>  </p>
<p>函数调用时，需要用一个<strong>栈存储</strong>：<br>① 调用返回地址<br>② 实参<br>③ 局部变量  </p>
<p>递归调用时，函数调用栈可称为“递归工作栈”<br>每进入一层递归，就将递归调用所需信息压入栈顶<br>每退出一层递归，就从栈顶弹出相应信息  </p>
<p><strong>缺点：</strong></p>
<ul>
<li>效率低；</li>
<li>太多层递归可能会导致栈溢出；</li>
<li>可能包含很多重复计算  </li>
</ul>
</blockquote>
<h2 id="4-队列应用"><a href="#4-队列应用" class="headerlink" title="4 队列应用"></a>4 队列应用</h2><blockquote>
<p><strong>树</strong>、图的广度优先遍历和<strong>操作系统中的应用</strong>（进程调度算法、磁盘算法、页面缺失算法）</p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列（二）队列</title>
    <url>/2021/09/16/Queue1/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="栈和队列（二）队列"><a href="#栈和队列（二）队列" class="headerlink" title="栈和队列（二）队列"></a>栈和队列（二）队列</h1><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h3><p><img src="/2021/09/16/Queue1/1.png" alt></p>
<p><img src="/2021/09/16/Queue1/2.png" alt></p>
<p><img src="/2021/09/16/Queue1/3-1.png" alt></p>
<p><img src="/2021/09/16/Queue1/3.png" alt></p>
<h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote>
<p><strong>队列（Queue）</strong>是只允许在一端进行插入，在另一端删除的线性表  </p>
<p><strong>队列</strong>是一种特殊的线性结构，它只允许在队列的首部（head/front）进行删除操作，这称为“出队”，而在队列的尾部（tail/rear）进行插入操作，这称为“入队”。当队列中没有元素时（即head == tail），称为空队列。比如买票，每个排队买票的窗口就是一个队列。在这个队列当中，新来的人总是站在队列的最后面，来得越早的人越靠前，也就是越早能买到票，我们称为“先进先出”（First In First Out, FIFO）原则。🚘</p>
<ul>
<li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现</li>
<li>在队首删除元素，在队尾插入元素</li>
<li>“先进先出”（FIFO）原则</li>
</ul>
<p><img src="/2021/09/16/Queue1/4.png" alt></p>
</blockquote>
<h4 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h4><blockquote>
<p>队列基本操作</p>
<p><strong>InitQueue(&amp;Q)：</strong>初始化队列，构造一个空队列Q。</p>
<p><strong>DestroyQueue(&amp;Q)：</strong>销毁队列。销毁并释放队列Q所占用的内存空间。</p>
<p><strong>EnQueue(&amp;Q,x)：</strong>入队，若队列Q未满，将x加入，使之成为新的队尾。</p>
<p><strong>DeQueue(&amp;Q,&amp;x)：</strong>出队，若队列Q非空，删除队头元素，并用x返回。</p>
<p><strong>GetHead(Q,&amp;x)：</strong>读队头元素，若队列Q非空，则将队头元素赋值给x。</p>
<p>其他常用操作：</p>
<p><strong>QueueEmpty(Q)：</strong>判队列空，若队列Q为空返回true，否则返回false。  </p>
</blockquote>
<h3 id="3-2-2-顺序队列"><a href="#3-2-2-顺序队列" class="headerlink" title="3.2.2 顺序队列"></a>3.2.2 顺序队列</h3><h4 id="1、顺序队列"><a href="#1、顺序队列" class="headerlink" title="1、顺序队列"></a>1、顺序队列</h4><blockquote>
<p><strong>初始状态（队空状态）:</strong> Q.front == Q.rear == 0</p>
<p><strong>进队操作：</strong>队不满，先送值到队尾元素，再将队尾指针加1</p>
<p><strong>出队操作：</strong>队不空，先去队头元素值，再将队头指针加1</p>
<p>会<strong>出现“上溢出”，即“假溢出”</strong></p>
<p><img src="/2021/09/16/Queue1/5.png" alt></p>
</blockquote>
<h4 id="2、循环队列"><a href="#2、循环队列" class="headerlink" title="2、循环队列"></a>2、循环队列</h4><blockquote>
<p>为了解决顺序队列的“<strong>假溢出</strong>”,充分利用空间，即把存储队列元素的表从逻辑上视为一个<strong>环</strong>。</p>
<p>用模运算将存储空间在逻辑上变成了<strong>“环状”</strong>  。取模运算，即取余运算。两个整数 a,b，a%b == a除以b的余数。</p>
<p><strong>队空状态:</strong>  Q.front == Q.rear；</p>
<p><strong>队满状态：</strong>(Q.rear + 1) % MaxSize == Q.front  </p>
<p><strong>进队操作：</strong>(Q.rear + 1) % MaxSize</p>
<p><strong>出队操作：</strong>(Q.front + 1) % MaxSize</p>
<p><strong>队列个数：</strong>(Q.rear - Q.front + MaxSize) % MaxSize</p>
<p><img src="/2021/09/16/Queue1/6.png" alt></p>
<p><img src="/2021/09/16/Queue1/7.png" alt></p>
</blockquote>
<h4 id="3、区分队空和队满的方式"><a href="#3、区分队空和队满的方式" class="headerlink" title="3、区分队空和队满的方式"></a>3、区分队空和队满的方式</h4><p>（1）</p>
<blockquote>
<p><strong>牺牲一个存储单元</strong> ，队列已满的条件：队尾指针的再下一个位置是队头，</p>
<p>即(Q.rear+1)%MaxSize == Q.front  </p>
</blockquote>
<p>（2）</p>
<blockquote>
<p><strong>类型中增设表示元素个数的数据成员</strong>。</p>
<p>插入成功 size++；</p>
<p>删除成功 size–;  </p>
<p><strong>队满条件：</strong>size==MaxSize</p>
<p><strong>队空条件：</strong>size == 0;   </p>
<p><strong>队列元素个数</strong> = size   </p>
</blockquote>
<p>（3）</p>
<blockquote>
<p><strong>类型中增设tag数据成员</strong></p>
<p>每次删除操作成功时，都令tag=0；</p>
<p>每次插入操作成功时，都令tag=1；  </p>
<p><strong>队满条件：</strong>front==rear &amp;&amp; tag == 1  </p>
<p><strong>队空条件：</strong>front==rear &amp;&amp; tag == 0  </p>
</blockquote>
<h4 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear; <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 初始化队列</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>; <span class="comment">//初始化队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断队空</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.front == Q.rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断是否上溢出</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//牺牲一个单元来区分队空和队满</span></span><br><span class="line">    <span class="keyword">return</span> (Q.rear + <span class="number">1</span>) % MaxSize == Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 入队</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; &amp;Q</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = e; <span class="comment">//入队</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize; <span class="comment">//队尾指针取模后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 出队</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; &amp;Q</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; &amp;e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = Q.data[Q.front];    </span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针取模后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取头元素</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">    GetTop(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Q.data[Q.front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取队列长度</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MaxSize) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 显示队列</span></span><br><span class="line"><span class="comment"> * @param &#123;SqQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = Q.front;</span><br><span class="line">    <span class="keyword">int</span> len = t + GetLength(Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"queue["</span> &lt;&lt; i % MaxSize &lt;&lt; <span class="string">"] = "</span> &lt;&lt; Q.data[i % MaxSize] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">bool</span> loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (loop)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎进行队列的操作，请按指定序号操作，考研顺利！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------菜单---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、入队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、输出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"4、查看队头元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5、查看队长"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0、退出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择序号："</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">switch</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (isFull(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队满"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> e;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数据："</span>;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">                EnQueue(Q, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> e = <span class="number">-1</span>;</span><br><span class="line">                DeQueue(Q, e);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出队的数据为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                printQueue(Q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队顶的数据为： "</span> &lt;&lt; GetTop(Q) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"队长为："</span> &lt;&lt; GetLength(Q) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、效果实现"><a href="#5、效果实现" class="headerlink" title="5、效果实现"></a>5、效果实现</h4><blockquote>
<p><img src="/2021/09/16/Queue1/11.jpg" alt="页面"></p>
<p><img src="/2021/09/16/Queue1/12.jpg" alt="输出队"></p>
<p><img src="/2021/09/16/Queue1/13.jpg" alt="出队"></p>
</blockquote>
<h3 id="3-2-3-链式队列"><a href="#3-2-3-链式队列" class="headerlink" title="3.2.3 链式队列"></a>3.2.3 链式队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   <span class="comment">//链接队列</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    LinkNode *front, *rear; <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 初始化队列</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//建立头结点</span></span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断队空</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return Q.front == Q.rear;</span></span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">size</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 入队</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; &amp;Q</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *t;</span><br><span class="line">    t = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    t-&gt;data = e;</span><br><span class="line">    t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = t; <span class="comment">//入队</span></span><br><span class="line">    Q.rear = t;  <span class="comment">//队尾指针后移</span></span><br><span class="line">    Q.<span class="built_in">size</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 出队</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; &amp;Q</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; &amp;e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;  <span class="comment">//队头指针后移</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) </span><br><span class="line">        Q.rear = Q.front;  <span class="comment">//若原队列只有一个结点，删除后变空</span></span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    Q.<span class="built_in">size</span>--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取头元素</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Q.front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取队列长度</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 显示队列</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkQueue&#125; Q</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *t = Q.front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">"-&gt;"</span>;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">bool</span> loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (loop)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎进行队列的操作，请按指定序号操作，考研顺利！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------菜单---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、入队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、输出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"4、查看队头元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5、查看队长"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0、退出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择序号："</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">switch</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">int</span> e;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数据："</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">            EnQueue(Q, e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> e = <span class="number">-1</span>;</span><br><span class="line">                DeQueue(Q, e);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出队的数据为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                printQueue(Q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"队顶的数据为： "</span> &lt;&lt; GetTop(Q) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"队长为："</span> &lt;&lt; GetLength(Q) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><p><img src="/2021/09/16/Queue1/10.png" alt></p>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-栈和队列（一）栈</title>
    <url>/2021/09/16/Stack1/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="栈和队列（一）栈"><a href="#栈和队列（一）栈" class="headerlink" title="栈和队列（一）栈"></a>栈和队列（一）栈</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/16/Stack1/1.png" alt></p>
<p><img src="/2021/09/16/Stack1/2.png" alt></p>
<p><img src="/2021/09/16/Stack1/3.png" alt></p>
<h2 id="1-栈的基本概念"><a href="#1-栈的基本概念" class="headerlink" title="1 栈的基本概念"></a>1 栈的基本概念</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><blockquote>
<p><strong>栈（Stack）</strong>是只允许在一端进行插入或删除操作的线性表  </p>
<ul>
<li><p>“先入后出”（FILO）原则</p>
</li>
<li><p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。只允许进行插入和删除操作，允许插入和删除的一端，为变化的一端，称为<strong>栈顶（Top）</strong>,另一端为固定的一端，称为<strong>栈底（Bottom）</strong>。</p>
</li>
<li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除<br><img src="/2021/09/16/Stack1/4.png" alt></p>
</li>
</ul>
</blockquote>
<h3 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h3><blockquote>
<p><strong>线性表基本操作</strong></p>
<p><strong>InitList(&amp;L)：</strong>初始化表。构造一个空的线性表L，分配内存空间。</p>
<p><strong>DestroyList(&amp;L)：</strong>销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p>
<p><strong>ListInsert(&amp;L,i,e)：</strong>插入操作。在表L中的第i个位置上插入指定元素e。</p>
<p><strong>ListDelete(&amp;L,i,&amp;e)：</strong>删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<p><strong>LocateElem(L,e)：</strong>按值查找操作。在表L中查找具有给定关键字值的元素。</p>
<p><strong>GetElem(L,i)：</strong>按位查找操作。获取表L中第i个位置的元素的值。 </p>
<p>其他常用操作： </p>
<p><strong>Length(L)：</strong>求表长。返回线性表L的长度，即L中数据元素的个数。</p>
<p><strong>PrintList(L)：</strong>输出操作。按前后顺序输出线性表L的所有元素值。</p>
<p><strong>Empty(L)：</strong>判空操作。若L为空表，则返回true，否则返回false。</p>
<p><strong>栈的基本操作</strong></p>
<p><strong>InitStack(&amp;S)：</strong>初始化栈。构造一个空栈 S，分配内存空间。</p>
<p><strong>DestroyStack(&amp;S)</strong>：销毁栈。销毁并释放栈 S 所占用的内存空间。</p>
<p><strong>Push(&amp;S,x)：</strong>进栈，若栈S未满，则将x加入使之成为新栈顶。</p>
<p><strong>Pop(&amp;S,&amp;x)：</strong>出栈，若栈S非空，则弹出栈顶元素，并用x返回。</p>
<p><strong>GetTop(S, &amp;x)：</strong>读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素</p>
<p>其他常用操作：</p>
<p><strong>StackEmpty(S)：</strong>判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。  </p>
</blockquote>
<h3 id="3、卡特兰数"><a href="#3、卡特兰数" class="headerlink" title="3、卡特兰数"></a><strong>3、卡特兰数</strong></h3><p><img src="/2021/09/16/Stack1/5.png" alt></p>
<h2 id="2-顺序栈"><a href="#2-顺序栈" class="headerlink" title="2 顺序栈"></a>2 顺序栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;  <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 初始化栈</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;  <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断栈是否空</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断栈是否满</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top == MaxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 入栈</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top++;  <span class="comment">//指针加一</span></span><br><span class="line">    S.data[S.top] = e;  <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 出栈</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; &amp;e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = S.data[S.top];</span><br><span class="line">    S.top--;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 取栈顶元素</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S)) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> S.data[S.top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 输出栈</span></span><br><span class="line"><span class="comment"> * @param &#123;SqStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = S.top; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack["</span> &lt;&lt; i  &lt;&lt; <span class="string">"] = "</span> &lt;&lt; S.data[i] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqStack S; <span class="comment">//初始化</span></span><br><span class="line">    initStack(S); </span><br><span class="line">    <span class="keyword">bool</span> loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (loop)</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎进行栈的操作，请按指定序号操作，考研顺利！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------菜单---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、入栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、出栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、输出栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"4、查看栈顶元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0、退出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择序号："</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">switch</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (isFull(S)) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈满"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> e;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数据："</span> ;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">                Push(S, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> e = <span class="number">-1</span>;</span><br><span class="line">                Pop(S, e);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出栈的数据为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                printStack(S);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶的数据为： "</span> &lt;&lt; GetTop(S) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-链表栈"><a href="#3-链表栈" class="headerlink" title="3 链表栈"></a>3 链表栈</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">&#125;*LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 初始化栈</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initStack</span><span class="params">(LinkStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    LinkStack *L; //初始化栈顶指针</span></span><br><span class="line">   S = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">   <span class="keyword">if</span>(S == <span class="literal">NULL</span>) </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   S-&gt;length = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断栈是否空</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 入栈 -- 头插法</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack &amp;S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkNode *t;</span><br><span class="line">    t = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    t-&gt;data = e;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">        t-&gt;length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;length = S-&gt;next-&gt;length + <span class="number">1</span>;    </span><br><span class="line">    t-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = t;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 出栈</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; &amp;S</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; &amp;e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack &amp;S, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = S-&gt;next;    </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    S-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 取栈顶元素</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 输出栈</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkNode *t = S-&gt;next;    </span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"stack ["</span> &lt;&lt; t-&gt;length &lt;&lt; <span class="string">"] = "</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取链长</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkStack&#125; S</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(LinkStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;next-&gt;length;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack S; <span class="comment">//初始化</span></span><br><span class="line">    initStack(S);</span><br><span class="line">    <span class="keyword">bool</span> loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"欢迎进行栈的操作，请按指定序号操作，考研顺利！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------菜单---------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1、入栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2、出栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3、输出栈"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"4、查看栈顶元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5、查看链长"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"0、退出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择序号："</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">switch</span> (num)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">int</span> e;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入数据："</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">            Push(S, e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> e = <span class="number">-1</span>;</span><br><span class="line">                Pop(S, e);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出栈的数据为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                printStack(S);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(S))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶的数据为： "</span> &lt;&lt; GetTop(S) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"链长为："</span> &lt;&lt; GetLength(S) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="程序效果"><a href="#程序效果" class="headerlink" title="程序效果"></a>程序效果</h2><blockquote>
<p><img src="/2021/09/16/Stack1/6.png" alt></p>
<p><img src="/2021/09/16/Stack1/7.png" alt></p>
<p><img src="/2021/09/16/Stack1/8.png" alt></p>
<p><img src="/2021/09/16/Stack1/9.png" alt></p>
<p><img src="/2021/09/16/Stack1/10.png" alt></p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表（四）循环链表</title>
    <url>/2021/09/15/Linear4/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="线性表（四）循环链表"><a href="#线性表（四）循环链表" class="headerlink" title="线性表（四）循环链表"></a>线性表（四）循环链表</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/15/Linear4/1.png" alt></p>
<h2 id="1-循环链表"><a href="#1-循环链表" class="headerlink" title="1 循环链表"></a>1 循环链表</h2><h3 id="（1）循环单链表"><a href="#（1）循环单链表" class="headerlink" title="（1）循环单链表"></a>（1）循环单链表</h3><blockquote>
<p><strong>循环链表跟单链表的区在尾结点指针是指向链表的头结点</strong>。和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环</p>
<p>型结构特点时，采用循环链表实现代码会简洁很多。</p>
<p><img src="/2021/09/15/Linear4/2.png" alt></p>
</blockquote>
<p><strong>代码</strong></p>
<blockquote>
<p><strong>注意代码判空判满的实现</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> //定义单链表结点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data;           <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 循环链表初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L; <span class="comment">//头结点NEXT指向头结点</span></span><br><span class="line">    <span class="comment">//L = NULL; //空表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断循环链表是否为空</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkList&#125; L</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="comment"> * @param &#123;LinkList&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;LNode&#125; *p</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L, LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（2）循环双链表"><a href="#（2）循环双链表" class="headerlink" title="（2）循环双链表"></a>（2）循环双链表</h3><p><img src="/2021/09/15/Linear4/3.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    DoubleLinkedList *prior, *next;</span><br><span class="line">&#125; DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断循环链表是否为空</span></span><br><span class="line"><span class="comment"> * @param &#123;DLinkList&#125; L</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(DLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next == L &amp;&amp; L-&gt;prior == L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="comment"> * @param &#123;DLinkList&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;DNode&#125; *p</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L, DNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;next == L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）约瑟夫环问题"><a href="#（3）约瑟夫环问题" class="headerlink" title="（3）约瑟夫环问题"></a>（3）约瑟夫环问题</h3><blockquote>
<p>N个人坐成一个圆环（编号为1 - N），从第1个人开始报数✋，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。</p>
</blockquote>
<p>👉<strong>思路：</strong></p>
<blockquote>
<p>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Josephus</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">int</span> m )</span> </span>&#123;</span><br><span class="line">    Firster ( );                                <span class="comment">//检验指针指向第一个结点</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ ) &#123;           <span class="comment">//执行n-1次</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>; j++ )  <span class="comment">//循环m次使current指向被删除结点</span></span><br><span class="line">            Next ( );</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"出列的人是"</span> &lt;&lt; GetElem_L ( ) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//出列人员的数据</span></span><br><span class="line">        ListDelete ( );                    <span class="comment">//删去每一趟的第m结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-顺序表和链表比较"><a href="#2-顺序表和链表比较" class="headerlink" title="2 顺序表和链表比较"></a>2 顺序表和链表比较</h2><p><img src="/2021/09/15/Linear4/4.png" alt></p>
<h3 id="2-1-逻辑结构"><a href="#2-1-逻辑结构" class="headerlink" title="2.1 逻辑结构"></a>2.1 逻辑结构</h3><blockquote>
<p>都属于线性表，都是<strong>线性结构</strong>  </p>
</blockquote>
<h3 id="2-2-存储结构"><a href="#2-2-存储结构" class="headerlink" title="2.2 存储结构"></a>2.2 存储结构</h3><blockquote>
<p><strong>顺序表 ：顺序存储</strong></p>
<ul>
<li>优点：支持随机存取、存储密度高</li>
<li>缺点：大片连续空间分配不方便，改变容量不方便   </li>
</ul>
<p><strong>链表：链式存储</strong> </p>
<ul>
<li>优点：离散的小空间分配方便，改变容量方便</li>
<li>缺点：不可随机存取，存储密度低  </li>
</ul>
</blockquote>
<h3 id="2-3-基本操作"><a href="#2-3-基本操作" class="headerlink" title="2.3 基本操作"></a>2.3 基本操作</h3><h4 id="1、创"><a href="#1、创" class="headerlink" title="1、创"></a>1、创</h4><blockquote>
<p><strong>顺序表：</strong></p>
<ul>
<li>需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源</li>
<li>静态分配：静态数组、容量不可改变  </li>
<li>动态分配：动态数组（malloc、free）   容量可改变，但需要移动大量元素，时间代价高  </li>
</ul>
<p><strong>链表：</strong></p>
<p>只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展  </p>
</blockquote>
<h4 id="2、销"><a href="#2、销" class="headerlink" title="2、销"></a>2、销</h4><blockquote>
<p><strong>顺序表：</strong></p>
<p>修改 Length = 0</p>
<p>静态分配：静态数组、系统自动回收空间</p>
<p>动态分配：动态数组（malloc、free）需要手动 free</p>
<p><strong>链表：</strong></p>
<p>依次删除各个结点（free）</p>
</blockquote>
<h4 id="3、增、删"><a href="#3、增、删" class="headerlink" title="3、增、删"></a>3、增、删</h4><blockquote>
<p><strong>顺序表：</strong></p>
<ol>
<li>插入/删除元素要将后续元素都后移/前移  </li>
<li>时间复杂度 O(n)，时间开销主要来自移动元素  </li>
<li>若数据元素很大，则移动的时间代价很高  </li>
</ol>
<p><strong>链表：</strong></p>
<ol>
<li>插入/删除元素只需修改指针即可  </li>
<li>时间复杂度 O(n)，时间开销主要来自查找目标元素  </li>
<li>查找元素的时间代价更低  </li>
</ol>
</blockquote>
<h4 id="4、查"><a href="#4、查" class="headerlink" title="4、查"></a>4、查</h4><blockquote>
<p><strong>顺序表：</strong></p>
<ol>
<li>按位查找：O(1)  </li>
<li>按值查找：O(n)<br>若表内元素有序，可在O(log2n) 时间内找到  </li>
</ol>
<p><strong>链表：</strong></p>
<ol>
<li>按位查找：O(n)  </li>
<li>按值查找：O(n)</li>
</ol>
</blockquote>
<h3 id="2-4-选择"><a href="#2-4-选择" class="headerlink" title="2.4 选择"></a>2.4 选择</h3><p><img src="/2021/09/15/Linear4/5.png" alt></p>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表（三）双链表</title>
    <url>/2021/09/14/Linear3/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="线性表（三）双链表"><a href="#线性表（三）双链表" class="headerlink" title="线性表（三）双链表"></a>线性表（三）双链表</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/14/Linear3/1.png" alt></p>
<h2 id="2-1-线性表的链式表示"><a href="#2-1-线性表的链式表示" class="headerlink" title="2.1 线性表的链式表示"></a>2.1 线性表的链式表示</h2><blockquote>
<p>链式存储线性表时，不需要使用地址连续的存储单元，结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</p>
</blockquote>
<h2 id="2-2-双链表"><a href="#2-2-双链表" class="headerlink" title="2.2 双链表"></a>2.2 双链表</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote>
<p>比单链表多一个 <strong>前驱指针prior</strong></p>
<p><strong>优缺点：</strong></p>
<ul>
<li>可进可退，存储密度比单链表更低一点；  </li>
<li>双链表不可随机存取；</li>
<li>按位查找、按值查找操作都只能用遍历的方式实现。</li>
</ul>
<p><strong>时间复杂度O(n)</strong></p>
</blockquote>
<h3 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h3><h3 id="（1）插入"><a href="#（1）插入" class="headerlink" title="（1）插入"></a>（1）插入</h3><p><img src="/2021/09/14/Linear3/2.png" alt></p>
<h3 id="（2）删除"><a href="#（2）删除" class="headerlink" title="（2）删除"></a>（2）删除</h3><p><img src="/2021/09/14/Linear3/3.png" alt></p>
<h3 id="（3）遍历"><a href="#（3）遍历" class="headerlink" title="（3）遍历"></a>（3）遍历</h3><blockquote>
<p>👉 遍历方式和单链表一样，可以<strong>向前遍历</strong>也可以向后遍历</p>
</blockquote>
<p><img src="/2021/09/14/Linear3/4.png" alt></p>
<h3 id="（4）代码"><a href="#（4）代码" class="headerlink" title="（4）代码"></a>（4）代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DoubleLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    DoubleLinkedList *prior, *next;</span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(L-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入数据</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNode</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    DNode *s;</span><br><span class="line">    DNode *temp = L;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    s = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior = temp;</span><br><span class="line">    temp-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后向遍历数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNodetoNext</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"后向遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前向遍历数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNodetoPrior</span><span class="params">(DLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"前向遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    DNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;prior != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p = p-&gt;prior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定位置元素</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(DLinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   DNode *p = L;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">       p = p-&gt;next;</span><br><span class="line">       j++;</span><br><span class="line">   &#125; </span><br><span class="line">   DNode *q = p-&gt;next;</span><br><span class="line">   p-&gt;next = q-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       q-&gt;next-&gt;prior = p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">free</span>(q);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    DLinkList L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; isEmpty(L) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    InsertNode(L, <span class="number">4</span>);</span><br><span class="line">    InsertNode(L, <span class="number">2</span>);</span><br><span class="line">    InsertNode(L, <span class="number">5</span>);</span><br><span class="line">    InsertNode(L, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    printNodetoNext(L);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    DeleteNode(L, <span class="number">2</span>);</span><br><span class="line">    printNodetoNext(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">插入成功！</span><br><span class="line">插入成功！</span><br><span class="line">插入成功！</span><br><span class="line">插入成功！</span><br><span class="line">后向遍历</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">删除成功！</span><br><span class="line">后向遍历</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表（二）单链表</title>
    <url>/2021/09/13/Linear2/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="线性表（二）单链表"><a href="#线性表（二）单链表" class="headerlink" title="线性表（二）单链表"></a>线性表（二）单链表</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/13/Linear2/1.png" alt></p>
<p><img src="/2021/09/13/Linear2/2.png" alt></p>
<p><img src="/2021/09/13/Linear2/3.png" alt></p>
<h2 id="2-1-线性表的链式表示"><a href="#2-1-线性表的链式表示" class="headerlink" title="2.1 线性表的链式表示"></a>2.1 线性表的链式表示</h2><blockquote>
<p>链式存储线性表时，不需要使用地址连续的存储单元，结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</p>
</blockquote>
<h2 id="2-2-单链表"><a href="#2-2-单链表" class="headerlink" title="2.2 单链表"></a>2.2 单链表</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><blockquote>
<p><strong>线性表的链式存储又称单链表</strong>，链表通过指针将一组<strong>零散</strong>的内存块串联在一起，内存块称为链表的<strong>“结点”</strong>。每个链表的结点除了存储数据之外，还需要记录链上的<strong>下一个结点的地址</strong>，叫作<strong>后继指针 next</strong>。链表有两个特殊的结点，分别是第一个<strong>结点（头结点）</strong>和最后一个结点<strong>（尾结点）</strong>。头结点用来记录<strong>链表的基地址</strong>，用它可以遍历得到整条链表。尾结点指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p>
<ol>
<li>链表是以节点的方式来存储,是链式存储。</li>
<li>每个节点包含 data 域， next 域：指向下一个节点。</li>
<li>链表的各个节点不一定是连续存储。</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定。</li>
</ol>
<p><strong>头指针</strong>是指向链表中第一个结点的指针。</p>
<p><strong>头结点</strong>是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息。</p>
<p><strong>首元结点</strong>是指链表中存储第一个数据元素a1的结点。</p>
</blockquote>
<h3 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h3><blockquote>
<p><strong>优点：</strong> 不要求大片连续空间，改变容量方便<br><strong>缺点：</strong> 不可随机存取，要耗费一定空间存放指针  </p>
</blockquote>
<h3 id="3、结构图"><a href="#3、结构图" class="headerlink" title="3、结构图"></a>3、结构图</h3><p><strong>（1）内存结构图</strong></p>
<p><img src="/2021/09/13/Linear2/4.png" alt></p>
<p><strong>（2）逻辑结构图</strong></p>
<p><img src="/2021/09/13/Linear2/6.png" alt></p>
<h3 id="4、基本操作"><a href="#4、基本操作" class="headerlink" title="4、基本操作"></a>4、基本操作</h3><h3 id="（1）建立单链表"><a href="#（1）建立单链表" class="headerlink" title="（1）建立单链表"></a>（1）建立单链表</h3><p><strong>头插法建立单链表</strong></p>
<blockquote>
<p>该方法从一个空表开始，生成新节点，将新结点插入到当前链表的表头，即头结点之后。</p>
<p><strong>平均时间复杂度：O(n)</strong></p>
<p><strong>头插法的重要应用：</strong>链表的逆置  （reverse LinkedList）</p>
</blockquote>
<p><img src="/2021/09/13/Linear2/7.png" alt></p>
<p><strong>尾插法建立单链表</strong></p>
<blockquote>
<p>该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针，使其始终指向当前链表的尾结点。</p>
</blockquote>
<p><img src="/2021/09/13/Linear2/8.png" alt></p>
<h3 id="（2）插入单链表"><a href="#（2）插入单链表" class="headerlink" title="（2）插入单链表"></a>（2）插入单链表</h3><p><strong>按位序插入</strong></p>
<blockquote>
<p><strong>ListInsert(&amp;L,i,e)：</strong>插入操作。在表L中的第i个位置上插入指定元素e。</p>
<p><strong>平均时间复杂度：O(n)</strong></p>
</blockquote>
<p><img src="/2021/09/13/Linear2/9.png" alt></p>
<p><strong>对某一结点进行前插操作</strong></p>
<blockquote>
<p><strong>时间复杂度：O(1)</strong></p>
</blockquote>
<p><img src="/2021/09/13/Linear2/10.png" alt></p>
<p><strong>对某一结点进行后插操作</strong></p>
<blockquote>
<p><strong>时间复杂度：O(1)</strong></p>
</blockquote>
<p><img src="/2021/09/13/Linear2/11.png" alt></p>
<h3 id="（3）删除单链表"><a href="#（3）删除单链表" class="headerlink" title="（3）删除单链表"></a>（3）删除单链表</h3><p><strong>按位序删除</strong></p>
<blockquote>
<p><strong>ListDelete(&amp;L,i,&amp;e)：</strong>删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。  </p>
<p><strong>平均时间复杂度：O(n)</strong></p>
</blockquote>
<p><img src="/2021/09/13/Linear2/12.png" alt></p>
<p><strong>指定结点的删除</strong></p>
<blockquote>
<p><strong>时间复杂度：O(1)</strong></p>
</blockquote>
<p><img src="/2021/09/13/Linear2/13.png" alt></p>
<h3 id="（4）查找单链表"><a href="#（4）查找单链表" class="headerlink" title="（4）查找单链表"></a>（4）查找单链表</h3><p><strong>按位查找</strong></p>
<blockquote>
<p><strong>GetElem(L,i)：</strong>按位查找操作。获取表L中第i个位置的元素的值。 </p>
<p><strong>平均时间复杂度：O(n)</strong></p>
</blockquote>
<p><strong>按值查找</strong></p>
<blockquote>
<p><strong>LocateElem(L,e)：</strong>按值查找操作。在表L中查找具有给定关键字值的元素。  </p>
<p><strong>平均时间复杂度：O(n)</strong></p>
</blockquote>
<h3 id="（5）表长"><a href="#（5）表长" class="headerlink" title="（5）表长"></a>（5）表长</h3><blockquote>
<p>遍历链表计算</p>
<p><strong>时间复杂度：O(n)</strong></p>
</blockquote>
<h3 id="（6）代码"><a href="#（6）代码" class="headerlink" title="（6）代码"></a>（6）代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个链表</span></span><br><span class="line"><span class="comment">//强调这是一个单链表  ——使用 LinkList</span></span><br><span class="line"><span class="comment">//强调这是一个结点    ——使用 LNode *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> //定义单链表结点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125; LNode, *LinkList;      <span class="comment">//LNode *p == LinkList p</span></span><br><span class="line"><span class="comment">//指针变量p：表示结点地址</span></span><br><span class="line"><span class="comment">//结点变量 *p：表示一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)  <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="comment">//L = NULL; //空表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否为空</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头插法</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    LNode *s;  <span class="comment">//新结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = i; <span class="comment">//数据</span></span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s; <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尾插法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *s; <span class="comment">//新结点</span></span><br><span class="line">    LNode *r = L; <span class="comment">//尾指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = i; <span class="comment">//数据</span></span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s; <span class="comment">//r指向新的表位</span></span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出链表</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode *temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位序插入</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"在第 "</span> &lt;&lt; i &lt;&lt; <span class="string">" 位"</span> &lt;&lt; <span class="string">"插入数值为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对某一结点进行后插操作</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对某一结点进行前插操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPreNode</span><span class="params">(LNode *p, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;    </span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位删除</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);  <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除第 "</span> &lt;&lt; i &lt;&lt; <span class="string">" 位"</span> &lt;&lt;<span class="string">"数值为："</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteByNode</span><span class="params">(LNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位查找</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkedListSearchBySite</span><span class="params">(LinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找第 "</span> &lt;&lt; i &lt;&lt; <span class="string">" 位的值为："</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">//获得头结点</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按值查找</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkedListSearchByValue</span><span class="params">(LinkList L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找值为 "</span> &lt;&lt; e &lt;&lt; <span class="string">" 的位置为："</span>;</span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">//获得头结点</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p -&gt;data != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求表长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLength</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"表长为 "</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">// L = List_HeadInsert(L);</span></span><br><span class="line">    L = List_TailInsert(L);</span><br><span class="line">    <span class="comment">// L = List_TailInsert2(L);</span></span><br><span class="line">    printList(L);</span><br><span class="line">    GetLength(L);</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    LinkedListInsert(L, <span class="number">4</span>, <span class="number">520</span>);</span><br><span class="line">    LinkedListInsert(L, <span class="number">6</span>, <span class="number">1314</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    ListDelete(L, <span class="number">2</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; LinkedListSearchBySite(L, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; LinkedListSearchByValue(L, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">表长为 <span class="number">10</span></span><br><span class="line">在第 <span class="number">4</span> 位插入数值为：<span class="number">520</span></span><br><span class="line">插入成功！</span><br><span class="line">在第 <span class="number">6</span> 位插入数值为：<span class="number">1314</span></span><br><span class="line">插入成功！</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">520</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1314</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">删除第 <span class="number">2</span> 位数值为：<span class="number">2</span></span><br><span class="line">删除成功！</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">520</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1314</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">查找第 <span class="number">4</span> 位的值为：<span class="number">4</span></span><br><span class="line">查找值为 <span class="number">8</span> 的位置为：<span class="number">9</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-线性表（一）概念及基本操作</title>
    <url>/2021/09/12/LinearOne/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="线性表（一）概念及基本操作"><a href="#线性表（一）概念及基本操作" class="headerlink" title="线性表（一）概念及基本操作"></a>线性表（一）概念及基本操作</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/12/LinearOne/1.png" alt></p>
<p><img src="/2021/09/12/LinearOne/2.png" alt></p>
<p><img src="/2021/09/12/LinearOne/3.png" alt></p>
<p><img src="/2021/09/12/LinearOne/4.png" alt></p>
<h2 id="2-1-线性表的定义及基本操作"><a href="#2-1-线性表的定义及基本操作" class="headerlink" title="2.1 线性表的定义及基本操作"></a>2.1 线性表的定义及基本操作</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><blockquote>
<p>线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列，其中n为表长，当n = 0时线性表是一个空表。若用L命名线性表，则其一般表示为  </p>
<p>$L = (a_1, a_2, … , a_i, a_i+1, … , a_n)$</p>
<p>几个概念：<br>$a_i$是线性表中的“第i个”元素线性表中的位序<br>$a_1$是表头元素；$a_n$是表尾元素。<br>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继  。</p>
</blockquote>
<h3 id="2-1-2-基本操作"><a href="#2-1-2-基本操作" class="headerlink" title="2.1.2 基本操作"></a>2.1.2 基本操作</h3><blockquote>
<p><strong>InitList(&amp;L)：</strong><code>初始化</code>表。构造一个空的线性表L，<code>分配内存空间</code>。</p>
<p><strong>DestroyList(&amp;L)：</strong><code>销毁</code>操作。销毁线性表，并<code>释放</code>线性表L所占用的<code>内存空间</code>。</p>
<p><strong>ListInsert(&amp;L,i,e)：</strong><code>插入</code>操作。在表L中的第i个位置上插入指定元素e。</p>
<p><strong>ListDelete(&amp;L,i,&amp;e)：</strong><code>删除</code>操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p>
<p><strong>LocateElem(L,e)：</strong><code>按值查找</code>操作。在表L中查找具有给定关键字值的元素。 </p>
<p><strong>GetElem(L,i)：</strong><code>按位查找</code>操作。获取表L中第i个位置的元素的值。 </p>
<p>其他常用操作：</p>
<p><strong>Length(L)：</strong>求表长。返回线性表L的长度，即L中数据元素的个数。</p>
<p><strong>PrintList(L)：</strong>输出操作。按前后顺序输出线性表L的所有元素值。</p>
<p><strong>Empty(L)：</strong>判空操作。若L为空表，则返回true，否则返回false。</p>
</blockquote>
<h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h2><h3 id="2-2-1-定义"><a href="#2-2-1-定义" class="headerlink" title="2.2.1 定义"></a>2.2.1 定义</h3><blockquote>
<p><strong>定义：</strong>  顺序表–用<code>顺序存储</code>的方式实现线性表顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。  </p>
</blockquote>
<h4 id="1、静态分配"><a href="#1、静态分配" class="headerlink" title="1、静态分配"></a>1、静态分配</h4><blockquote>
<p>给各个数据元素分配连续的存储空间，<strong>大小为MaxSize x sizeof(ElemType)</strong>  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10 <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize]; <span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;        <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L; <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L); <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data[%d]=%d\n"</span>, i, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、动态分配"><a href="#2、动态分配" class="headerlink" title="2、动态分配"></a>2、动态分配</h4><blockquote>
<p>C语言知识</p>
<p>1、<strong>malloc</strong> 是一个系统函数，它是 memory allocate 的缩写。其中memory是“内存”的意思，allocate是“分配”的意思。顾名思义 malloc 函数的功能</p>
<p>就是“分配内存”。要调用它必须要包含头文件&lt;stdlib.h&gt;。</p>
<p>malloc 函数的返回值是一个地址，这个地址就是动态分配的内存空间的起始地址。如果此函数未能成功地执行，如内存空间不足，则返回空指针 </p>
<p>NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>请求系统分配 4 字节的内存空间，并返回第一字节的地址，然后赋给指针变量 p。当用 malloc 分配动态内存之后，上面这个指针变量 p 就被初始</p>
<p>化了。</p>
<p>2、<strong>sizeof(x)</strong> 计算变量x的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>sizeof（int）的值是 int 型变量所占的字节数，这样就能很好地表示当前计算机中 int 型变量占几字节。这样写程序的可移植性就增强了。所以动态</p>
<p>内存最好是需要多少就构建多少。</p>
<p>3、<strong>free(p)</strong> 释放指针p所指变量的存储空间，即彻底删除一个变量</p>
<p>前面定义了一个指向动态内存的指针变量 p：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>*(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>前面讲过，动态分配的内存空间是由程序员手动编程释放的。那么怎么释放呢？用 free 函数。</p>
<p><strong>free 函数</strong>无返回值，它的功能是释放指针变量 p 所指向的内存单元。此时 p 所指向的那块内存单元将会被释放并还给操作系统，不再归它使用。</p>
<p>操作系统可以重新将它分配给其他变量使用。</p>
<p>需要注意的是，释放<strong>并不是</strong>指清空内存空间，而是指将该内存空间标记为<strong>“可用”状态</strong>，使操作系统在分配内存时可以将它重新分配给其他变量使用。</p>
<p><strong>注意：</strong></p>
<p>只有动态创建的内存才能用 free 把它释放掉，静态内存是不能用free释放的。静态内存只能由系统释放。</p>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> *data; <span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize; <span class="comment">//定义最大长度</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L.MaxSize + len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[i] = p[i];  <span class="comment">//将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len; <span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);  <span class="comment">//释放原来的内存空间</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;    <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L); <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    </span><br><span class="line">    IncreaseSize(L, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、顺序表特点"><a href="#3、顺序表特点" class="headerlink" title="3、顺序表特点"></a>3、顺序表特点</h4><blockquote>
<ol>
<li><strong>随机访问</strong>，即可以在 O(1) 时间内找到第 i 个元素。（代码实现：data[i-1];静态分配、动态分配都一样 ）</li>
<li><strong>存储密度高</strong>，每个节点只存储数据元素</li>
<li><strong>拓展容量不方便</strong>（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</li>
<li><strong>插入、删除操作不方便</strong>，需要移动大量元素</li>
</ol>
</blockquote>
<h3 id="2-2-2-基本操作的实现"><a href="#2-2-2-基本操作的实现" class="headerlink" title="2.2.2 基本操作的实现"></a>2.2.2 基本操作的实现</h3><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><blockquote>
<p><strong>ListInsert(&amp;L,i,e)：</strong>插入操作。在表L中的<strong>第i个位置</strong>上插入<strong>指定元素e</strong>。  </p>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前存储空间是否已满，不能插入</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= MaxSize) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将第i个元素及以后的元素后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;  <span class="comment">//长度++</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印输出</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"长度length = "</span> &lt;&lt; L.length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"数据为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"data["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; L.data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[i] = i;</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">bool</span> flag = ListInsert(L, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">长度length = <span class="number">5</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">data[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">长度length = <span class="number">6</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">6</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">4</span>] = <span class="number">3</span></span><br><span class="line">data[<span class="number">5</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<blockquote>
<p>(1)<strong>最好情况：</strong>新元素插入到表尾，不需要移动元素</p>
<p>i = n+1，循环0次；最好时间复杂度 = O(1)</p>
<p>(2)<strong>最坏情况：</strong>新元素插入到表头，需要将原有的 n 个元素全都向后移动</p>
<p>i = 1，循环 n 次；最坏时间复杂度 = O(n);  </p>
<p>(3)<strong>平均情况：</strong>假设新元素插入到任何一个位置的概率相同，即 i = 1,2,3, … , length+1 的概率都是 p = 1/(n+1)</p>
<p>i = 1，循环 n 次；i = 2 时，循环 n - 1 次；i = 3，循环 n-2 次 …… i = n + 1时，循环0次  </p>
<p>$平均循环次数 = np + (n-1)p + (n-2)p + …… + 1⋅p = \frac{n(n+1)}{2} * \frac{1}{(n+1)} = \frac{n}{2}$ </p>
<p><strong>平均时间复杂度 = O(n)</strong>  </p>
</blockquote>
<h4 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h4><blockquote>
<p><strong>ListDelete(&amp;L,i,&amp;e)：</strong>删除操作。删除表L中<strong>第i个位置</strong>的元素，并用<strong>e返回删除元素的值</strong>。</p>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">    &#125;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将第i个元素及以后的元素前移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;  <span class="comment">//长度--</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印输出</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"长度length = "</span> &lt;&lt; L.length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"数据为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"data["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; L.data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[i] = i;</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    printList(L);</span><br><span class="line">    ListDelete(L, <span class="number">4</span>, e);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除的数字为 "</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">长度length = <span class="number">5</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">data[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">长度length = <span class="number">4</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">4</span></span><br><span class="line">删除的数字为 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<blockquote>
<p>(1)<strong>最好情况：</strong>删除表尾元素，不需要移动其他元素</p>
<p>i = n，循环 0 次；最好时间复杂度 = O(1)</p>
<p>(2)<strong>最坏情况：</strong>删除表头元素，需要将后续的 n-1 个元素全都向前移动</p>
<p>i = 1，循环 n-1 次；最坏时间复杂度 = O(n);</p>
<p>(3)<strong>平均情况：</strong>假设删除任何一个元素的概率相同，即 i = 1,2,3, … , length 的概率都是   $p = \frac{1}{n}$</p>
<p>i = 1，循环 n-1 次；i=2 时，循环 n-2 次；i=3，循环 n-3 次 …… i =n 时，循环0次  </p>
<p>$平均循环次数 = (n-1)p + (n-2)p + …… + 1⋅p = \frac{n(n-1)}{2} * \frac{1}{n} = \frac{(n-1)}{2}$ </p>
<p><strong>平均时间复杂度 = O(n)</strong>  </p>
</blockquote>
<h4 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h4><h5 id="（1）按位查找"><a href="#（1）按位查找" class="headerlink" title="（1）按位查找"></a>（1）<strong>按位查找</strong></h5><blockquote>
<p><strong>GetElem(L,i)：</strong>按位查找操作。获取表L中第i个位置的元素的值。  </p>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> *data; <span class="comment">//动态分配</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按位查找顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListSearchBySite</span><span class="params">(SqList L,  <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找第 "</span> &lt;&lt; i &lt;&lt; <span class="string">" 位的值为："</span>;</span><br><span class="line">    <span class="keyword">return</span>  L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"长度length = "</span> &lt;&lt; L.length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"数据为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"data["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; L.data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[i] = i;</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ListSearchBySite(L, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">长度length = <span class="number">5</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">data[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">查找第 <span class="number">3</span> 位的值为：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<blockquote>
<p>由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第 i 个元素——“随机存取”特性  </p>
<p><strong>时间复杂度 = O(n)</strong></p>
</blockquote>
<h5 id="（2）按值查找"><a href="#（2）按值查找" class="headerlink" title="（2）按值查找"></a>（2）<strong>按值查找</strong></h5><blockquote>
<p><strong>LocateElem(L,e)：</strong>按值查找操作。在表L中查找具有给定关键字值的元素。  </p>
</blockquote>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按值查找顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListSearchByValue</span><span class="params">(SqList L, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"查找值为 "</span> &lt;&lt; e &lt;&lt; <span class="string">" 的位置为："</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"长度length = "</span> &lt;&lt; L.length &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"数据为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"data["</span> &lt;&lt; i &lt;&lt; <span class="string">"] = "</span> &lt;&lt; L.data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        L.data[i] = i;</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ListSearchByValue(L, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">长度length = <span class="number">5</span></span><br><span class="line">数据为：</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">data[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">data[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">data[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">data[<span class="number">4</span>] = <span class="number">4</span></span><br><span class="line">查找值为 <span class="number">1</span> 的位置为：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<blockquote>
<p>（1）<strong>最好情况：</strong>目标元素在表头循环1次；最好时间复杂度 = O(1);</p>
<p>（2）<strong>最坏情况：</strong>目标元素在表尾循环 n 次；最坏时间复杂度 = O(n);</p>
<p>（3）<strong>平均情况：</strong>假设目标元素出现在任何一个位置的概率相同，都是  $\frac{1}{n}$</p>
<p>$平均循环次数 = np + (n-1)p + (n-2)p + …… + 1⋅p = \frac{n(n+1)}{2} * \frac{1}{n} = \frac{(n+1)}{2}$</p>
<p><strong>平均时间复杂度 = O(n)</strong>  </p>
</blockquote>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-绪论（二）</title>
    <url>/2021/09/11/DataStructure-preface2/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="绪论（二）"><a href="#绪论（二）" class="headerlink" title="绪论（二）"></a>绪论（二）</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/11/DataStructure-preface2/2.png" alt></p>
<h2 id="1-3-算法"><a href="#1-3-算法" class="headerlink" title="1.3 算法"></a>1.3 算法</h2><p><strong>程序</strong> = <strong>数据结构</strong> + <strong>算法</strong></p>
<blockquote>
<p>定义： <strong>算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。</strong> （求解问题的步骤）</p>
</blockquote>
<h3 id="1-3-1-算法的特性"><a href="#1-3-1-算法的特性" class="headerlink" title="1.3.1 算法的特性"></a>1.3.1 算法的特性</h3><blockquote>
<p>一个算法必须满足以下五个<strong>重要特性</strong>。 </p>
<ol>
<li><strong>有穷性</strong>。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。</li>
<li><strong>确定性</strong>。对千每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 </li>
<li><strong>可行性</strong>。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 </li>
<li><strong>输入</strong>。一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的， 在它们被调用时，从主调函数获得输入值。</li>
<li><strong>输出</strong>。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的 算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示</li>
</ol>
<p>好算法的特质</p>
<ol>
<li><strong>正确性</strong>。算法应能够正确地解决求解问题。  </li>
<li><strong>可读性</strong>。算法应具有良好的可读性，以帮助人们理解。  </li>
<li><strong>健壮性</strong>。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。  </li>
<li><strong>高效率与低存储量需求</strong>。花的时间少。时间复杂度低，不费内存。空间复杂度低  </li>
</ol>
</blockquote>
<h3 id="1-3-2-时间复杂度"><a href="#1-3-2-时间复杂度" class="headerlink" title="1.3.2 时间复杂度"></a>1.3.2 时间复杂度</h3><p><img src="/2021/09/11/DataStructure-preface2/11.png" alt></p>
<blockquote>
<p>定义：<strong>事前预估算法时间开销T(n)与问题规模 n 的关系</strong>（T 表示 “time”） </p>
<p>（1）<strong>加法规则</strong>：多项相加，只保留最高阶的项，且系数变为1  </p>
<p>$T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))$</p>
<p>（2）<strong>乘法规则</strong>：多项相乘，都保留  </p>
<p>$T(n) = T_1(n)×T_2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))$</p>
<p>$O(1) &lt; O(log_2n) &lt; O(n) &lt; O(nlog_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$  </p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface2/12.png" alt></p>
<p><img src="/2021/09/11/DataStructure-preface2/13.png" alt></p>
<h4 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a><strong>例子</strong>🌰</h4><blockquote>
<p>1、逐步递增型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    loveYou(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">//n为问题规模</span></span><br><span class="line">①    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">②    <span class="keyword">while</span>(i &lt;= n) &#123;</span><br><span class="line">③        i++;</span><br><span class="line">④        <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">⑤    <span class="built_in">printf</span>(<span class="string">"I love you more than %d\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>语句频度：</p>
<p>①     1次</p>
<p>②     3001次</p>
<p>③④  3000次</p>
<p>⑤     1次</p>
<p>T(3000) = 1 + 3001 + 2 * 3000 + 1<br>时间开销与问题规模 n 的关系：<br>T(n) = 3n+3 = O(n)  </p>
</blockquote>
<blockquote>
<p>2、嵌套循环性</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n为问题规模</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n) &#123;  <span class="comment">//外层循环执行n次</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, i);</span><br><span class="line">     	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;  <span class="comment">//嵌套两层循环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am Iron Man\n"</span>); <span class="comment">//内层循环共执行n^2次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I love you more than %d\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间开销与问题规模 n 的关系：<br>$T(n) = O(n) + O(n^2)$ = $O(n^2)$  </p>
</blockquote>
<blockquote>
<p>3、指数递增型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n为问题规模</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n) &#123;  <span class="comment">//一次循环</span></span><br><span class="line">        i = i * <span class="number">2</span>;   <span class="comment">//每次翻倍</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I love you more than %d\n"</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>计算上述算法的时间复杂度 T(n)：</p>
<p>设最深层循环的语句频度（总共循环的次数）为 x，($i = 2^x$)则</p>
<p>由循环条件可知，循环结束时刚好满足 $2^x &gt; n$</p>
<p>$x = log_2n + 1$</p>
<p>T(n) = O(x) = <strong>$O(log_2n)$</strong>  </p>
</blockquote>
<blockquote>
<p>4、搜索型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag[n] = &#123;<span class="number">1.</span>..n&#125;; <span class="comment">//flag数组中乱序存放了1~n这些数</span></span><br><span class="line">    loveYou(flag, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> flag[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n为问题规模</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am Iron Man\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//从第一个函数中查找</span></span><br><span class="line">        <span class="keyword">if</span>(flag[i] == n) &#123;  <span class="comment">//找到</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/11/DataStructure-preface2/14.png" alt></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><blockquote>
<p><strong>最坏时间复杂度</strong>：最坏情况下算法的时间复杂度<br><strong>平均时间复杂度</strong>：所有输入示例等概率出现的情况下，算法的期望运行时间<br><strong>最好时间复杂度</strong>：最好情况下算法的时间复杂度 </p>
</blockquote>
<h3 id="1-3-3-空间复杂度"><a href="#1-3-3-空间复杂度" class="headerlink" title="1.3.3 空间复杂度"></a>1.3.3 空间复杂度</h3><p><img src="/2021/09/11/DataStructure-preface2/15.png" alt></p>
<blockquote>
<p><strong>定义：</strong>算法所需存储空间的度量，记作:  S(n)=O(f(n))   其中n为问题的规模(或大小)，空间开销（内存开销）与问题规模 n 之间的关系  </p>
</blockquote>
<p><strong>（1）逐步递增</strong><br><img src="/2021/09/11/DataStructure-preface2/16.png" alt></p>
<p><strong>（2）声明一个一维数组</strong><br><img src="/2021/09/11/DataStructure-preface2/17.png" alt></p>
<p><strong>（3）声明一个二维数组</strong><br><img src="/2021/09/11/DataStructure-preface2/18.png" alt></p>
<p><strong>（4）声明一个二维数组，一个一维数组</strong><br><img src="/2021/09/11/DataStructure-preface2/19.png" alt></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><blockquote>
<p>1、递归型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n为问题规模</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;  <span class="comment">//声明局部变量</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        loveYou(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/11/DataStructure-preface2/20.png" alt></p>
<blockquote>
<p>2、递归型</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loveYou</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//n为问题规模</span></span><br><span class="line">    <span class="keyword">int</span> flag[n];  <span class="comment">//声明一个数组</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        loveYou(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I love you %d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/09/11/DataStructure-preface2/21.png" alt></p>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-绪论（一）</title>
    <url>/2021/09/11/DataStructure-preface1/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="绪论（一）"><a href="#绪论（一）" class="headerlink" title="绪论（一）"></a>绪论（一）</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="/2021/09/11/DataStructure-preface1/1.png" alt></p>
<!-- <img src="DataStructure-Preface1\1.png" alt="image-20210803160642188" style="zoom:80%;" /> -->


<h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1  基本概念"></a>1.1  基本概念</h2><blockquote>
<ol>
<li><p>数据 (Data)  <strong>是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</strong>。如数学计算中用到的整数和实数，文本</p>
<p>编辑中用到的字符串，多媒体程序处理的图形、 图像、声音及动画等通过特殊编码定义后的数据。 </p>
</li>
<li><p>数据元素(DataElement) <strong>是数据的基本单位</strong>，在计算机中通常作为一个整体进行考虑和处理。 在有些情况下，数据元素也称为元素、记录</p>
<p>等。数据元素用于完整地描述一个对象，如一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。 </p>
</li>
<li><p>数据项 (Data Item) <strong>是组成数据元素的、有独立含义的、不可分割的最小单位</strong>。例如，学生基本信息表中的学号、姓名、性别等都是数据<br>项。 <strong>是性质相同的数据元素的集合，是数据的一个子集</strong>。例如：整数数据对象是集合N={O, 士1’ 士2,…}, 字母字符数据对象是集合C= </p>
<p>{‘A’,’B’, …，’Z’,’a’,’b’, …， ‘z’}, 学生基本信息表也可以是一个数据对象。由此可以看出，不论数据元素集合是无限集（如 整数集），或是有限</p>
<p>集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表） 的集合，只要集合内元素的性质均相同，都可称之为一个数据对</p>
<p>象。 </p>
</li>
</ol>
</blockquote>
<h2 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h2><blockquote>
<ol>
<li>数据结构 (Data Structure)== 是相互之间存在一种或多种特定关系的<strong>数据元素</strong>的集合。</li>
<li>线性结构包括<strong>线性表、栈和队列、字符串、数组、 广义表</strong>。</li>
<li>非线性结构包括<strong>树和二叉树、 有向图和无向图</strong>。</li>
</ol>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/3.png" alt></p>
<h3 id="1-2-1-逻辑结构"><a href="#1-2-1-逻辑结构" class="headerlink" title="1.2.1 逻辑结构"></a>1.2.1 逻辑结构</h3><h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><blockquote>
<p>结构中的数据元素之间只存在<strong>一对一</strong>的关系</p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/4.png" alt></p>
<h4 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h4><blockquote>
<p>结构中的数据元素之间只存在<strong>一对多</strong>的关系</p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/5.png" alt></p>
<h4 id="图状结构"><a href="#图状结构" class="headerlink" title="图状结构"></a>图状结构</h4><blockquote>
<p>结构中的数据元素之间只存在<strong>多对多</strong>的关系</p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/6.png" alt></p>
<h3 id="1-2-2-存储结构"><a href="#1-2-2-存储结构" class="headerlink" title="1.2.2 存储结构"></a>1.2.2 存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><blockquote>
<p><strong>顺序存储</strong>。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。  </p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/7.png" alt></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><blockquote>
<p><strong>链式存储</strong>。 逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。  </p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/8.png" alt></p>
<h4 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h4><blockquote>
<p><strong>索引存储</strong>。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）  </p>
</blockquote>
<p><img src="/2021/09/11/DataStructure-preface1/9.png" alt></p>
<h4 id="散列存储"><a href="#散列存储" class="headerlink" title="散列存储"></a>散列存储</h4><blockquote>
<p><strong>散列存储</strong>。根据元素的关键字直接计算出该元素的存储地址，又称<strong>哈希（Hash）存储</strong>  </p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><blockquote>
<p>绪论部分只需要理解两点：</p>
<p>1、若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。</p>
<p>2、数据的存储结构会影响存储空间分配的方便程度。</p>
<p>3、数据的存储结构会影响对数据运算的速度。  </p>
</blockquote>
<h3 id="1-2-3-数据计算"><a href="#1-2-3-数据计算" class="headerlink" title="1.2.3 数据计算"></a>1.2.3 数据计算</h3><blockquote>
<p>施加在数据上的运算包括运算的定义和实现。 运算的定义是针对逻辑结构的，指出运算的功能； </p>
<p>运算的实现是针对存储结构的，指出运算的具体操作步骤。  </p>
<p><strong>常用的数据计算：增删改查排</strong>。</p>
</blockquote>
<h3 id="1-2-4-数据、抽象数据类型"><a href="#1-2-4-数据、抽象数据类型" class="headerlink" title="1.2.4 数据、抽象数据类型"></a>1.2.4 数据、抽象数据类型</h3><p><img src="/2021/09/11/DataStructure-preface1/10.png" alt></p>]]></content>
      <categories>
        <category>C/C++数据结构</category>
      </categories>
      <tags>
        <tag>C/C++数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>StudyShare</title>
    <url>/2020/10/22/StudyShare/</url>
    <content><![CDATA[<h1 id="学习经验交流会"><a href="#学习经验交流会" class="headerlink" title="学习经验交流会"></a>学习经验交流会</h1><h2 id="一、学习心态"><a href="#一、学习心态" class="headerlink" title="一、学习心态"></a>一、学习心态</h2><p>​    大学承担着传播知识、传播思想、传承文化的责任，肩负着培养具有时代特征的、符合社会需要的，有理想、有责任、有道德，掌握专业知识、熟悉职业技能、了解行业思维的人才的神圣使命。😎😎</p>
<p>​    进入大学，我们仍应清醒的认识到自己的身份是学生，自己的职责仍是学习。要明确的认识到学业是大学生立身之本。我们需要社会发展趋势、个人兴趣、特长及所学专业确定自己的学业目标，做好切实可行的职业规划来明白自己以后的学习和生活。😄😄</p>
<p>​    “上大学不在乎在哪上，而在乎怎么学”。希望你们怀揣着梦想，摆正积极学习的态度，过出自己想要的大学生活。将自己的发展与学校命运相结合，与国家命运相结合。👍👍</p>
<h2 id="二、大学规划"><a href="#二、大学规划" class="headerlink" title="二、大学规划"></a>二、大学规划</h2><ol>
<li><p>大一</p>
<ul>
<li><p>提交入党申请书，上党课</p>
</li>
<li><p>了解自己的专业，要学什么东西，找什么样的工作</p>
</li>
<li><p>学好专业课</p>
</li>
<li><p>英语四级</p>
</li>
<li><p>奖学金</p>
<p>（1）国家励志奖学金（综合）</p>
<p>（2）校级奖学金（按成绩）</p>
<p>（3）学科优秀和科技创新单项奖学金（比赛获奖）</p>
<p>（4）创业创新奖学金</p>
</li>
<li><p>积极参加社团组织，各种活动比赛，三下乡，双学位，支教</p>
</li>
</ul>
</li>
<li><p>大二</p>
<ul>
<li>巩固自己的专业知识，定位自己的方向</li>
<li>英语六级</li>
<li>奖学金</li>
<li>积极参加社团组织，各种活动比赛，三下乡</li>
</ul>
</li>
<li><p>大三</p>
<ul>
<li>明确就业方向、准备考研、准备考公务员或教师资格证</li>
<li>奖学金</li>
</ul>
</li>
</ol>
<h2 id="三、学习方法"><a href="#三、学习方法" class="headerlink" title="三、学习方法"></a>三、学习方法</h2><ol>
<li><p>培养学习兴趣💡</p>
<blockquote>
<p>将自己所学的知识进行实践，拥有成就感，提高学习动力</p>
</blockquote>
</li>
<li><p>培养自主学习能力（产入）📚</p>
<blockquote>
<p>通过书籍、网络等其它方式进行自学</p>
</blockquote>
</li>
<li><p>培养总结能力（产出）✏</p>
<blockquote>
<p>将自己所学到的知识进行总结，不仅可以锻炼自己的逻辑思维能力，</p>
<p>而且可以培养写文档的能力</p>
</blockquote>
</li>
</ol>
<h2 id="四、学科竞赛"><a href="#四、学科竞赛" class="headerlink" title="四、学科竞赛"></a>四、学科竞赛</h2><ol>
<li><p>蓝桥杯</p>
</li>
<li><p>ACM比赛</p>
</li>
<li><p>挑战杯</p>
</li>
<li><p>计算机设计大赛</p>
</li>
<li><p>人工智能比赛</p>
</li>
<li><p>大学生创新创业科技项目</p>
</li>
<li><p>大学生科技活动项目</p>
</li>
<li><p>大学生英语竞赛</p>
</li>
<li><p>大学生数学竞赛</p>
<p>……</p>
</li>
</ol>
<h2 id="五、资源分享"><a href="#五、资源分享" class="headerlink" title="五、资源分享"></a>五、资源分享</h2><ol>
<li><p>算法</p>
<ul>
<li>轻大OJ</li>
<li>航电OJ</li>
<li>浙大OJ</li>
<li>LeetCode(力扣)</li>
<li>计蒜客</li>
</ul>
</li>
<li><p>学习</p>
<ul>
<li>哔哩哔哩</li>
<li>菜鸟教程</li>
<li>w3school 在线教程</li>
<li>网易云课堂</li>
<li>慕课堂</li>
<li>各个技术主页文档</li>
</ul>
</li>
<li><p>博客</p>
<ul>
<li>CSDN</li>
<li>博客园</li>
<li>掘金</li>
<li>开源中国</li>
<li>GitHub</li>
</ul>
</li>
<li><p>资源</p>
<ul>
<li><p>高斯课堂</p>
<p>链接: <a href="https://pan.baidu.com/s/1lkVeoF4i0OSyBPI6maTLag" target="_blank" rel="noopener">https://pan.baidu.com/s/1lkVeoF4i0OSyBPI6maTLag</a></p>
<p> 提取码: i93i </p>
</li>
<li><p>四级网课</p>
<p>链接: <a href="https://pan.baidu.com/s/1NB8heJYAfwbQJqe31iYszQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1NB8heJYAfwbQJqe31iYszQ</a> </p>
<p>提取码: 933d </p>
</li>
</ul>
</li>
</ol>]]></content>
      <tags>
        <tag>学习经验</tag>
      </tags>
  </entry>
  <entry>
    <title>递归-八皇后问题</title>
    <url>/2020/03/18/Queen/</url>
    <content><![CDATA[<h2 id="递归-八皇后问题👑👑（回溯算法）"><a href="#递归-八皇后问题👑👑（回溯算法）" class="headerlink" title="递归-八皇后问题👑👑（回溯算法）"></a>递归-八皇后问题👑👑（回溯算法）</h2><h2 id="一、问题介绍"><a href="#一、问题介绍" class="headerlink" title="一、问题介绍"></a>一、问题介绍</h2><blockquote>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。</p>
</blockquote>
<h2 id="二、思路分析💡💡"><a href="#二、思路分析💡💡" class="headerlink" title="二、思路分析💡💡"></a>二、思路分析💡💡</h2><ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤</li>
</ol>
<p><strong>👉说明</strong>：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列。</p>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义数组array， 保存皇后放置的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queen queen = <span class="keyword">new</span> Queen();</span><br><span class="line">        queen.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"一共有"</span> + count + <span class="string">"种解法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">//注意: check 每一次递归时，进入到check中都有一次循环，进行回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;</span><br><span class="line">            showAnswer();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一次放入皇后，并判断皇后是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n，放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (backtrack(n)) &#123;</span><br><span class="line">                <span class="comment">//接着放第n+1个皇后，开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行的后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置n个皇后，就去检查该皇后是否和已摆放的皇后冲突</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 符合规则返回true， 否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//1. array[i] == array[n] 检查是否在同一列</span></span><br><span class="line">            <span class="comment">//2. Math.abs(n - i) == Math.abs(array[n] - array[i]) 检查是否在同一斜线</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="number">1</span> + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果展示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> </span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> </span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> </span><br><span class="line"><span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">7</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> </span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> </span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> </span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">8</span> </span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> </span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">6</span> <span class="number">1</span> </span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">7</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">6</span> <span class="number">2</span> </span><br><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> </span><br><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> </span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">4</span> </span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">4</span> </span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">7</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span> </span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">1</span> <span class="number">5</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">3</span> </span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> </span><br><span class="line"><span class="number">6</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> </span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">3</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> </span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">2</span> <span class="number">6</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">4</span> </span><br><span class="line"><span class="number">7</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">6</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> </span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> </span><br><span class="line"><span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">8</span> <span class="number">3</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">4</span> </span><br><span class="line"><span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> </span><br><span class="line">一共有<span class="number">92</span>种解法</span><br></pre></td></tr></table></figure>

<p>加油！！！😘😘</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之递归</title>
    <url>/2020/03/17/Recursion/</url>
    <content><![CDATA[<h2 id="一、递归的概论"><a href="#一、递归的概论" class="headerlink" title="一、递归的概论"></a>一、递归的概论</h2><p>所谓递归是指，若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是递归的，或者是递归定义的。简单来说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</p>
<h2 id="二、递归的调用机制"><a href="#二、递归的调用机制" class="headerlink" title="二、递归的调用机制"></a>二、递归的调用机制</h2><blockquote>
<p>递归调用规则</p>
</blockquote>
<ol>
<li>当程序执行到一个方法时，就会开辟一个独立的空间(栈)</li>
<li>每个空间的数据(局部变量)，是独立的</li>
</ol>
<p>例如：阶乘问题 👈</p>
<p>当计算4！时</p>
<ol>
<li>执行fac(4),则开辟一个栈，计算fac(3) * 4</li>
<li>执行fac(3),开辟一个栈，计算fac(2) * 3</li>
<li>执行fac(2),开辟一个栈，计算fac(1) * 2</li>
<li>执行fac(1) 得fac(1) == 1,回溯回去从而可得到fan(2) == 1 * 2, fac(3) == 1 * 2 * 3，fac(4) == 1 * 2 * 3 * 4</li>
<li>得到结果4! = 24</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = fac(<span class="number">4</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fac(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、递归的规则-👨‍✈️👨‍✈️"><a href="#三、递归的规则-👨‍✈️👨‍✈️" class="headerlink" title="三、递归的规则 👨‍✈️👨‍✈️"></a>三、递归的规则 👨‍✈️👨‍✈️</h2><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响, 比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须存在递归终止条件，必须向退出递归的条件逼近，否则就是无限递归，导致堆栈溢出。</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h2 id="四、如何编写递归代码？🙃"><a href="#四、如何编写递归代码？🙃" class="headerlink" title="四、如何编写递归代码？🙃"></a>四、如何编写递归代码？🙃</h2><p><strong>摘抄</strong></p>
<blockquote>
<p>写递归代码最关键的是写出递推公式，找到终止条件。写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</p>
</blockquote>
<p><strong>正确的理解递归的思维方式：</strong></p>
<p>如果一个问题 A 可以分解为若干子问题 B、C、D，先假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样理解起来就简单多了。</p>
<p>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p>
<h2 id="五、递归应用场景-🏳‍🌈🏳‍🌈"><a href="#五、递归应用场景-🏳‍🌈🏳‍🌈" class="headerlink" title="五、递归应用场景  🏳‍🌈🏳‍🌈"></a>五、递归应用场景  🏳‍🌈🏳‍🌈</h2><ol>
<li>各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题，斐波那契数列等</li>
<li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法，深搜等</li>
</ol>
<p>加油！！！😘😘</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀、中缀、后缀表达式</title>
    <url>/2020/03/01/StackApply2/</url>
    <content><![CDATA[<h1 id="前缀、中缀、后缀表达式"><a href="#前缀、中缀、后缀表达式" class="headerlink" title="前缀、中缀、后缀表达式"></a>前缀、中缀、后缀表达式</h1><h1 id="一、前缀表达式"><a href="#一、前缀表达式" class="headerlink" title="一、前缀表达式"></a>一、前缀表达式</h1><p>前缀表达式是一种没有括号的算术表达式，与中缀表达式不同的是，<strong>其将运算符写在前面，操作数写在后面</strong>。也被叫做波兰表达式,比如（499 + 1）* 2 + 314 的前缀表达式为 + * + 499 1 2 314</p>
<h2 id="前缀表达式的计算机求值"><a href="#前缀表达式的计算机求值" class="headerlink" title="前缀表达式的计算机求值"></a>前缀表达式的计算机求值</h2><p><strong>求值方法：</strong></p>
<blockquote>
<p>从右至左扫描表达式，遇到数字时，将数字压入栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
</blockquote>
<p>举栗子🌰🌰（499 + 1）* 2 + 314 对应的前缀表达式就是 + * + 499 1 2 314, 针对前缀表达式求值步骤如下:</p>
<ol>
<li>从右至左扫描，将314、2、1、499压入堆栈</li>
<li>遇到+运算符，因此弹出499和1（499为栈顶元素，1为次顶元素），计算499 + 1的值，得500，再将500入栈</li>
<li>接下来是 * 运算符，因此弹出500和2（500为栈顶元素，2为次顶元素），计算500 * 2的值，得1000，再将1000入栈</li>
<li>最后是+运算符，计算出1000 + 314的值，即1314💝💝，由此得出最终结果</li>
</ol>
<h1 id="二、中缀表达式"><a href="#二、中缀表达式" class="headerlink" title="二、中缀表达式"></a>二、中缀表达式</h1><p>中缀表达式是一个通用的算术或逻辑公式表示方法， <strong>操作符是以中缀形式处于操作数的中间</strong>，中缀表达式是人们常用的算术表示方法，比如（499 + 1）* 2 + 314</p>
<h2 id="中缀表达式的计算机求值"><a href="#中缀表达式的计算机求值" class="headerlink" title="中缀表达式的计算机求值"></a>中缀表达式的计算机求值</h2><p>可看另一篇文章，栈实现中缀表达式计算机</p>
<p><a href="https://Mr00wang.github.io/2020/02/29/StackApply1/#more">栈实现中缀表达式计算机</a></p>
<h1 id="三、后缀表达式"><a href="#三、后缀表达式" class="headerlink" title="三、后缀表达式"></a>三、后缀表达式</h1><p>逆波兰式（或逆波兰记法），也叫后缀表达式，<strong>其将运算符写在操作数之后</strong>，后缀表达式源自于前缀表达式，为了区分前缀和后缀表示，通常将后缀表示称为逆波兰表示。比如：（499 + 1）x 2 + 314 的后缀表达试为 499 1 + 2 x 314 +</p>
<h2 id="后缀表达式的计算机求值"><a href="#后缀表达式的计算机求值" class="headerlink" title="后缀表达式的计算机求值"></a>后缀表达式的计算机求值</h2><p><strong>求值方法：</strong></p>
<blockquote>
<p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。</p>
</blockquote>
<p>举栗子🌰🌰（499 + 1）* 2 + 314 对应的后缀表达式就是 499 1 + 2 * 314 +, 针对前缀表达式求值步骤如下:</p>
<ol>
<li>从左至右扫描，将499和1压入堆栈；</li>
<li>遇到+运算符，因此弹出499和1（1为栈顶元素，499为次顶元素），计算出499+1的值，得500，再将500入栈；</li>
<li>将2入栈；</li>
<li>接下来是 * 运算符，因此弹出500和2，计算出500 * 2，得1000，再将1000入栈；</li>
<li>将314入栈；</li>
<li>最后是+运算符，计算出1000+314的值，即1314💗💗，由此得出最终结果    </li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 * 6 -</span></span><br><span class="line">        String suffixExpression = <span class="string">"499 1 + 2 * 314 +"</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1、先将"3 4 + 5 × 6 -" 放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2、将ArrayList 传递一个方法，遍历ArrayList 配合栈 完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = calculate(list);</span><br><span class="line">        System.out.println(<span class="string">"计算的结果是： "</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression 分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//Collections.addAll(list, split);</span></span><br><span class="line">        <span class="keyword">for</span> (String element: split)</span><br><span class="line">            list.add(element);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成逆波兰表达式的计算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 从左至右扫描，将499和1压入堆栈；</span></span><br><span class="line"><span class="comment">	2. 遇到+运算符，因此弹出499和1（1为栈顶元素，499为次顶元素），</span></span><br><span class="line"><span class="comment">	计算出499+1的值，得500，再将500入栈；</span></span><br><span class="line"><span class="comment">	3. 将2入栈；</span></span><br><span class="line"><span class="comment">	4. 接下来是×运算符，因此弹出500和2，计算出500×2，得1000，再将1000入栈；</span></span><br><span class="line"><span class="comment">	5. 将314入栈；</span></span><br><span class="line"><span class="comment">	6. 最后是+运算符，计算出1000+314的值，即1314💗💗，由此得出最终结果	</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建栈，只需要一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item: ls) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123; <span class="comment">//匹配多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(<span class="string">""</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回最后栈顶的结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果展示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算的结果是： <span class="number">1314</span></span><br></pre></td></tr></table></figure>



<h2 id="中缀表达式转为后缀表达式"><a href="#中缀表达式转为后缀表达式" class="headerlink" title="中缀表达式转为后缀表达式"></a>中缀表达式转为后缀表达式</h2><p><strong>转换算法步骤</strong>📋👇</p>
<ol>
<li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2栈；</p>
</li>
<li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<p>4.1.如果s1为空，或栈顶运算符为左括号“ ( ”，则直接将此运算符入栈；</p>
<p>4.2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p>
<p>4.3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</p>
</li>
<li><p>遇到括号时：<br> (1) 如果是左括号“ ( ”，则直接压入s1<br> (2) 如果是右括号“ ) ”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</p>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></p>
</li>
</ol>
<p><strong>注：中缀表达式转为前缀表达式是从又往左扫描中缀表达式，核心算法思想相同</strong>😄😄</p>
<p><strong>实例分析</strong></p>
<p>将中缀表达式1+((2+3)*4)-5转换为前缀表达式。</p>
<p><img src="/2020/03/01/StackApply2/stackApply1.png" alt></p>
<p>按照步骤最终结果为：1 2 3 + 4 * + 5 -</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"不存在该运算符"</span> + operation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、因为直接对str进行操作，不方便，因此，</span></span><br><span class="line"><span class="comment">//先将“1+((2+3)*4)-5”=》中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">// 即“1+((2+3)*4)-5” =》 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"><span class="comment">//将中缀表达式转成对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpression</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个List,存放中缀表达式对应的内容</span></span><br><span class="line">    List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//这是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">    String str; <span class="comment">//对多位数的拼接</span></span><br><span class="line">    <span class="keyword">char</span> c; <span class="comment">//每遍历到一个字符，就放入到c</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果c是一个非数字，需要加入到ls</span></span><br><span class="line">        <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">            ls.add(<span class="string">""</span> + c);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是一个数，需要考虑多位数</span></span><br><span class="line">            str = <span class="string">""</span>; <span class="comment">// 先将str 置成""</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> </span><br><span class="line">                   &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                str += c; <span class="comment">//拼接</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ls.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回中缀表达式的list</span></span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、将得到的中缀表达式对应的List转换为后缀表达式对应的List</span></span><br><span class="line"><span class="comment">//即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =》ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;(); <span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//说明:s2这个栈,在整个转换过程中，没有pop操作，而且后面还需要逆序输出</span></span><br><span class="line">        <span class="comment">//因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用List&lt;String&gt; s2</span></span><br><span class="line">        <span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 储存中间结果的Lists2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//如果是一个数，则加入到s2</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是右括号“ ) ”，则依次弹出s1栈顶的运算符，并压入s2</span></span><br><span class="line">                <span class="comment">//直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop(); <span class="comment">//消除小括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于s1栈顶运算符, </span></span><br><span class="line">                <span class="comment">//将s1栈顶的运算符弹出并加入到s2中，</span></span><br><span class="line">                <span class="comment">//再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="comment">//问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span>(s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek())</span><br><span class="line">                      &gt;= Operation.getValue(item) ) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line">        <span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//注意因为是存放到List, </span></span><br><span class="line">    	<span class="comment">//因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">        <span class="keyword">return</span> s2; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后结合着后缀表达式的求值，便可实现完整的逆波兰计算器！📅📅</p>
<p>加油😘😘</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>栈实现中缀表达式</title>
    <url>/2020/02/29/StackApply1/</url>
    <content><![CDATA[<p>栈实现中缀表达式</p>
<p>👉目的：实现计算一个计算式如（5 + 10 * 2 + 20 / 2）🕵️‍♂️🕵️‍♂️</p>
<p>👉思路：</p>
<ol>
<li>通过一个 index  值（索引），来遍历我们的表达式</li>
<li>如果我们发现是一个数字, 就直接入数栈🗑🗑</li>
<li>如果发现扫描到是一个符号,  就分如下情况<br>（1） 如果发现当前的符号栈为空，就直接入栈🗑🗑<br>（2） 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈🗑🗑，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.🗑🗑</li>
<li>当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</li>
<li>最后在数栈只有一个数字，就是表达式的结果</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入需要计算的表达式:"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String expression1 = scanner.nextLine();</span><br><span class="line">        <span class="comment">//String expression1 = "5 + 10 * 2 + 20 / 2";</span></span><br><span class="line">        <span class="comment">//将全部空格替换掉</span></span><br><span class="line">        String expression = expression1.trim();</span><br><span class="line">        <span class="comment">//先创建两个栈，</span></span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">100</span>);</span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义相关变量</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">' '</span>; <span class="comment">//将每次扫描得到的char保存到ch</span></span><br><span class="line">        String keepNum = <span class="string">""</span>; <span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//依次得到expression 的每一个字符</span></span><br><span class="line">            ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断字符是数字还是运算符，然后做相应的处理;</span></span><br><span class="line">            <span class="keyword">if</span> ( operStack.isOper(ch)) &#123; <span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">//如果如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，</span></span><br><span class="line">                    <span class="comment">// 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，</span></span><br><span class="line">                    <span class="comment">// 然后将当前的操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//然后将当前操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果为空直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果我们发现是一个数字, 就直接入数栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch - 48);</span></span><br><span class="line">                <span class="comment">//1、当处理多位数时，不能发现一个数就立即入栈， 因为它可能是多位数</span></span><br><span class="line">                <span class="comment">//2、在处理数时，需向expression的表达式的index 后再看一位， 如果是数字继续扫描，是符号才入栈</span></span><br><span class="line">                <span class="comment">//3、定义字符串变量用于拼接</span></span><br><span class="line">                 <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line">                <span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字继续扫描， 是符号入栈</span></span><br><span class="line">                    <span class="comment">//只是看后一位，不用index++</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="comment">//如果后一位是运算符， 则入栈keepNum</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//注意清空keepNum ！！！</span></span><br><span class="line">                        keepNum = <span class="string">""</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index + 1， 判断是否扫描到expression结尾</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个结果</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num1 = numStack.pop();</span><br><span class="line">                num2 = numStack.pop();</span><br><span class="line">                oper = operStack.pop();</span><br><span class="line">                res = numStack.cal(num1, num2, oper);</span><br><span class="line">                <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                numStack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后在数栈只有一个数字，就是表达式的结果</span></span><br><span class="line">        System.out.println(<span class="string">"表达式"</span> + expression1 + <span class="string">" = "</span> + numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] stack; <span class="comment">//数组模拟栈，数据就放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>; <span class="comment">//top表示栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前栈顶的值,但不是出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断栈满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断栈空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack["</span> + i + <span class="string">"] = "</span> + stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级, 优先级自己确定，优先级使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，则优先级就越高</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">'*'</span> || oper == <span class="string">'/'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//假定目前的表达式只有+， -， *， /</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">'+'</span> || val == <span class="string">'-'</span> || val == <span class="string">'*'</span> || val == <span class="string">'/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res用于存放计算的结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                res = num2 - num1;  <span class="comment">// 注意返回顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果展示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请输入需要计算的表达式:</span><br><span class="line"><span class="number">5</span> + <span class="number">10</span> * <span class="number">2</span> + <span class="number">20</span> / <span class="number">2</span></span><br><span class="line">表达式<span class="number">5</span>+<span class="number">10</span>*<span class="number">2</span>+<span class="number">20</span>/<span class="number">2</span> = <span class="number">35</span></span><br></pre></td></tr></table></figure>



<p>加油！😘😘🎸🎸</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之栈</title>
    <url>/2020/02/14/Stack/</url>
    <content><![CDATA[<h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><blockquote>
<p>队列是先进先出的数据结构，即FIFO原则，而栈是一种后进先出的数据结构</p>
</blockquote>
<p><img src="/2020/02/14/Stack/stack1.jpg" alt></p>
<h2 id="1、栈的特性"><a href="#1、栈的特性" class="headerlink" title="1、栈的特性"></a>1、栈的特性</h2><ul>
<li><p>“先入后出”（FILO）原则</p>
</li>
<li><p>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。只允许进行插入和删除操作，允许插入和删除的一端，为变化的一端，称为栈顶（Top）,另一端为固定的一端，称为栈底（Bottom）。</p>
</li>
<li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
</li>
</ul>
<h2 id="2、栈的应用"><a href="#2、栈的应用" class="headerlink" title="2、栈的应用"></a>2、栈的应用</h2><ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 </li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求值。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth一first)搜索法。</li>
<li>浏览器的前进和后退功能</li>
</ol>
<h2 id="3、栈的实现"><a href="#3、栈的实现" class="headerlink" title="3、栈的实现"></a>3、栈的实现</h2><blockquote>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
</blockquote>
<h3 id="（1）数组模拟栈"><a href="#（1）数组模拟栈" class="headerlink" title="（1）数组模拟栈"></a>（1）数组模拟栈</h3><p><strong>思路：</strong></p>
<ol>
<li>使用数组来模拟栈</li>
<li>定义一个 top 来表示栈顶，初始化 为 -1</li>
<li>入栈（push）的操作，当有数据加入到栈时， top++; stack[top] = data;</li>
<li>出栈（pop）的操作， int value = stack[top]; top–, return value</li>
<li>当 top = -1; 栈空</li>
<li>当 top = maxSize - 1; 栈满</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试栈</span></span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"show: 显示栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"push: 入栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"pop: 出栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"请选择"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入添加的数据"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = stack.pop();</span><br><span class="line">                        System.out.println(<span class="string">"出栈的数据为"</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] stack; <span class="comment">//数组模拟栈，数据就放在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>; <span class="comment">//top表示栈顶</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断栈满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断栈空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack["</span> + i + <span class="string">"] = "</span> + stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）链表模拟栈"><a href="#（2）链表模拟栈" class="headerlink" title="（2）链表模拟栈"></a>（2）链表模拟栈</h3><p><strong>思路：</strong></p>
<ol>
<li><p>定义一个节点类Node</p>
</li>
<li><p>定义一个头节点 head 表示栈底</p>
</li>
<li><p>入栈（push）的操作，当有数据加入到栈时， 找到栈尾，temp.next = newNode;;</p>
</li>
<li><p>出栈（pop）的操作，遍历到链表尾部的前一个节点，然后将最后一个节点数据返回，并删除最后一个节点</p>
<p>int value = temp.next.data; temp.next = null;  return value;</p>
</li>
<li><p>当 head.next == null; 栈空</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试栈</span></span><br><span class="line">        LinkedListStack stack = <span class="keyword">new</span> LinkedListStack();</span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"show: 显示栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"push: 入栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"pop: 出栈"</span>);</span><br><span class="line">            System.out.println(<span class="string">"请选择"</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入添加的数据"</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = stack.pop();</span><br><span class="line">                        System.out.println(<span class="string">"出栈的数据为"</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个LinkedList栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="comment">//定义一个辅助节点</span></span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表尾部</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表尾部的前一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最后一个节点的值，即栈顶的值</span></span><br><span class="line">        <span class="comment">//删除最后一个节点，即最后一个节点的前一个节点指向为 null</span></span><br><span class="line">        <span class="keyword">int</span> value = temp.next.data;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈, 为了简洁点，从链头开始显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，所以需要一个辅助遍历temp</span></span><br><span class="line">        Node temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp.data);</span><br><span class="line">            <span class="comment">//将next后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之单向环形链表</title>
    <url>/2020/02/13/CircleLinkedList/</url>
    <content><![CDATA[<h1 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h1><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><blockquote>
<p>循环链表跟单链表的区在尾结点指针是指向链表的头结点。和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，采用循环链表实现代码会简洁很多。</p>
</blockquote>
<p><img src="/2020/02/13/CircleLinkedList/circlelinkedlist1.jpg" alt></p>
<h2 id="Josephu问题"><a href="#Josephu问题" class="headerlink" title="Josephu问题"></a>Josephu问题</h2><blockquote>
<p>N个人坐成一个圆环（编号为1 - N），从第1个人开始报数✋，数到K的人出列，后面的人重新从1开始报数。问最后剩下的人的编号。</p>
</blockquote>
<p>👉<strong>思路：</strong></p>
<blockquote>
<p>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
</blockquote>
<h2 id="约瑟夫环-51Nod-1073"><a href="#约瑟夫环-51Nod-1073" class="headerlink" title="约瑟夫环  51Nod - 1073"></a>约瑟夫环  51Nod - 1073</h2><p>例如：N = 3，K = 2。2号先出列，然后是1号，最后剩下的是3号。</p>
<p><strong>Input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2个数N和K，表示N个人，数到K出列。(2 &lt;&#x3D; N, K &lt;&#x3D; 10^6)</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最后剩下的人的编号</span><br></pre></td></tr></table></figure>

<p>Sample Input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>

<p>Sample Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>对于这道OJ题可以通过递归的方法，找到其中的规律便可AC，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + k) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>👉以此题为例，使用单项循环链表的方式实现，<code>但是不能作为此题AC的代码，会超时！</code>思路如下：</p>
<blockquote>
<p>首先构建一个单向的环形链表</p>
</blockquote>
<ol>
<li>先创建第一个节点, 让 first 指向该节点，并形成环形⚪</li>
<li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.f</li>
</ol>
<blockquote>
<p>然后进行报数出圈</p>
</blockquote>
<ol>
<li>需要创建一个辅助指针(变量) helper , 首先让其指向环形链表的最后这个节点</li>
<li>当开始报数时，让first 和 helper 指针同时 的移动  k  - 1 次 🐌🐌</li>
<li>这时就可以将first 指向的节点 出圈<br>first = first .next<br>helper.next = first </li>
<li>然后直到圈内只有最后一个人，即最后一个节点的时候（first == helper）结束循环🔄</li>
<li>最后的first中的编号即为最后一个人的编号</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">        addNode(n);</span><br><span class="line">        countNode(n, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node first = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        Node current = <span class="keyword">null</span>; <span class="comment">// 辅助指针</span></span><br><span class="line">        <span class="comment">//创建一个循环链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">//first指向第一个孩子</span></span><br><span class="line">                first = node;</span><br><span class="line">                first.next = first;</span><br><span class="line">                current = first; <span class="comment">//</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.next = node;</span><br><span class="line">                node.next = first;</span><br><span class="line">                current = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countNode</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个辅助指针helper</span></span><br><span class="line">        Node helper = first;</span><br><span class="line">        <span class="comment">//需要创建一个辅助指针helper，事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.next == first) &#123; <span class="comment">//说明helper指向最后一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当报数时，让first 和 helper指针同时移动 k- 1次，然后出圈</span></span><br><span class="line">        <span class="comment">//这是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first == helper) &#123;<span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">                helper = helper.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这是first指向的节点，就是要出圈的节点</span></span><br><span class="line">            first = first.next;</span><br><span class="line">            helper.next = first;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(first.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Node节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之链表</title>
    <url>/2020/02/12/LinkedList/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="一、链表介绍"><a href="#一、链表介绍" class="headerlink" title="一、链表介绍"></a>一、链表介绍</h2><ol>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>如图：发现链表的各个节点不一定是连续存储.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li>
</ol>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote>
<p>链表通过指针将一组零散的内存块串联在一起，内存块称为链表的“结点”。每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址，叫作后继指针 next。链表有两个特殊的结点，分别是第一个结点（头结点）和最后一个结点（尾结点）。头结点用来记录链表的基地址，用它可以遍历得到整条链表。尾结点指向一个空地址 NULL，表示这是链表上最后一个结点。</p>
</blockquote>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>双向链表支持两个方向，每个结点同时有后继指针 next 指向后面的结点，还有一个前驱指针 pre 指向前面的结点。双向链表需要额外的两个空间来存储后继结点和前驱结点的地址，存储同样的数据，双向链表要比单链表占用更多的内存空间。</p>
</blockquote>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<p>循环链表跟单链表的区在尾结点指针是指向链表的头结点。和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，采用循环链表实现代码会简洁很多。</p>
</blockquote>
<p><strong>内存结构图</strong></p>
<p><img src="/2020/02/12/LinkedList/linkedlist1.png" alt></p>
<p><strong>单链表(带头结点) 逻辑结构图</strong></p>
<p><img src="/2020/02/12/LinkedList/linkedlist2.png" alt></p>
<h2 id="二、单链表应用实例"><a href="#二、单链表应用实例" class="headerlink" title="二、单链表应用实例"></a>二、单链表应用实例</h2><blockquote>
<p>使用head头的单链表实现对水浒传英雄的增删改查等操作</p>
</blockquote>
<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据编号顺序添加</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        System.out.println(<span class="string">"修改2号："</span>);</span><br><span class="line">        HeroNode newHeroNode = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"小卢"</span>, <span class="string">"玉麒麟。。。"</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line">        <span class="comment">//显示</span></span><br><span class="line">        System.out.println(<span class="string">"修改后情况！"</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除一个节点</span></span><br><span class="line">        System.out.println(<span class="string">"删除1号："</span>);</span><br><span class="line">        singleLinkedList.delete(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除后的链表情况"</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（1）添加节点"><a href="#（1）添加节点" class="headerlink" title="（1）添加节点"></a>（1）添加节点</h3><blockquote>
<p>第一种方式，直接添加到链表的尾部</p>
</blockquote>
<p><img src="/2020/02/12/LinkedList/linkedlist3.jpg" alt></p>
<blockquote>
<p>第二种方式，插入节点，可以根据排名插入到指定位置</p>
</blockquote>
<p>思路：</p>
<ol>
<li>需要按照编号的顺序添加</li>
<li>首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定</li>
<li>newNode.next = temp.next</li>
<li>将temp.next = newNode</li>
</ol>
<p><img src="/2020/02/12/LinkedList/linkedlist4.jpg" alt></p>
<h3 id="（2）删除节点"><a href="#（2）删除节点" class="headerlink" title="（2）删除节点"></a>（2）删除节点</h3><p>思路：</p>
<ol>
<li>我们先找到 需要删除的这个节点的前一个节点 temp</li>
<li>temp.next = temp.next.next</li>
<li>被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</li>
</ol>
<p><img src="/2020/02/12/LinkedList/linkedlist5.jpg" alt></p>
<h3 id="（3）修改节点"><a href="#（3）修改节点" class="headerlink" title="（3）修改节点"></a>（3）修改节点</h3><p>思路：</p>
<ol>
<li>通过遍历找到该节点，然后直接重新赋值</li>
<li>temp.data= newNode.data</li>
</ol>
<h3 id="（4）查询节点"><a href="#（4）查询节点" class="headerlink" title="（4）查询节点"></a>（4）查询节点</h3><p>链表的随机访问第 k 个元素，必须根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点， 头节点不要动, 不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单项链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的next 指向 新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//head节点不能动，因此需要一个辅助遍历temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到就把temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next 指向 新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span> <span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一个辅助指针来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123; <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123; <span class="comment">//添加的编号存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//编号存在，不能添加</span></span><br><span class="line">            System.out.println(<span class="string">"准备插入的编号"</span> + heroNode.no +<span class="string">"已经存在了"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no编号来修改</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            System.out.println(<span class="string">"没有找到编号为"</span> +newHeroNode.no + <span class="string">"的节点"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.head 节点不动，需要一个temp辅助节点，找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2.说明我们在比较时，是temp.next.no和待删除的节点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"要删除的"</span>+ no +<span class="string">"这个节点不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，所以需要一个辅助遍历temp</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将next后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span> <span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode [no = "</span>+ no +<span class="string">", name = "</span>+ name +<span class="string">", nickname = "</span>+ nickname +<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果展示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HeroNode [no = <span class="number">1</span>, name = 宋江, nickname = 及时雨]</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢俊义, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">3</span>, name = 吴用, nickname = 智多星]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲, nickname = 豹子头]</span><br><span class="line">修改<span class="number">2</span>号：</span><br><span class="line">修改后情况！</span><br><span class="line">HeroNode [no = <span class="number">1</span>, name = 宋江, nickname = 及时雨]</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">3</span>, name = 吴用, nickname = 智多星]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲, nickname = 豹子头]</span><br><span class="line">删除<span class="number">1</span>号</span><br><span class="line">删除后的链表情况</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">3</span>, name = 吴用, nickname = 智多星]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲, nickname = 豹子头]</span><br></pre></td></tr></table></figure>



<h2 id="三、双链表应用实例"><a href="#三、双链表应用实例" class="headerlink" title="三、双链表应用实例"></a>三、双链表应用实例</h2><h3 id="（1）添加节点-1"><a href="#（1）添加节点-1" class="headerlink" title="（1）添加节点"></a>（1）添加节点</h3><blockquote>
<p>第一种方式，添加到尾部</p>
</blockquote>
<p>思路：</p>
<ol>
<li>先找到双向链表的最后这个节点temp</li>
<li>temp.next = newNode</li>
<li>newNode.pre = temp;</li>
</ol>
<blockquote>
<p>第二种方式，插入节点，可以根据排名插入到指定位置</p>
</blockquote>
<p>思路：</p>
<ol>
<li><p>需要按照编号的顺序添加</p>
</li>
<li><p>首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定</p>
</li>
</ol>
<p>👉<code>需要注意下面代码的先后顺序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newNode.next = temp.next;</span><br><span class="line">   <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      temp.next.pre = newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   temp.next = newNode;</span><br><span class="line">   newNode.pre = temp;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/02/12/LinkedList/linkerlist6.jpg" alt></p>
<h3 id="（2）删除节点-1"><a href="#（2）删除节点-1" class="headerlink" title="（2）删除节点"></a>（2）删除节点</h3><p>思路：</p>
<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如temp</li>
<li>temp.pre.next = temp.next</li>
<li>temp.next.pre = temp.pre;</li>
</ol>
<p><img src="/2020/02/12/LinkedList/linkedlist7.jpg" alt></p>
<h3 id="（3）修改节点-1"><a href="#（3）修改节点-1" class="headerlink" title="（3）修改节点"></a>（3）修改节点</h3><p>👉双链表修改节点思路和单链表思路一样</p>
<h3 id="（4）遍历节点"><a href="#（4）遍历节点" class="headerlink" title="（4）遍历节点"></a>（4）遍历节点</h3><p>👉遍历方式和单链表一样，可以向前遍历也可以向后遍历</p>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"双向链表"</span>);</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero1);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero2);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero3);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(hero4);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据编号顺序添加</span></span><br><span class="line">        doubleLinkedList.addByOrder(hero1);</span><br><span class="line">        doubleLinkedList.addByOrder(hero4);</span><br><span class="line">        doubleLinkedList.addByOrder(hero3);</span><br><span class="line">        doubleLinkedList.addByOrder(hero2);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"修改4号"</span>);</span><br><span class="line">        HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲..."</span>, <span class="string">"豹子..."</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">"修改后："</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"删除吴用"</span>);</span><br><span class="line">        doubleLinkedList.delete(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"删除后："</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点， 头节点不要动, 不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个节点到双向链表的最后</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//head节点不能动，因此需要一个辅助遍历temp</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到就把temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span> <span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一个辅助指针来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123; <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123; <span class="comment">//添加的编号存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//编号存在，不能添加</span></span><br><span class="line">            System.out.println(<span class="string">"准备插入的编号"</span> + heroNode.no +<span class="string">"已经存在了"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">            <span class="comment">//这里格外要注意下面的先后顺序</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = heroNode;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">            heroNode.pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no编号来修改，和单项链表一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            System.out.println(<span class="string">"没有找到编号为"</span> +newHeroNode.no + <span class="string">"的节点"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">// 1. 因为是双向链表，因此，我们可以实现自我删除某个节点</span></span><br><span class="line">    <span class="comment">//2. 直接找到要删除的这个节点，比如temp</span></span><br><span class="line">    <span class="comment">//3. temp.pre.next = temp.next</span></span><br><span class="line">    <span class="comment">//4. temp.next.pre = temp.pre;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 temp = head.next; <span class="comment">//辅助变量</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">//如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"要删除的"</span>+ no +<span class="string">"这个节点不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表,遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，所以需要一个辅助遍历temp</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将next后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode2，每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next; <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre; <span class="comment">//指向前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span> <span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode [no = "</span>+ no +<span class="string">", name = "</span>+ name +<span class="string">", nickname = "</span>+ nickname +<span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现效果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">双向链表</span><br><span class="line">HeroNode [no = <span class="number">1</span>, name = 宋江, nickname = 及时雨]</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢俊义, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">3</span>, name = 吴用, nickname = 智多星]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲, nickname = 豹子头]</span><br><span class="line">修改<span class="number">4</span>号</span><br><span class="line">修改后：</span><br><span class="line">HeroNode [no = <span class="number">1</span>, name = 宋江, nickname = 及时雨]</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢俊义, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">3</span>, name = 吴用, nickname = 智多星]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲..., nickname = 豹子...]</span><br><span class="line">删除吴用</span><br><span class="line">删除后：</span><br><span class="line">HeroNode [no = <span class="number">1</span>, name = 宋江, nickname = 及时雨]</span><br><span class="line">HeroNode [no = <span class="number">2</span>, name = 卢俊义, nickname = 玉麒麟]</span><br><span class="line">HeroNode [no = <span class="number">4</span>, name = 林冲..., nickname = 豹子...]</span><br></pre></td></tr></table></figure>

<h2 id="四、单向环形链表应用场景"><a href="#四、单向环形链表应用场景" class="headerlink" title="四、单向环形链表应用场景"></a>四、单向环形链表应用场景</h2><blockquote>
<p>Josephu（约瑟夫、约瑟夫环）问题</p>
</blockquote>
<p>详细可以看这篇 </p>
<p><a href="https://mr00wang.github.io/2020/02/13/CircleLinkedList/#more">单向环形链表和Josephu</a></p>
<p>加油！！！😘😘</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java算法与数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之队列</title>
    <url>/2020/02/05/Queue/</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>队列是一种特殊的线性结构，它只允许在队列的首部（head/front）进行删除操作，这称为“出队”，而在队列的尾部（tail/rear）进行插入操作，这称为“入队”。当队列中没有元素时（即head == tail），称为空队列。比如买票，每个排队买票的窗口就是一个队列。在这个队列当中，新来的人总是站在队列的最后面，来得越早的人越靠前，也就是越早能买到票，我们称为“先进先出”（First In First Out, FIFO）原则。🚘</p>
</blockquote>
<h2 id="队列的特性"><a href="#队列的特性" class="headerlink" title="队列的特性"></a>队列的特性</h2><ul>
<li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现</li>
<li>在队首删除元素，在队尾插入元素</li>
<li>“先进先出”（FIFO）原则</li>
</ul>
<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><blockquote>
<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
</blockquote>
<h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><ul>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:</p>
</li>
</ul>
<p><img src="/2020/02/05/Queue/queue.png" alt></p>
<ul>
<li>数组模拟队列的数组使用一次便不可使用，即使数组还有空闲空间，也无法往队列里添加，这是就需要进行数据的搬移，复用性不好，可以替换为环形队列。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"(s)show: 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(e)exit: 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(a)add: 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(g)get: 从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(h)head: 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">"取出的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">"队列头的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>; <span class="comment">//指向队列头部，分析出front是指队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>; <span class="comment">//指向队列尾，指向队列尾的数据（即就是队列最后一个数据）</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列满，不能加入数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++; <span class="comment">// 让rear 后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++; <span class="comment">//front 后移</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列的头数据，不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表模拟队列"><a href="#链表模拟队列" class="headerlink" title="链表模拟队列"></a>链表模拟队列</h3><blockquote>
<p>基于链表的实现，需要head 和 tail 两个指针。分别指向链表的第一个和最后一个结点。</p>
<p>入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p>
</blockquote>
<p><strong>图示如下：</strong></p>
<p><img src="/2020/02/05/Queue/queue2.jpg" alt></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//创建一个链表</span></span><br><span class="line">        LinkedListQueue queue = <span class="keyword">new</span> LinkedListQueue();<span class="comment">//设置的是有效数据</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"(s)show: 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(e)exit: 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(a)add: 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(g)get: 从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(h)head: 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object res = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">"取出的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object res = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">"队列头的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用链表模拟队列-编写一个LinkedListQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node front; <span class="comment">//链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node rear; <span class="comment">//链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//队列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        front = rear = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Node节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node next; <span class="comment">//每一个节点</span></span><br><span class="line">        <span class="keyword">private</span> Object data;<span class="comment">//每个节点的数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列,将新节点添加到表尾，然后把新节点设置成新的表尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(data, <span class="keyword">null</span>);</span><br><span class="line">            front = newNode;</span><br><span class="line">            rear = newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = <span class="keyword">new</span> Node(data, <span class="keyword">null</span>);</span><br><span class="line">            rear = rear.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++; <span class="comment">//队列长度加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Object value = front.data;</span><br><span class="line">        front = front.next;</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rear = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历链表所有数据</span></span><br><span class="line">        Node node = front;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">"-&gt;"</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据，不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h3><p><strong>思路如下:</strong></p>
<ul>
<li>front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li>rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 空</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 </li>
<li>我们就可以在原来的队列上修改得到，一个环形队列</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//创建一个环形队列</span></span><br><span class="line">        CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);<span class="comment">//设置的是有效数据</span></span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"(s)show: 显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(e)exit: 退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(a)add: 添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(g)get: 从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"(h)head: 查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">"取出的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">"队列头的数据是"</span> + res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出！"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个CircleQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, </span></span><br><span class="line">    <span class="comment">//也就是说 arr[front] 就是队列的第一个元素 front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">    <span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. </span></span><br><span class="line">    <span class="comment">//因为希望空出一个空间做为约定.rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line"><span class="comment">//        front = 0;</span></span><br><span class="line"><span class="comment">//        rear = 0;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列满，不能加入数据"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移，这里必须考虑取模，也就是循环</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析出front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1.先把front对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">//2.将front后移, 考虑取模</span></span><br><span class="line">        <span class="comment">//3.将临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="comment">//对i进行取模，循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求出当前队列的有效数据的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示队列的头数据，不是取出数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>😎😎 加油！</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之稀疏数组</title>
    <url>/2020/02/02/SparseArray/</url>
    <content><![CDATA[<h1 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><blockquote>
<p>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组,也可以理解为压缩数组。</p>
</blockquote>
<p><strong>稀疏数组的处理方法：</strong></p>
<ol>
<li>记录数组一共有几行几列，有多少个不同的值。</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ol>
<h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><ol>
<li>使用稀疏数组，来保留类似前面的二维数组（棋盘、地图等等）</li>
<li>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</li>
<li>整体思路分析：</li>
</ol>
<blockquote>
<p>首先需要将二维数组转换为稀疏数组，然后再将稀疏数组写入到磁盘文件中</p>
<p>通过磁盘文件读取稀疏数组，然后再转换为原来数组</p>
</blockquote>
<p><img src="/2020/02/02/SparseArray/sparseArray1.jpg" alt></p>
<p><strong>二维数组转稀疏数组的思路：</strong></p>
<ol>
<li>遍历原始的二维数组，得到有效数据的个数sum</li>
<li>根据sum就可以创建稀疏数组 spareArray = int [sum+1] [3]</li>
<li>将二维数组的有效数据存入到稀疏数组</li>
</ol>
<p><strong>稀疏数组转原始数组的思路：</strong></p>
<ol>
<li>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二位数组，比如上面的array = int [11] [11]</li>
<li>在读取稀疏数组后几行的数据，并赋给原始的二维数组即可</li>
</ol>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">//0：表示没有棋子， 1：表示黑子 2：表示白子</span></span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        System.out.println(<span class="string">"原始的二维数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : array) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,value);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* **二维数组转稀疏数组的思路：**</span></span><br><span class="line"><span class="comment">        1. 遍历原始的二维数组，得到有效数据的个数sum</span></span><br><span class="line"><span class="comment">        2. 根据sum就可以创建稀疏数组 spareArray = int [sum+1] [3]</span></span><br><span class="line"><span class="comment">        3. 将二维数组的有效数据存入到稀疏数组*/</span></span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>)</span><br><span class="line">                   sum++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArray = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">       <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值存放到稀疏数组中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArray[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArray[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArray[count][<span class="number">2</span>] = array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"得到的稀疏数组为"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArray.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArray[i][<span class="number">0</span>], sparseArray[i][<span class="number">1</span>], sparseArray[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将稀疏数组恢复到原始数组</span></span><br><span class="line">        <span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二位数组，比如上面的array = int [11] [11]</span></span><br><span class="line">        <span class="keyword">int</span> array2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[ sparseArray[<span class="number">0</span>][<span class="number">0</span>] ][ sparseArray[<span class="number">0</span>][<span class="number">1</span>]] ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行)，并赋给原始的二维数组即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArray.length; i++) &#123;</span><br><span class="line">            array2[ sparseArray[i][<span class="number">0</span>] ][ sparseArray[i][<span class="number">1</span>] ] = sparseArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"恢复后的二维数组为"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : array2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,value);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原始的二维数组：</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"></span><br><span class="line">得到的稀疏数组为</span><br><span class="line"><span class="number">11</span>	<span class="number">11</span>	<span class="number">2</span>	</span><br><span class="line"><span class="number">1</span>	<span class="number">2</span>	<span class="number">1</span>	</span><br><span class="line"><span class="number">2</span>	<span class="number">3</span>	<span class="number">2</span>	</span><br><span class="line"></span><br><span class="line">恢复后的二维数组为</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">2</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	</span><br><span class="line"><span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span>	<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法与数据结构之排序（一）</title>
    <url>/2020/01/21/SortAlgorithm/</url>
    <content><![CDATA[<h1 id="算法与数据结构之排序（一）"><a href="#算法与数据结构之排序（一）" class="headerlink" title="算法与数据结构之排序（一）"></a>算法与数据结构之排序（一）</h1><p>最常用的排序算法：</p>
<p><code>冒泡排序</code>、<code>插入排序</code>、<code>选择排序</code>、<code>希尔排序</code>、<code>归并排序</code>、<code>快速排序</code>、<code>基数排序</code>、<code>桶排序</code>。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡、插入、选择</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>希尔</td>
<td>O(n1.5)</td>
</tr>
<tr>
<td>快排、归并</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>桶、基数</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h2 id="1、桶排序（Bucket-Sort）"><a href="#1、桶排序（Bucket-Sort）" class="headerlink" title="1、桶排序（Bucket Sort）"></a>1、桶排序（Bucket Sort）</h2><p>桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。简单来说就是要将排序的数据分到几个有序的桶里，再将每个桶里的数据进行单独排序。桶内排完序后，再把给桶里的数据按照顺序取出。</p>
<p>举个栗子！（将每个数据分到一个桶）😏😏</p>
<blockquote>
<p>题目：我们需要将6个同学的分数（3，5，3，4，8，9）从大到小进行排序，满分为10分</p>
</blockquote>
<p>  首先我需要定义一个下界为11的数组a[11],初始化为零，表示这些分数还没有人得过。</p>
<p><img src="/2020/01/21/SortAlgorithm/bucketsort1.jpg" alt></p>
<p>  然后开始处理每一个人的分数</p>
<p>  第一个同学分数为3分，则在相对应的a[3]的值基础上加1，a[3]的值从0变1,表示3分出现过一次。</p>
<p><img src="/2020/01/21/SortAlgorithm/bucketsort2.jpg" alt></p>
<p>  第二个人的分数为5，则在相对应的a[5]的值基础上加1，a[5]的值从0变1,表示5分出现过一次。</p>
<p><img src="/2020/01/21/SortAlgorithm/bucketsort3.jpg" alt></p>
<p>  第三个人的分数为3，则在相对应的a[3]的值基础上加1，a[3]的值从1变2,表示3分出现了两次。</p>
<p><img src="/2020/01/21/SortAlgorithm/bucketsort4.jpg" alt></p>
<p>  依此类推，最终结果为下图</p>
<p><img src="/2020/01/21/SortAlgorithm/bucketsort5.jpg" alt></p>
<p>  最后我们将出现的分数打印出来，出现几次就打印几次</p>
<p>Java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">//输入n个数</span></span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 循环读入n个数，并进行桶排序</span></span><br><span class="line">            scores[i] = scanner.nextInt();</span><br><span class="line">            bucket[scores[i]]++; <span class="comment">//进行计数，对应编号为scores[i]的桶放入分数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket[i]; j++) <span class="comment">//出现几次就将桶的编号打印几次</span></span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 5 3 4 8 9</span><br></pre></td></tr></table></figure>

<p>输出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 4 5 8 9</span><br></pre></td></tr></table></figure>

<p>  如果要实现从大到小排序，只需要将<code>for (int i = 0; i &lt; bucket.length; i++)</code>改为<code>for (int i = bucket.length; i &gt; 0; i--)</code></p>
<p>  桶排序就好比有11个桶🛢，编号从0~10.每出现一个数，就在对应编号的桶中放一个篮球🏀，最后只要数数每个桶中有几个篮球🏀就好啦！我们需要<strong>注意的是桶的数量</strong></p>
<p>  最后桶排序时间复杂度为<code>O(M+N)</code>，m为桶的个数，n为待排序数的个数。本次桶排序举的栗子是简化版的，真正的桶排序在分桶的时候，每个桶会有一个范围的数据，然后在桶里在进行排序。</p>
<h2 id="2、冒泡排序（Bubble-Sort）"><a href="#2、冒泡排序（Bubble-Sort）" class="headerlink" title="2、冒泡排序（Bubble Sort）"></a>2、冒泡排序（Bubble Sort）</h2><p>冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把他们交换过来。从第一个元素起。比较相邻的元素，如果第一个比第一个大，就交换。然后继续比较，知道最大的数到最后一个。所有元素重复以上动作。👈</p>
<blockquote>
<p>举个例子，需要对数组a[5,8,3,4,2]进行从小到大排序</p>
</blockquote>
<p>从小到大排序就需要将最大的数冒到最后面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++)&#123; <span class="comment">// 5个数排序，只用进行n-1趟，即4趟</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">          <span class="comment">//从第1位开始比较直到最后一个归位的数，i可以认为为已经归位了几个数字</span></span><br><span class="line"><span class="comment">//第一趟 i = 0</span></span><br><span class="line">第一次: <span class="number">5</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> (j = <span class="number">0</span>)</span><br><span class="line">第二次: <span class="number">5</span> <span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">2</span> (j = <span class="number">1</span>)</span><br><span class="line">第三次: <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span> <span class="number">2</span> (j = <span class="number">2</span>)</span><br><span class="line">第四次: <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> (j = <span class="number">3</span>) <span class="comment">//8归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二趟 i = 1</span></span><br><span class="line">第一次: <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span> <span class="number">8</span> (j = <span class="number">0</span>)</span><br><span class="line">第二次: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> (j = <span class="number">1</span>)</span><br><span class="line">第三次: <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> (j = <span class="number">2</span>) <span class="comment">//5归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三趟 i = 2</span></span><br><span class="line">第一次: <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> (j = <span class="number">0</span>)</span><br><span class="line">第二次: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> (j = <span class="number">1</span>) <span class="comment">//4归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四趟 i = 3</span></span><br><span class="line">第一次: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">8</span> (j = <span class="number">0</span>) <span class="comment">//2归位</span></span><br></pre></td></tr></table></figure>

<p>动态图如下：</p>
<img alt="动态图" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY">



<p>Java代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">//输入n个数</span></span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            scores[i] = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 冒泡排序核心部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">// n个数排序，只用进行n-1趟</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)&#123; <span class="comment">//从第1位开始比较直到最后一个归为的数，i可以认为为已经归为了几个数字</span></span><br><span class="line">                <span class="keyword">if</span> (scores[j] &gt; scores[j + <span class="number">1</span>])&#123; <span class="comment">// 比较大小并交换</span></span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = scores[j];</span><br><span class="line">                    scores[j] = scores[j + <span class="number">1</span>];</span><br><span class="line">                    scores[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> score : scores)</span><br><span class="line">            System.out.print(score + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">8 9 14 2 90 76 46 35 24 57</span><br></pre></td></tr></table></figure>

<p>输出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 8 9 14 24 35 46 57 76 90</span><br></pre></td></tr></table></figure>

<p> 👉 冒泡排序的核心部分是<code>双重嵌套循环。</code></p>
<p> 👉 冒泡排序的时间复杂度为<code>O(N^2)</code></p>
<h2 id="3、快速排序（Qucik-Sort）"><a href="#3、快速排序（Qucik-Sort）" class="headerlink" title="3、快速排序（Qucik Sort）"></a>3、快速排序（Qucik Sort）</h2><p>快速排序基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是基于一种“二分”思想，分治思想。</p>
<blockquote>
<p>举个栗子，将4 1 6 2 9 3进行快速排序</p>
</blockquote>
<p>  首先在这个序列中随便找一个基准数（pivot）。为了方便，通常让第一个数4作为基准数。接下来，需要将这个序列所有比基准数大的数放在4的右边，比基准数小的数放在4的左边，即：</p>
<p>​         2    1    3    <u><strong>4</strong></u>    9    6</p>
<p>  在初始状态下，数字4在序列的第一位。我们需要将4挪到中间的一个位置，假设这个位置是k。现在需要找这个k，并且以k为分界点，左边的数都小于等于4，右边的数都是大于等于4。</p>
<p>  分别从初始序列“4   1   6   2   9   3”两端开始勘测。先从<code>右</code>往<code>左</code>找一个小于4的数，找到后，再从<code>左</code>往<code>右</code>找一个大于4的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。刚开始的时候“哨兵i”指向序列最左边（即i=1）,指向数字4，“哨兵j”指向序列最右边（即j=4）,指向数字3。</p>
<p><img src="/2020/01/21/SortAlgorithm/quicksort1.jpg" alt></p>
<p>  首先哨兵j开始出动。因为基准数设置为最左边的数。哨兵j一步一步向左挪到（即j–），直到找到一个小于4的数停下来，接下来哨兵i再一步一步向右挪动（即i++），直到找到一个大于4的数停下来。最后哨兵j停在了数字3上面，哨兵i停在了数字6上。</p>
<p><img src="/2020/01/21/SortAlgorithm/quicksort2.jpg" alt></p>
<p>  现在交换哨兵i和哨兵j所指向的元素的值。交换后序列如下</p>
<p>  4   1   <u><strong>3</strong></u>   2   9   <u><strong>6</strong></u></p>
<p>  到此，第一次交换结束。接下来哨兵j继续向左挪动。哨兵j找到了数字2后，哨兵i继续向右挪动，然后与哨兵j相遇后，与基准数交换。第一轮勘测结束。此时4左边的数都小于等于4，4右边的数都大于等于4。哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是找大于基准数的数，直到i和j相遇为止。</p>
<p><img src="/2020/01/21/SortAlgorithm/quicksort3.jpg" alt></p>
<p>相遇后与基准数交换后的序列为：</p>
<p>2   1   3    <u><strong>4</strong></u>   9   6</p>
<p>现在基准数4已经归位，此时，我们以4为分界点拆分为两个序列，左边为“2    1    3”，右边序列为“9    6”。接下来我们按照第一轮勘测的方法继续处理。直到不可拆分出新的子序列为止。</p>
<p><img src="/2020/01/21/SortAlgorithm/quicksort4.jpg" alt></p>
<p>最终序列为</p>
<p>1    2    3    4    6    9</p>
<p>动态图如下：</p>
<p><img src="/2020/01/21/SortAlgorithm/quicksort5.gif" alt></p>
<p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(); <span class="comment">//输入n个数</span></span><br><span class="line">        <span class="keyword">int</span>[] scores = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//</span></span><br><span class="line">            scores[i] = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用快速排序函数</span></span><br><span class="line">        <span class="comment">//quickSort(排序的数组，左边范围，右边范围 - 1)</span></span><br><span class="line">        quickSort(scores, <span class="number">0</span>, scores.length - <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> score : scores)</span><br><span class="line">            System.out.print(score + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">int</span> key = a[left]; <span class="comment">//key存的是基准数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="comment">//顺序很重要，要先从右往左边找</span></span><br><span class="line">            <span class="keyword">while</span>(a[j] &gt;= key &amp;&amp; i &lt; j)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="comment">//再从左往右找</span></span><br><span class="line">            <span class="keyword">while</span>(a[i] &lt;= key &amp;&amp; i &lt; j)</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;  <span class="comment">// 当哨兵i和哨兵j没有相遇时</span></span><br><span class="line">                <span class="keyword">int</span> t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终将基准数归位</span></span><br><span class="line">        a[left] = a[i];</span><br><span class="line">        a[i] = key;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归处理</span></span><br><span class="line">        quickSort(a, left, i-<span class="number">1</span>); <span class="comment">// 继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">        quickSort(a, i+<span class="number">1</span>, right); <span class="comment">// 继续处理右边的，这里是一个递归的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">8 9 14 2 90 76 46 35 24 57</span><br></pre></td></tr></table></figure>

<p>输出数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 8 9 14 24 35 46 57 76 90</span><br></pre></td></tr></table></figure>

<p>  快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当<br>然在坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的差时间复杂度和 冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。</p>
<p>未完待续~~😘😘</p>]]></content>
      <categories>
        <category>Java算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学生成绩管理系统</title>
    <url>/2020/01/15/C-Administration/</url>
    <content><![CDATA[<h1 id="C语言-学生成绩管理系统"><a href="#C语言-学生成绩管理系统" class="headerlink" title="C语言 学生成绩管理系统"></a>C语言 学生成绩管理系统</h1><blockquote>
<p>简述：该学生管理系统数据结构采用结构体</p>
</blockquote>
<h1 id="1、系统需求分析"><a href="#1、系统需求分析" class="headerlink" title="1、系统需求分析"></a>1、系统需求分析</h1><h2 id="1-1系统介绍"><a href="#1-1系统介绍" class="headerlink" title="1.1系统介绍"></a>1.1系统介绍</h2><p>本学生管理系统是为教师人员提供管理班级成绩的工具，该系统可以实现的对学生的成绩进行增、删、改、查、信息保存和信息导入等基本功能，以及对学生成绩排序和分段的扩展功能，有利于对学生成绩管理。</p>
<a id="more"></a>

<h2 id="1-2功能性需求"><a href="#1-2功能性需求" class="headerlink" title="1.2功能性需求"></a>1.2功能性需求</h2><p>（1）    成绩录入</p>
<p>（2）    成绩输出、成绩排序（按平均成绩）</p>
<p>（3）    成绩查找</p>
<p>（4）    成绩修改</p>
<p>（5）    删除成绩</p>
<p>（6）    文件存储、文件导入</p>
<h2 id="1-3非功能性需求"><a href="#1-3非功能性需求" class="headerlink" title="1.3非功能性需求"></a>1.3非功能性需求</h2><p>（1）    友好的交互页面</p>
<p>（2）    登陆密码设置</p>
<p>（3）    数据的保护</p>
<h1 id="2、程序结构设计"><a href="#2、程序结构设计" class="headerlink" title="2、程序结构设计"></a>2、程序结构设计</h1><blockquote>
<p>该该系统总体的流程图框架如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">学生成绩管理系统 --&gt;A[登 陆 界 面]</span><br><span class="line">A--&gt;B[菜 单 界 面]</span><br><span class="line">B--&gt;录入成绩</span><br><span class="line">B--&gt;输出成绩</span><br><span class="line">B--&gt;C[成绩排序]</span><br><span class="line">B--&gt;D[成绩查找]</span><br><span class="line">D--&gt;按学号查找</span><br><span class="line">D--&gt;按姓名查找</span><br><span class="line">B--&gt;成绩修改</span><br><span class="line">B--&gt;F[成绩删除]</span><br><span class="line">F--&gt;按学号删除</span><br><span class="line">F--&gt;按姓名删除</span><br><span class="line">B--&gt;E[文件管理]</span><br><span class="line">E--&gt;文件导入</span><br><span class="line">E--&gt;文件保存</span><br></pre></td></tr></table></figure>


<h1 id="3、用户界面设计"><a href="#3、用户界面设计" class="headerlink" title="3、用户界面设计"></a>3、用户界面设计</h1><h2 id="登陆界面"><a href="#登陆界面" class="headerlink" title="登陆界面"></a>登陆界面</h2><blockquote>
<p>登陆界面根据自己的需要进行设计，尽量设计的和谐美观。<br>如我的登陆界面额外添加了获取时间和登陆密码功能！<br>以下展示主要代码和效果展示。</p>
</blockquote>
<blockquote>
<p>获取时间代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">time_t</span> timep;    <span class="comment">//系统时间 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">p_1</span>;</span></span><br><span class="line">time (&amp;timep);</span><br><span class="line">p_1=gmtime(&amp;timep);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t  当前时间%02d时%02d分%\n"</span>,<span class="number">8</span>+p_1-&gt;tm_hour,p_1-&gt;tm_min); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t   %d年%02d月%02d日\n"</span>,<span class="number">1900</span>+p_1-&gt;tm_year,<span class="number">1</span>+p_1-&gt;tm_mon,p_1-&gt;tm_mday);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t\t\t有朋自远方来，不亦乐乎！ \t\t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t*****************************************************\t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t\t\t 学 生 管 理 系 统\t\t\t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t  制作者:Mr.Wang 专业:软件工程1801 学号:************\t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t*****************************************************\t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★\t\t\t  欢迎使用软件工程18-01的学生管理系统,祝您使用愉快! \t\t\t\t★\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★\n\n"</span>);</span><br></pre></td></tr></table></figure>

<p>如图：<img src="https://img-blog.csdnimg.cn/20190328132901443.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="登陆界面"></p>
<h2 id="菜单界面"><a href="#菜单界面" class="headerlink" title="菜单界面"></a>菜单界面</h2><blockquote>
<p>进入页面后设计一个菜单界面，也就是功能界面，在该界面上进行操作</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\t\t★————————————————————————————————————————★\n\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 1. 成绩录入\t\t2. 成绩显示\t\t3. 各科均分  |\n\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 4. 成绩排序\t\t5. 成绩查找\t\t6. 信息修改  |\n\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 7. 删除成绩\t\t8. 成绩分段\t\t0. 退出系统  |\n\n"</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\t\t★————————————————————————————————————————★\n"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>展示如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190328132935285.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="登陆界面"></p>
<h1 id="4、功能设计"><a href="#4、功能设计" class="headerlink" title="4、功能设计"></a>4、功能设计</h1><blockquote>
<p>在该模块中，将会介绍程序的主要功能实现的设计思想和代码</p>
</blockquote>
<h2 id="4-1成绩录入"><a href="#4-1成绩录入" class="headerlink" title="4.1成绩录入"></a>4.1成绩录入</h2><blockquote>
<p>设计思想</p>
</blockquote>
<p>成绩录入是对结构体中班级、姓名、学号和五门成绩的录入，同时加上对五门成绩平均成绩的计算。按照基本的录入，只需用scanf函数对数据输入，用printf函数进行汉字的打印即可。然后进行文件保存该组数据，最后判断是否继续录入。</p>
<blockquote>
<p>流程图如下</p>
<p><img src="https://img-blog.csdnimg.cn/20190328133229893.jpg" alt="input"><br>代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//学生成绩录入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct Student stu[])</span></span>;<span class="comment">//声明保存文件函数</span></span><br><span class="line">    <span class="keyword">int</span> choose;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> tempcla[<span class="number">10</span>]=&#123;<span class="string">"-1"</span>&#125;;  <span class="comment">//定义临时姓名字符串，用于按（-1）返回菜单 </span></span><br><span class="line">    a:</span><br><span class="line">    system(<span class="string">"cls"</span>);    <span class="comment">//清屏</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);    <span class="comment">//清空缓存区 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"成  绩  录  入\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请依次输入\t\t班级、姓名、  学号、     五门课成绩(高数 英语 C语言 计算机基础 软件工程导论)\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"班级(按-1返回菜单)："</span>);  <span class="comment">//输入班级</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].cla)==<span class="number">0</span>)   <span class="comment">//判断返回值，除去类型错误bug </span></span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(stu[count].cla,tempcla)==<span class="number">0</span>)  <span class="comment">//按-1返回菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strlen</span>(stu[count].cla)&gt;<span class="number">10</span>)  <span class="comment">//判断字符长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"班级输入不合理，请重新录入:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].cla);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n姓名："</span>);  <span class="comment">//输入姓名</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].name)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strlen</span>(stu[count].name)&gt;<span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"姓名不合理，请重新录入:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n学号："</span>);    <span class="comment">//输入姓名</span></span><br><span class="line">    w:</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;stu[count].num)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)     <span class="comment">//判断重复学号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stu[count].num==stu[i].num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"已有该学号，请重新输入：\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n高数(0~100)："</span>);  <span class="comment">//输入高数</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">0</span>])==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stu[count].score[<span class="number">0</span>]&lt;<span class="number">0</span>||stu[count].score[<span class="number">0</span>]&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据超出，请重新输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n英语(0~100)："</span>);   <span class="comment">//输入英语</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stu[count].score[<span class="number">1</span>]&lt;<span class="number">0</span>||stu[count].score[<span class="number">1</span>]&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据超出，请重新输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nC语言(0~100)："</span>);  <span class="comment">//输入C语言</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">2</span>])==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stu[count].score[<span class="number">2</span>]&lt;<span class="number">0</span>||stu[count].score[<span class="number">2</span>]&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据超出，请重新输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n计算机基础(0~100)："</span>);  <span class="comment">//输入计算机基础</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">3</span>])==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stu[count].score[<span class="number">3</span>]&lt;<span class="number">0</span>||stu[count].score[<span class="number">3</span>]&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据超出，请重新输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n软件工程导论(0~100)："</span>); <span class="comment">//输入软件工程导论</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">4</span>])==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stu[count].score[<span class="number">4</span>]&lt;<span class="number">0</span>||stu[count].score[<span class="number">4</span>]&gt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"数据超出，请重新输入："</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[count].score[<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    stu[count].aver=(stu[count].score[<span class="number">0</span>]+stu[count].score[<span class="number">1</span>]+stu[count].score[<span class="number">2</span>]+stu[count].score[<span class="number">3</span>]+stu[count].score[<span class="number">4</span>])/<span class="number">5.0</span>;<span class="comment">//计算平均成绩 </span></span><br><span class="line">    count++;   <span class="comment">//结构体数据数+1</span></span><br><span class="line">    save(p);   <span class="comment">//保存文件</span></span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"是否继续录入：\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.是 2.否\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n请选择:"</span>);</span><br><span class="line">    b:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"您输入的格式错误，请重新输入：\n"</span>);</span><br><span class="line">    	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    	<span class="keyword">goto</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">goto</span> a;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"没有该序号，请重新输入："</span>);<span class="keyword">goto</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>部分代码说明</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].cla)==<span class="number">0</span>)   <span class="comment">//判断返回值，除去类型错误bug </span></span><br><span class="line">   &#123;</span><br><span class="line">       fflush(<span class="built_in">stdin</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">//在输入成绩时通常直接使用scanf，但当我们做项目时，为了具有一定的容错性，需要判断输入数据的类型和</span></span><br><span class="line"> <span class="comment">//判断scanf的返回值，如果直接使用scanf，输入其它类型的数据，程序将会炸掉，因此我们需要用这种形式</span></span><br><span class="line"> <span class="comment">//保证系统正常运行</span></span><br></pre></td></tr></table></figure>

<p>scanf的返回值具体解释见他人解释，地址如下：<br>(<a href="https://blog.csdn.net/zhl254467014/article/details/44183567" target="_blank" rel="noopener">https://blog.csdn.net/zhl254467014/article/details/44183567</a>)</p>
<blockquote>
<p>为了方便其它功能的实现，在这里需要判断学号是否重复，保证学号的唯一性</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w:</span><br><span class="line">   fflush(<span class="built_in">stdin</span>);</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;stu[count].num)==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       fflush(<span class="built_in">stdin</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)     <span class="comment">//判断重复学号</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(stu[count].num==stu[i].num)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"已有该学号，请重新输入：\n"</span>);</span><br><span class="line">           <span class="keyword">goto</span> w;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2成绩显示"><a href="#4-2成绩显示" class="headerlink" title="4.2成绩显示"></a>4.2成绩显示</h2><blockquote>
<p>由于我想按照平均成绩排序的方式输出，因此直接调用该函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//学生成绩显示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(struct Student stu[])</span></span>;<span class="comment">//声明平均成绩排序函数</span></span><br><span class="line">    system(<span class="string">"cls"</span>);<span class="comment">//清屏函数</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n您尚未录入学生信息，请返回菜单进行录入！\n"</span>);</span><br><span class="line">    sort(p);    <span class="comment">//排序函数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3成绩排序"><a href="#4-3成绩排序" class="headerlink" title="4.3成绩排序"></a>4.3成绩排序</h2><blockquote>
<p>排序思想：<br>成绩排序是将结构体中的数据按平均成绩进行排序，在本系统中，我将成绩排序非为按五门成绩排序和平均成绩排序，排序的思想是运用冒泡排序。在此功能中需注意的是排序时要将整组数据随着平均成绩一起改变，最后不能出现平均成绩与信息对应不上。其次在进行字符串互换的时候不能直接赋值号进行互换，要用strcpy函数进行复制，在这里只展示按平均成绩排序的代码，其它成绩排序与之相似</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//平均成绩排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">char</span> tempname[<span class="number">20</span>];  <span class="comment">//临时变量</span></span><br><span class="line">    <span class="keyword">char</span> tempcla[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> t1;</span><br><span class="line">    <span class="keyword">float</span> t;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n\n您尚未录入学生信息，请返回菜单进行录入！\n\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n成绩显示(按平均成绩排序)\n"</span>);   <span class="comment">//冒泡排序</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;count-i<span class="number">-1</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(stu[j].aver&lt;stu[j+<span class="number">1</span>].aver)  <span class="comment">//注意字符串的复制 </span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">strcpy</span>(tempcla,stu[j].cla);<span class="built_in">strcpy</span>(stu[j].cla,stu[j+<span class="number">1</span>].cla);<span class="built_in">strcpy</span>(stu[j+<span class="number">1</span>].cla,tempcla);</span><br><span class="line">                        <span class="built_in">strcpy</span>(tempname,stu[j].name);<span class="built_in">strcpy</span>(stu[j].name,stu[j+<span class="number">1</span>].name);<span class="built_in">strcpy</span>(stu[j+<span class="number">1</span>].name,tempname);</span><br><span class="line">                        t1=stu[j].num;stu[j].num=stu[j+<span class="number">1</span>].num;stu[j+<span class="number">1</span>].num=t1;</span><br><span class="line">                        t=stu[j].score[<span class="number">0</span>];stu[j].score[<span class="number">0</span>]=stu[j+<span class="number">1</span>].score[<span class="number">0</span>];stu[j+<span class="number">1</span>].score[<span class="number">0</span>]=t;</span><br><span class="line">                        t=stu[j].score[<span class="number">1</span>];stu[j].score[<span class="number">1</span>]=stu[j+<span class="number">1</span>].score[<span class="number">1</span>];stu[j+<span class="number">1</span>].score[<span class="number">1</span>]=t;</span><br><span class="line">                        t=stu[j].score[<span class="number">2</span>];stu[j].score[<span class="number">2</span>]=stu[j+<span class="number">1</span>].score[<span class="number">2</span>];stu[j+<span class="number">1</span>].score[<span class="number">2</span>]=t;</span><br><span class="line">                        t=stu[j].score[<span class="number">3</span>];stu[j].score[<span class="number">3</span>]=stu[j+<span class="number">1</span>].score[<span class="number">3</span>];stu[j+<span class="number">1</span>].score[<span class="number">3</span>]=t;</span><br><span class="line">                        t=stu[j].score[<span class="number">4</span>];stu[j].score[<span class="number">4</span>]=stu[j+<span class="number">1</span>].score[<span class="number">4</span>];stu[j+<span class="number">1</span>].score[<span class="number">4</span>]=t;</span><br><span class="line">                        t=stu[j].aver;stu[j].aver=stu[j+<span class="number">1</span>].aver;stu[j+<span class="number">1</span>].aver=t;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">    save(p);   <span class="comment">//保存文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4成绩查找"><a href="#4-4成绩查找" class="headerlink" title="4.4成绩查找"></a>4.4成绩查找</h2><blockquote>
<p>设计思想：<br>成绩查找需要实现的是按学号和姓名查找到学生的所有信息，然后打印出来。该功能的思想是输入学号或姓名，然后在循环体中对结构体进行遍历，找到所查到的结构体的下标值，然后将该下标值对应学生的信息打印出来。按照姓名查询时，判断字符串是否相等需要用strcmp函数。在循环体中对结构体进行遍历的时候，找到的时候，可以用break跳出循环，提高效率。</p>
</blockquote>
<blockquote>
<p>流程图如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190328134815840.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="search"></p>
<blockquote>
<p>代码展示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//按学号查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findnum</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> searchindex=<span class="number">-1</span>;  <span class="comment">//定义下表值 </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> searchnum;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n请输入查询成绩的学生学号："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;searchnum);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(searchnum==stu[i].num)</span><br><span class="line">        &#123;</span><br><span class="line">            system(<span class="string">"cls"</span>);</span><br><span class="line">            searchindex=i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//找到后跳出 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(searchindex==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n很抱歉，没有找到该学生的学号！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n按任意键返回成绩查询\n\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//按姓名查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findname</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> searchname[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> searchindex=<span class="number">-1</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n请输入查询成绩学生的姓名：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,searchname);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)  <span class="comment">//循环寻找姓名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(searchname,stu[i].name)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            system(<span class="string">"cls"</span>);</span><br><span class="line">            searchindex=i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//找到跳出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(searchindex==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n很抱歉，没有找到该学生的姓名！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n按任意键返回成绩查询\n\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//成绩查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n您尚未录入学生信息，请返回菜单进行录入！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> choose;</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    choose:   <span class="comment">//成绩查询页面菜单</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\t\t\t\t\t\t  成绩查询\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t*****************************\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t |1.按学号查找 2.按姓名查找|\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t |3.全部显示   4.返回菜单  |\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t*****************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\n请输入查询方式:"</span>);</span><br><span class="line">    a:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入格式有误，请您重新输入："</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	        findnum(p);</span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="keyword">goto</span> choose;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	        findname(p);</span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="keyword">goto</span> choose;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	        <span class="built_in">print</span>(p);</span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="keyword">goto</span> choose;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单！\n\n"</span>);</span><br><span class="line">	        system(<span class="string">"pause"</span>);</span><br><span class="line">	        <span class="keyword">return</span>;</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"没有该序号，请您重新输入："</span>);<span class="keyword">goto</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-5成绩修改"><a href="#4-5成绩修改" class="headerlink" title="4.5成绩修改"></a>4.5成绩修改</h2><blockquote>
<p>该功能与录入成绩功能相似，成绩修改是对结构体中的信息进行修改，首先找到需要修改同学结构体的下标值，然后对该下标值对应的信息进行覆盖修改，该信息修改的录入与成绩录入功能的录入相同，同样需要注意与成绩录入时的漏洞。过多的不说了，直接上代码，依据我的需求，代码较多，仅供参考</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">******************************</span><br><span class="line"><span class="comment">//修改成绩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> choose;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> searchnum,tempnum;</span><br><span class="line">    <span class="keyword">int</span> searchindex=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n您尚未录入学生信息，请返回菜单进行录入！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a:</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n修改成绩！\n\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n请输入修改学生的学号：(按-1返回菜单）"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;searchnum);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span>(searchnum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(searchnum==stu[i].num)</span><br><span class="line">        &#123;</span><br><span class="line">            searchindex=i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n该学生信息：\n"</span>);  <span class="comment">//修改成绩页面菜单</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|1.修改班级\t       2. 修改姓名            |\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|3.修改学号\t       4. 修改高数            |\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|5.修改英语\t       6. 修改C语言           |\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|7.修改计算机基础      8. 修改软件工程导论    |\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"|9.返回菜单\t                              |\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"请选择修改的信息："</span>);</span><br><span class="line">            choose:</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"输入格式有误，请您重新输入："</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span>(choose)</span><br><span class="line">            &#123;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改班级:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[i].cla)==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">strlen</span>(stu[count].cla)&gt;<span class="number">10</span>)  <span class="comment">//判断字符长度</span></span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"班级输入不合理，请重新录入:"</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].cla);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改姓名:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[i].name)==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">strlen</span>(stu[count].name)&gt;<span class="number">10</span>)  <span class="comment">//判断字符长度</span></span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"班级输入不合理，请重新录入:"</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stu[count].name);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改学号:"</span>);</span><br><span class="line">	                w:</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;stu[i].num)==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                tempnum=stu[i].num;</span><br><span class="line">	                stu[i].num=<span class="number">0</span>;</span><br><span class="line">	                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;count;j++)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="keyword">if</span>(tempnum==stu[j].num)</span><br><span class="line">	                    &#123;</span><br><span class="line">	                        <span class="built_in">printf</span>(<span class="string">"已有该学号，请重新输入：\n"</span>);</span><br><span class="line">	                        <span class="keyword">goto</span> w;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	                stu[i].num=tempnum;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改高数:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">0</span>])==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(stu[i].score[<span class="number">0</span>]&lt;<span class="number">0</span>||stu[i].score[<span class="number">0</span>]&gt;<span class="number">100</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">0</span>]);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改英语:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(stu[i].score[<span class="number">1</span>]&lt;<span class="number">0</span>||stu[i].score[<span class="number">1</span>]&gt;<span class="number">100</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">1</span>]);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改C语言:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">2</span>])==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(stu[i].score[<span class="number">2</span>]&lt;<span class="number">0</span>||stu[i].score[<span class="number">2</span>]&gt;<span class="number">100</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">2</span>]);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改计算机基础:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">3</span>])==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(stu[i].score[<span class="number">3</span>]&lt;<span class="number">0</span>||stu[i].score[<span class="number">3</span>]&gt;<span class="number">100</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">3</span>]);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">	                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"请修改软件工程导论:"</span>);</span><br><span class="line">	                <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">4</span>])==<span class="number">0</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">while</span>(stu[i].score[<span class="number">4</span>]&lt;<span class="number">0</span>||stu[i].score[<span class="number">4</span>]&gt;<span class="number">100</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    <span class="built_in">printf</span>(<span class="string">"格式有误，请重新输入："</span>);</span><br><span class="line">	                    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	                    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;stu[i].score[<span class="number">4</span>]);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单！\n\n"</span>);</span><br><span class="line">	                save(p);</span><br><span class="line">	                <span class="keyword">return</span>;</span><br><span class="line">	            <span class="keyword">default</span>:</span><br><span class="line">	                <span class="built_in">printf</span>(<span class="string">"没有该序号，请您重新输入："</span>);</span><br><span class="line">	                <span class="keyword">goto</span> choose;</span><br><span class="line">            &#125;<span class="comment">//switch结尾处 </span></span><br><span class="line">            stu[i].aver=(stu[i].score[<span class="number">0</span>]+stu[i].score[<span class="number">1</span>]+stu[i].score[<span class="number">2</span>]+stu[i].score[<span class="number">3</span>]+stu[i].score[<span class="number">4</span>])/<span class="number">5.0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n修改成功：\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">        &#125;<span class="comment">//if结束处</span></span><br><span class="line">    &#125;<span class="comment">//for结束处</span></span><br><span class="line">    <span class="keyword">if</span>(searchindex==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n很抱歉，未能找到该学生，请重新输入学号!\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">goto</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    save(p);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6成绩删除"><a href="#4-6成绩删除" class="headerlink" title="4.6成绩删除"></a>4.6成绩删除</h2><blockquote>
<p>设计思想:<br>删除成绩是对结构体中的信息进行删除，其实对于C语言无法进行删除本身的意义，只是做出了一些假像，其实删除成绩就是覆盖成绩。删除成绩分为按学号删除和按姓名删除。删除成绩的思想为覆盖，首先通过结构体的遍历找到所删学生信息的下标值，然<br>后从该下标值开始，后面一个学生信息覆盖前面一个学生的信息，最后最关键的一点是将全局变量count即结构体组数-1</p>
</blockquote>
<blockquote>
<p>流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190328135432241.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="delete"><br>代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//删除成绩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delnum</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delname</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="keyword">int</span> choose;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n\n您尚未录入学生信息，请返回菜单进行录入！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    choose:</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);   <span class="comment">//删除成绩页面菜单</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\t\t\t\t\t     删除成绩\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t********************************\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" \t\t\t\t\t   1.按学号删除\n\n\t\t\t\t\t   2.按姓名删除\n\n\t\t\t\t\t   3.返回菜单\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t********************************\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入删除方式："</span>);</span><br><span class="line">    a:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入格式有误，请您重新输入："</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	        delnum(p);</span><br><span class="line">	        save(p);</span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="keyword">goto</span> choose;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	        delname(p);</span><br><span class="line">	        save(p);</span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="keyword">goto</span> choose;</span><br><span class="line">	        <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单！\n\n"</span>);</span><br><span class="line">	        system(<span class="string">"pause"</span>);</span><br><span class="line">	        <span class="keyword">return</span>;</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"没有该序号，请您重新输入："</span>);<span class="keyword">goto</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//按学号删除成绩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delnum</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,choose;</span><br><span class="line">    <span class="keyword">int</span> searchindex=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> deletenum;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除学生的学号(按-1返回）："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;deletenum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"是否确定删除：\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.是 2.否\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请选择:"</span>);</span><br><span class="line">    b:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"您输入的格式错误，请重新输入：\n"</span>);</span><br><span class="line">    	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    	<span class="keyword">goto</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"没有该序号，请重新输入："</span>);<span class="keyword">goto</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deletenum==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回删除成绩！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deletenum==stu[i].num)</span><br><span class="line">        &#123;</span><br><span class="line">            searchindex=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(searchindex==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n很遗憾，未能找到所要删除学生的学号！\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//查找信息后，每组数据往前进行覆盖</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=searchindex;i&lt;count<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(stu[i].cla,stu[i+<span class="number">1</span>].cla);</span><br><span class="line">            stu[i].num=stu[i+<span class="number">1</span>].num;</span><br><span class="line">            <span class="built_in">strcpy</span>(stu[i].name,stu[i+<span class="number">1</span>].name);</span><br><span class="line">            stu[i].score[<span class="number">0</span>]=stu[i+<span class="number">1</span>].score[<span class="number">0</span>];</span><br><span class="line">            stu[i].score[<span class="number">1</span>]=stu[i+<span class="number">1</span>].score[<span class="number">1</span>];</span><br><span class="line">            stu[i].score[<span class="number">2</span>]=stu[i+<span class="number">1</span>].score[<span class="number">2</span>];</span><br><span class="line">            stu[i].score[<span class="number">3</span>]=stu[i+<span class="number">1</span>].score[<span class="number">3</span>];</span><br><span class="line">            stu[i].score[<span class="number">4</span>]=stu[i+<span class="number">1</span>].score[<span class="number">4</span>];</span><br><span class="line">            stu[i].aver=stu[i+<span class="number">1</span>].aver;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;  <span class="comment">//总数据组-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n目前没有学生信息，请返回菜单录入!\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"cls"</span>);  <span class="comment">//删除后进行打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除成功！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单\n\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//按姓名删除成绩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delname</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i,choose;</span><br><span class="line">    <span class="keyword">char</span> tempname[<span class="number">10</span>]=&#123;<span class="string">"-1"</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> searchindex=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> deletename[<span class="number">20</span>];</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除学生的姓名（按-1返回）："</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,deletename);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"是否确定删除：\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.是 2.否\n"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请选择:"</span>);</span><br><span class="line">    b:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"您输入的格式错误，请重新输入：\n"</span>);</span><br><span class="line">    	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    	<span class="keyword">goto</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">return</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">"没有该序号，请重新输入："</span>);<span class="keyword">goto</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(deletename,tempname)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回删除成绩！\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(deletename,stu[i].name)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            searchindex=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(searchindex==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n很遗憾，未能找到所要删除学生的姓名！\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=searchindex;i&lt;count<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(stu[i].cla,stu[i+<span class="number">1</span>].cla);</span><br><span class="line">            stu[i].num=stu[i+<span class="number">1</span>].num;</span><br><span class="line">            <span class="built_in">strcpy</span>(stu[i].name,stu[i+<span class="number">1</span>].name);</span><br><span class="line">            stu[i].score[<span class="number">0</span>]=stu[i+<span class="number">1</span>].score[<span class="number">0</span>];</span><br><span class="line">            stu[i].score[<span class="number">1</span>]=stu[i+<span class="number">1</span>].score[<span class="number">1</span>];</span><br><span class="line">            stu[i].score[<span class="number">2</span>]=stu[i+<span class="number">1</span>].score[<span class="number">2</span>];</span><br><span class="line">            stu[i].score[<span class="number">3</span>]=stu[i+<span class="number">1</span>].score[<span class="number">3</span>];</span><br><span class="line">            stu[i].score[<span class="number">4</span>]=stu[i+<span class="number">1</span>].score[<span class="number">4</span>];</span><br><span class="line">            stu[i].aver=stu[i+<span class="number">1</span>].aver;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除成功！\n\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n目前没有学生信息，请返回菜单录入!\n\n"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n删除成功！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t班级\t姓名\t学号\t\t高数\t英语\tC语言\t计算机基础\t软件工程导论\t平均成绩\t\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"************************************************************************************************************\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                   stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n按任意键返回菜单\n\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>核心代码如下，请好好理解</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(deletenum==stu[i].num)</span><br><span class="line">     &#123;</span><br><span class="line">          searchindex=i;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//查找信息后，每组数据往前进行覆盖</span></span><br><span class="line"> <span class="keyword">for</span>(i=searchindex;i&lt;count<span class="number">-1</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">         <span class="built_in">strcpy</span>(stu[i].cla,stu[i+<span class="number">1</span>].cla);</span><br><span class="line">         stu[i].num=stu[i+<span class="number">1</span>].num;</span><br><span class="line">         <span class="built_in">strcpy</span>(stu[i].name,stu[i+<span class="number">1</span>].name);</span><br><span class="line">         stu[i].score[<span class="number">0</span>]=stu[i+<span class="number">1</span>].score[<span class="number">0</span>];</span><br><span class="line">         stu[i].score[<span class="number">1</span>]=stu[i+<span class="number">1</span>].score[<span class="number">1</span>];</span><br><span class="line">         stu[i].score[<span class="number">2</span>]=stu[i+<span class="number">1</span>].score[<span class="number">2</span>];</span><br><span class="line">         stu[i].score[<span class="number">3</span>]=stu[i+<span class="number">1</span>].score[<span class="number">3</span>];</span><br><span class="line">         stu[i].score[<span class="number">4</span>]=stu[i+<span class="number">1</span>].score[<span class="number">4</span>];</span><br><span class="line">         stu[i].aver=stu[i+<span class="number">1</span>].aver;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;  <span class="comment">//总数据组数-1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-7文件保存"><a href="#4-7文件保存" class="headerlink" title="4.7文件保存"></a>4.7文件保存</h2><blockquote>
<p>文件存储简要介绍：</p>
<p>文件存储是将程序中的数据存储如磁盘中，生成文件。在我们没有进行保存之前，我们每次进入系统都要进行录入，如果数据很多，那么操作十分复杂。所有我们需要对数据进行存储。然后进入系统时进行导入，文件的存储分为两种方法，一种是十进制进行存储，另一种是二进制进行存储。这两种方式都可以对数据进行存储，但每种方式都有其的优点和缺点，对于第一种十进制存储，用fprintf函数对磁盘写入，它的优点是格式化输出，在磁盘中可查看数据，也可进行修改使用方便，容易理解，缺点是由于在输入时要将文件中的ASCII码转换为二进制形式在保存在内存变量中，在输出时又要将内存的二进制形式转换成字符，要花费较多时间。并且数据可被其他人查看和修改，在保存数据时需要进行进制转换，可能会造成数据错误。对于二进制存储，用fwrite函数对磁盘文件进行写，优点是fwrite函数可向文件写一个数据块，在读写时以二进制形式进行的。在向磁盘写数据时，直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上，不需要进制转换，运行速度高。其缺点是生成二进制文件，信息是一堆乱码，但是该文件安全系数高，他人无法查看文件内容，对文件数据进行保护。</p>
</blockquote>
<blockquote>
<p>我的文件是使用二进制存储<br>具体代码如下:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE*fp;</span><br><span class="line">    fp=fopen(<span class="string">"student.bat"</span>,<span class="string">"wb"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fwrite(&amp;stu[i],<span class="keyword">sizeof</span>(struct Student),<span class="number">1</span>,fp)!=<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file write error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n已保存至文件中\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>鉴于有些人使用十进制文件，我这里也写了，代码如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"student.txt"</span>,<span class="string">"w"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"\t%-8s%-8s%-16lld%-8.2lf%-8.2lf%-8.2lf%-16.2lf%-16.2lf%-12.2lf\n"</span>,stu[i].cla,stu[i].name,stu[i].num,stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"save success!\n"</span>);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>

<h2 id="4-7文件保存-1"><a href="#4-7文件保存-1" class="headerlink" title="4.7文件保存"></a>4.7文件保存</h2><blockquote>
<p>简要概述<br>文件导入是对磁盘中的数据导入进学生管理系统的结构体中，对数据进行使用。文件导入是与文件存储相对应，十进制导入对应十进制存储，二进制导入对应二进制存储。因此文件导入也分为两种，十进制导入用fscanf，二进制文件导入用fread</p>
</blockquote>
<blockquote>
<p>这里同样展示两种方式<br>首先是二进制</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件导入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(struct Student stu[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    FILE*fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"student.bat"</span>,<span class="string">"rb"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fread(&amp;stu[i],<span class="keyword">sizeof</span>(struct Student),<span class="number">1</span>,fp)!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(feof(fp))</span><br><span class="line">            &#123;</span><br><span class="line">                fclose(fp);</span><br><span class="line">                <span class="keyword">goto</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file read error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;  <span class="comment">//存入一个，数据组数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    a:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n导入文件已成功，祝您使用愉快！\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请按任意键进入页面菜单！\n\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二进制形式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(num!=EOF)&#123;</span><br><span class="line">		   num=<span class="built_in">fscanf</span>(fp,<span class="string">"%s %s %lld %f %f %f %f %f %f\n"</span>,stu[i].cla,stu[i].name,stu[i].num,</span><br><span class="line">                 stu[i].score[<span class="number">0</span>],stu[i].score[<span class="number">1</span>],stu[i].score[<span class="number">2</span>],stu[i].score[<span class="number">3</span>],stu[i].score[<span class="number">4</span>],stu[i].aver);</span><br><span class="line">		    count++;  <span class="comment">//存入一个，数据组数+1</span></span><br><span class="line">&#125;</span><br><span class="line">	count--;</span><br></pre></td></tr></table></figure>

<h2 id="4-8主函数代码"><a href="#4-8主函数代码" class="headerlink" title="4.8主函数代码"></a>4.8主函数代码</h2><blockquote>
<p>主函数代码展示</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//*************************************</span></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"color 9E"</span>); <span class="comment">//设置背景颜色</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> code[<span class="number">20</span>]=&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>&#125;,password[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">    <span class="comment">//初始页面</span></span><br><span class="line">    <span class="keyword">time_t</span> timep;    <span class="comment">//系统时间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">p_1</span>;</span></span><br><span class="line">	time (&amp;timep);</span><br><span class="line">	p_1=gmtime(&amp;timep);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t  当前时间%02d时%02d分%\n"</span>,<span class="number">8</span>+p_1-&gt;tm_hour,p_1-&gt;tm_min); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t   %d年%02d月%02d日\n"</span>,<span class="number">1900</span>+p_1-&gt;tm_year,<span class="number">1</span>+p_1-&gt;tm_mon,p_1-&gt;tm_mday);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t\t\t有朋自远方来，不亦乐乎！ \t\t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t*****************************************************\t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t\t\t 学 生 管 理 系 统\t\t\t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t  制作者:Mr.Wang 专业:软件工程1801 学号:************\t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t*****************************************************\t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★\t\t\t  欢迎使用软件工程18-01的学生管理系统,祝您使用愉快! \t\t\t\t★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★\n\n"</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入六位登陆密码！\n"</span>);</span><br><span class="line">	q:</span><br><span class="line">	x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;<span class="number">6</span> &amp;&amp; c!=<span class="number">13</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c=getch();</span><br><span class="line">		<span class="keyword">if</span>(c!=<span class="number">13</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">		password[x++]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	password[x]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(password,code)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n输入密码有误，您还有%d次机会，请重新输入："</span>,i--);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read</span>(p); <span class="comment">//导入文件</span></span><br><span class="line">    system(<span class="string">"cls"</span>);    <span class="comment">//清屏</span></span><br><span class="line">    <span class="comment">//页面菜单</span></span><br><span class="line">    menu:</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">    time (&amp;timep);</span><br><span class="line">	p_1=gmtime(&amp;timep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t   当前时间%02d时%02d分%\n"</span>,<span class="number">8</span>+p_1-&gt;tm_hour,p_1-&gt;tm_min); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t    %d年%02d月%02d日\n"</span>,<span class="number">1900</span>+p_1-&gt;tm_year,<span class="number">1</span>+p_1-&gt;tm_mon,p_1-&gt;tm_mday);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t    页  面  菜  单\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t★————————————————————————————————————————★\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 1. 成绩录入\t\t2. 成绩显示\t\t3. 各科均分  |\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 4. 成绩排序\t\t5. 成绩查找\t\t6. 信息修改  |\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t   | 7. 删除成绩\t\t8. 成绩分段\t\t0. 退出系统  |\n\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t★————————————————————————————————————————★\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t          * \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t         *** \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t        ***** \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t       *******\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t      *********\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t     *********** \n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t ********************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t  ******************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t   ******* ********\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t  *******   ********\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t ******       *******\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t\t\t\t\t\t******          ******\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请选择相应序号："</span>);</span><br><span class="line">    <span class="keyword">int</span> choose;</span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    w:</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choose)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"格式错误，请重新输入："</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(choose)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">case</span> <span class="number">1</span>:   <span class="comment">//成绩录入</span></span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"学生成绩录入\n"</span>);</span><br><span class="line">	        input(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//成绩显示和排序</span></span><br><span class="line">	    	system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"学生成绩显示\n"</span>);</span><br><span class="line">	        <span class="built_in">print</span>(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//均科成绩 </span></span><br><span class="line">	    	system(<span class="string">"cls"</span>);</span><br><span class="line">			average(p);</span><br><span class="line">			<span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//成绩排序</span></span><br><span class="line">	    	 system(<span class="string">"cls"</span>);</span><br><span class="line">	        projectsort(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//成绩查找</span></span><br><span class="line">	        system(<span class="string">"cls"</span>);</span><br><span class="line">	        <span class="built_in">find</span>(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//成绩修改</span></span><br><span class="line">		    system(<span class="string">"cls"</span>);</span><br><span class="line">	        change(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">7</span>:  <span class="comment">//成绩删除</span></span><br><span class="line">		    system(<span class="string">"cls"</span>);</span><br><span class="line">	        del(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">8</span>:  <span class="comment">//成绩分段</span></span><br><span class="line">		    system(<span class="string">"cls"</span>);</span><br><span class="line">	        section(p);</span><br><span class="line">	        <span class="keyword">goto</span> menu;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//退出系统</span></span><br><span class="line">	        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n是否继续退出：\n"</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n1. 是 2. 否\n\n"</span>);</span><br><span class="line">	        back:</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"请选择:"</span>);</span><br><span class="line">	        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a)==<span class="number">0</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	        	<span class="built_in">printf</span>(<span class="string">"您输入格式有误，请重新输入："</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	        <span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">	        &#123;</span><br><span class="line">	            system(<span class="string">"cls"</span>);</span><br><span class="line">	            <span class="comment">//心形图案 </span></span><br><span class="line">	            <span class="keyword">float</span> y, x, b;</span><br><span class="line">	            <span class="keyword">for</span> (y = <span class="number">1.5f</span>;y &gt; <span class="number">-1.5f</span>;y -= <span class="number">0.1f</span>)</span><br><span class="line">	            &#123;</span><br><span class="line">	                <span class="keyword">for</span> (x = <span class="number">-1.5f</span>;x &lt; <span class="number">1.5f</span>;x += <span class="number">0.05f</span>)</span><br><span class="line">	                &#123;</span><br><span class="line">	                    b = x*x + y*y - <span class="number">1</span>;</span><br><span class="line">	                    <span class="built_in">putchar</span>(b*b*b - x*x*y*y*y &lt;= <span class="number">0.0f</span> ? <span class="string">'*'</span> : <span class="string">' '</span>);</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">	            Sleep(<span class="number">1000</span>);  <span class="comment">//休眠 </span></span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"欢迎下次继续使用本产品!\n"</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"正在退出，请稍后."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">	            Sleep(<span class="number">500</span>);</span><br><span class="line">	            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	        &#125;<span class="comment">//if(a==1)结束处 </span></span><br><span class="line">	        <span class="keyword">if</span>(a==<span class="number">2</span>)<span class="keyword">goto</span> menu;</span><br><span class="line">	        <span class="keyword">if</span>(a!=<span class="number">1</span>||a!=<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"输入有误，重新输入:\n"</span>);<span class="keyword">goto</span> back;</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	    	<span class="built_in">printf</span>(<span class="string">"没有该序号！请重新输入："</span>);</span><br><span class="line">        	<span class="keyword">goto</span> w;</span><br><span class="line">	&#125;<span class="comment">//switch结束处 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4、效果展示"><a href="#4、效果展示" class="headerlink" title="4、效果展示"></a>4、效果展示</h1><p><img src="https://img-blog.csdnimg.cn/20190328160536752.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="login"><br><img src="https://img-blog.csdnimg.cn/20190328160559954.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="input">)<img src="https://img-blog.csdnimg.cn/20190328160617783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="printf">)<img src="https://img-blog.csdnimg.cn/20190328160639191.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="sort">)<img src="https://img-blog.csdnimg.cn/2019032816070423.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="change">)<img src="https://img-blog.csdnimg.cn/20190328160715655.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzUzMzUzOA==,size_16,color_FFFFFF,t_70" alt="exit"></p>
<blockquote>
<p>退出时的效果可以自行添加，这里我在csdn上找的时一个心型图案，该图案设计者链接如下：</p>
</blockquote>
<p>(<a href="https://blog.csdn.net/stone15165/article/details/80260580" target="_blank" rel="noopener">https://blog.csdn.net/stone15165/article/details/80260580</a>)</p>
<p>源码在github上：(<a href="https://github.com/Mr00wang/C-language.git" target="_blank" rel="noopener">https://github.com/Mr00wang/C-language.git</a>)<br>以上是该学生管理系统的全部内容，上面没有对各科均分和成绩分段进行展述，如有问题请留言，谢谢！</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
</search>
